{"version":3,"sources":["../../../src/js/money/Bitcoin.js"],"names":[],"mappings":"AAAA;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;AAMA,IAAI,cAAc;;;;;;AAMd,wBAAoB,wBAAU,cAAV,EAA0B;AAC1C,gCAAc,cAAd,CAA6B,cAA7B;;AAEA,eAAO,iBAAiB,QAAQ,oBAAhC;AACH,KAVa;;;;;;;AAiBd,wBAAoB,wBAAU,cAAV,EAA0B;AAC1C,gCAAc,cAAd,CAA6B,cAA7B;;AAEA,eAAO,iBAAiB,QAAQ,mBAAhC;AACH;AArBa,CAAlB;;;AAyBA,mBAAS,SAAT,CAAmB,QAAnB,CAA4B,WAA5B;;;;;;;;;;IASqB,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAuCE,c,EAAgB;;;;AAI/B,gBAAI,QAAQ,mBAAS,aAAT,CAAuB,cAAvB,CAAZ;;;;AAIA,gBAAI,WAAW,mBAAS,WAAT,CAAqB,cAArB,CAAf;;AAEA,gBAAI,QAAJ,EAAc;AACV,wBAAQ,eAAR,CAAwB,QAAxB;AACH;;AAED,mBAAO,oBAAU;AACb,uBAAO,KADM;AAEb,0BAAU;AAFG,aAAV,CAAP;AAIH;;;;;;;;;;oCAOkB,e,EAAiB;AAChC,mBAAO,kBAAQ,YAAR,CAAqB,eAArB,CAAP;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCA8DgB;AACb,mBAAO,OAAP;AACH;;;;;;;;mCAKiB;AACd,mBAAO,SAAP;AACH;;;;;;;;;;;;;;;kCAagB,e,EAAiB;AAC9B,gBAAI,CAAC,eAAL,EAAsB;AAClB,uBAAO,KAAP;AACH;;AAED,gBAAI,WAAW,mBAAS,WAAT,CAAqB,eAArB,CAAf;;AAEA,mBAAO,QAAQ,OAAR,CAAgB,QAAhB,KAA6B,QAAQ,UAAR,CAAmB,QAAnB,CAApC;AACH;;;;;;;;;;;;wCASsB,e,EAAiB;AACpC,gBAAI,CAAC,QAAQ,SAAR,CAAkB,eAAlB,CAAL,EAAyC;AACrC,wCAAc,IAAd,CAAmB,OAAnB,EAA4B,mBAAS,WAAT,CAAqB,eAArB,KAAyC,eAArE;AACH;;AAED,mBAAO,eAAP;AACH;;;;;;4BA5DiC;AAC9B,mBAAO,SAAP;AACH;;;;;;;;;4BAMgC;AAC7B,mBAAO,UAAP;AACH;;;;;;kBA3HgB,O","file":"Bitcoin.js","sourcesContent":["'use strict';\n\nimport Preconditions from \"../Preconditions\";\nimport Currency from \"./Currency\";\nimport Satoshi from \"./Satoshi\";\nimport Money from \"./Money\";\n\n/**\n * @private\n * @type {Converter}\n */\nlet conversions = {\n    /**\n     *\n     * @param {Number} valueInBitcoin\n     * @returns {Number}\n     */\n    'Bitcoin->Satoshi': function (valueInBitcoin) {\n        Preconditions.shouldBeNumber(valueInBitcoin);\n\n        return valueInBitcoin * Bitcoin.SATOSHIS_PER_BITCOIN\n    },\n\n    /**\n     *\n     * @param {Number} valueInSatoshi\n     * @returns {Number}\n     */\n    'Satoshi->Bitcoin': function (valueInSatoshi) {\n        Preconditions.shouldBeNumber(valueInSatoshi);\n\n        return valueInSatoshi * Bitcoin.BITCOIN_PER_SATOSHI;\n    }\n};\n\n// Register our known conversions.\nCurrency.converter.register(conversions);\n\n/**\n * Represents the Bitcoin currency in memory.\n *\n * This class cannot be instantiated. Everything is static and the constructor throws, so treat it like a singleton.\n *\n * @class Bitcoin\n */\nexport default class Bitcoin extends Currency {\n\n    // /**\n    //  *\n    //  * @param {Money} money\n    //  * @param {Number} [places]\n    //  * @returns {String}\n    //  */\n    // static serialize(money, places) {\n    //     let value = this.toBitcoin();\n    //\n    //     if (isNaN(value)) {\n    //         return 'NaN';\n    //     }\n    //\n    //     if (!places) {\n    //         places = 8;\n    //     }\n    //\n    //     let parts = String(value).split('.');\n    //\n    //     if (parts.length === 1) {\n    //         parts.push('0');\n    //     }\n    //\n    //     let needed = places - parts[1].length;\n    //\n    //     for (let i = 0; i < needed; i++) {\n    //         parts[1] += '0';\n    //     }\n    //\n    //     return parts[0] + '.' + parts[1];\n    // }\n\n    /**\n     *\n     * @param {Money|String|Number|null|undefined} valueInBitcoin\n     * @returns {Money}\n     */\n    static fromBitcoin(valueInBitcoin) {\n        /**\n         * @type {Number}\n         */\n        let value = Currency.toValueOrFail(valueInBitcoin);\n        /**\n         * @type {Class.<Currency>|undefined}\n         */\n        let currency = Currency.optCurrency(valueInBitcoin);\n\n        if (currency) {\n            Bitcoin.shouldBeBitcoin(currency);\n        }\n\n        return new Money({\n            value: value,\n            currency: Bitcoin\n        });\n    }\n\n    /**\n     *\n     * @param {Money|String|Number|null|undefined} valueInSatoshis\n     * @returns {Money}\n     */\n    static fromSatoshi(valueInSatoshis) {\n        return Satoshi.fromSatoshis(valueInSatoshis);\n    }\n\n    // /**\n    //  *\n    //  * @param number\n    //  * @returns {Number}\n    //  */\n    // static calculateSatoshisFromBitcoin(number) {\n    //     Preconditions.shouldBeDefined(Currency);\n    //     number = Currency.toValueOrFail(number);\n    //\n    //     if (isNaN(number)) {\n    //         return NaN;\n    //     }\n    //\n    //     if (number === 0) {\n    //         return 0;\n    //     }\n    //\n    //     let str = String(number);\n    //     let sign = (str.indexOf('-') === 0) ? '-' : '';\n    //\n    //     str = str.replace(/^-/, '');\n    //\n    //     if (str.indexOf('e') >= 0) {\n    //         return parseInt(sign + str.replace('.', '').replace(/e-8/, '').replace(/e-7/, '0'), 10);\n    //     } else {\n    //         if (!(/\\./).test(str)) {\n    //             str += '.0';\n    //         }\n    //\n    //         let parts = str.split('.');\n    //\n    //         str = parts[0] + '.' + parts[1].slice(0, 8);\n    //\n    //         while (!(/\\.[0-9]{8}/).test(str)) {\n    //             str += '0';\n    //         }\n    //\n    //         return parseInt(sign + str.replace('.', '').replace(/^0+/, ''), 10);\n    //     }\n    // }\n\n    /**\n     * @return {Number}\n     * @readonly\n     */\n    static get SATOSHIS_PER_BITCOIN() {\n        return 100000000;\n    }\n\n    /**\n     * @return {Number}\n     * @readonly\n     */\n    static get BITCOIN_PER_SATOSHI() {\n        return 0.00000001;\n    }\n\n    /**\n     * @returns {Class<Bitcoin>}\n     */\n    static toClass() {\n        return Bitcoin;\n    }\n\n    /**\n     * @returns {String}\n     */\n    static toString() {\n        return 'Bitcoin';\n    }\n\n\n    //region Detection\n    /**\n     * Detects if you pass in either Money or Currency of type Bitcoin <br>\n     * <br>\n     * Bitcoin -> true <br>\n     * money<Bitcoin> -> true <br>\n     *\n     * @param {Money|Currency|Class<Currency>} moneyOrCurrency\n     * @return {Boolean}\n     */\n    static isBitcoin(moneyOrCurrency) {\n        if (!moneyOrCurrency) {\n            return false;\n        }\n\n        let currency = Currency.optCurrency(moneyOrCurrency);\n\n        return Bitcoin.isClass(currency) || Bitcoin.isInstance(currency);\n    }\n\n    /**\n     * If {@link Bitcoin#isBitcoin} returns false, will throw.\n     *\n     * @param {Money|Currency|Class<Currency>} moneyOrCurrency\n     * @return {Class<Currency>}\n     * @throws {PreconditionsError} if not an instance of Money (for Bitcoin) or the Bitcoin class itself.\n     */\n    static shouldBeBitcoin(moneyOrCurrency) {\n        if (!Bitcoin.isBitcoin(moneyOrCurrency)) {\n            Preconditions.fail(Bitcoin, Currency.optCurrency(moneyOrCurrency) || moneyOrCurrency);\n        }\n\n        return moneyOrCurrency;\n    }\n\n    //endregion\n\n}"]}