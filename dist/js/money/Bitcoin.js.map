{"version":3,"sources":["../../../src/js/money/Bitcoin.js"],"names":[],"mappings":"AAAA;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;AAMA,IAAI,cAAc;;;;;;AAMd,wBAAoB,wBAAU,cAAV,EAA0B;AAC1C,gCAAc,cAAd,CAA6B,cAA7B,EAD0C;;AAG1C,eAAO,iBAAiB,QAAQ,oBAAR,CAHkB;KAA1B;;;;;;;AAWpB,wBAAoB,wBAAU,cAAV,EAA0B;AAC1C,gCAAc,cAAd,CAA6B,cAA7B,EAD0C;;AAG1C,eAAO,iBAAiB,QAAQ,mBAAR,CAHkB;KAA1B;CAjBpB;;;AAyBJ,mBAAS,SAAT,CAAmB,QAAnB,CAA4B,WAA5B;;;;;;;;;;IASqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAuCE,gBAAgB;;;;AAI/B,gBAAI,QAAQ,mBAAS,aAAT,CAAuB,cAAvB,CAAR;;;;AAJ2B,gBAQ3B,WAAW,mBAAS,WAAT,CAAqB,cAArB,CAAX,CAR2B;;AAU/B,gBAAI,QAAJ,EAAc;AACV,wBAAQ,eAAR,CAAwB,QAAxB,EADU;aAAd;;AAIA,mBAAO,oBAAU;AACb,uBAAO,KAAP;AACA,0BAAU,OAAV;aAFG,CAAP,CAd+B;;;;;;;;;;;oCAyBhB,iBAAiB;AAChC,mBAAO,kBAAQ,YAAR,CAAqB,eAArB,CAAP,CADgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAgEnB;AACb,mBAAO,OAAP,CADa;;;;;;;;;mCAOC;AACd,mBAAO,SAAP,CADc;;;;;;;;;;;;;;;;kCAeD,iBAAiB;AAC9B,gBAAI,CAAC,eAAD,EAAkB;AAClB,uBAAO,KAAP,CADkB;aAAtB;;AAIA,gBAAI,WAAW,mBAAS,WAAT,CAAqB,eAArB,CAAX,CAL0B;;AAO9B,mBAAO,QAAQ,OAAR,CAAgB,QAAhB,KAA6B,QAAQ,UAAR,CAAmB,QAAnB,CAA7B,CAPuB;;;;;;;;;;;;;wCAiBX,iBAAiB;AACpC,gBAAI,CAAC,QAAQ,SAAR,CAAkB,eAAlB,CAAD,EAAqC;AACrC,wCAAc,IAAd,CAAmB,OAAnB,EAA4B,mBAAS,WAAT,CAAqB,eAArB,KAAyC,eAAzC,CAA5B,CADqC;aAAzC;;AAIA,mBAAO,eAAP,CALoC;;;;;;;4BAtDN;AAC9B,mBAAO,SAAP,CAD8B;;;;;;;;;;4BAQD;AAC7B,mBAAO,UAAP,CAD6B;;;;WAzHhB","file":"Bitcoin.js","sourcesContent":["'use strict';\r\n\r\nimport Preconditions from \"../Preconditions\";\r\nimport Currency from \"./Currency\";\r\nimport Satoshi from \"./Satoshi\";\r\nimport Money from \"./Money\";\r\n\r\n/**\r\n * @private\r\n * @type {Converter}\r\n */\r\nlet conversions = {\r\n    /**\r\n     *\r\n     * @param {Number} valueInBitcoin\r\n     * @returns {Number}\r\n     */\r\n    'Bitcoin->Satoshi': function (valueInBitcoin) {\r\n        Preconditions.shouldBeNumber(valueInBitcoin);\r\n\r\n        return valueInBitcoin * Bitcoin.SATOSHIS_PER_BITCOIN\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param {Number} valueInSatoshi\r\n     * @returns {Number}\r\n     */\r\n    'Satoshi->Bitcoin': function (valueInSatoshi) {\r\n        Preconditions.shouldBeNumber(valueInSatoshi);\r\n\r\n        return valueInSatoshi * Bitcoin.BITCOIN_PER_SATOSHI;\r\n    }\r\n};\r\n\r\n// Register our known conversions.\r\nCurrency.converter.register(conversions);\r\n\r\n/**\r\n * Represents the Bitcoin currency in memory.\r\n *\r\n * This class cannot be instantiated. Everything is static and the constructor throws, so treat it like a singleton.\r\n *\r\n * @class Bitcoin\r\n */\r\nexport default class Bitcoin extends Currency {\r\n\r\n    // /**\r\n    //  *\r\n    //  * @param {Money} money\r\n    //  * @param {Number} [places]\r\n    //  * @returns {String}\r\n    //  */\r\n    // static serialize(money, places) {\r\n    //     let value = this.toBitcoin();\r\n    //\r\n    //     if (isNaN(value)) {\r\n    //         return 'NaN';\r\n    //     }\r\n    //\r\n    //     if (!places) {\r\n    //         places = 8;\r\n    //     }\r\n    //\r\n    //     let parts = String(value).split('.');\r\n    //\r\n    //     if (parts.length === 1) {\r\n    //         parts.push('0');\r\n    //     }\r\n    //\r\n    //     let needed = places - parts[1].length;\r\n    //\r\n    //     for (let i = 0; i < needed; i++) {\r\n    //         parts[1] += '0';\r\n    //     }\r\n    //\r\n    //     return parts[0] + '.' + parts[1];\r\n    // }\r\n\r\n    /**\r\n     *\r\n     * @param {Money|String|Number|null|undefined} valueInBitcoin\r\n     * @returns {Money}\r\n     */\r\n    static fromBitcoin(valueInBitcoin) {\r\n        /**\r\n         * @type {Number}\r\n         */\r\n        let value = Currency.toValueOrFail(valueInBitcoin);\r\n        /**\r\n         * @type {Class.<Currency>|undefined}\r\n         */\r\n        let currency = Currency.optCurrency(valueInBitcoin);\r\n\r\n        if (currency) {\r\n            Bitcoin.shouldBeBitcoin(currency);\r\n        }\r\n\r\n        return new Money({\r\n            value: value,\r\n            currency: Bitcoin\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Money|String|Number|null|undefined} valueInSatoshis\r\n     * @returns {Money}\r\n     */\r\n    static fromSatoshi(valueInSatoshis) {\r\n        return Satoshi.fromSatoshis(valueInSatoshis);\r\n    }\r\n\r\n    // /**\r\n    //  *\r\n    //  * @param number\r\n    //  * @returns {Number}\r\n    //  */\r\n    // static calculateSatoshisFromBitcoin(number) {\r\n    //     Preconditions.shouldBeDefined(Currency);\r\n    //     number = Currency.toValueOrFail(number);\r\n    //\r\n    //     if (isNaN(number)) {\r\n    //         return NaN;\r\n    //     }\r\n    //\r\n    //     if (number === 0) {\r\n    //         return 0;\r\n    //     }\r\n    //\r\n    //     let str = String(number);\r\n    //     let sign = (str.indexOf('-') === 0) ? '-' : '';\r\n    //\r\n    //     str = str.replace(/^-/, '');\r\n    //\r\n    //     if (str.indexOf('e') >= 0) {\r\n    //         return parseInt(sign + str.replace('.', '').replace(/e-8/, '').replace(/e-7/, '0'), 10);\r\n    //     } else {\r\n    //         if (!(/\\./).test(str)) {\r\n    //             str += '.0';\r\n    //         }\r\n    //\r\n    //         let parts = str.split('.');\r\n    //\r\n    //         str = parts[0] + '.' + parts[1].slice(0, 8);\r\n    //\r\n    //         while (!(/\\.[0-9]{8}/).test(str)) {\r\n    //             str += '0';\r\n    //         }\r\n    //\r\n    //         return parseInt(sign + str.replace('.', '').replace(/^0+/, ''), 10);\r\n    //     }\r\n    // }\r\n\r\n    /**\r\n     * @return {Number}\r\n     * @readonly\r\n     */\r\n    static get SATOSHIS_PER_BITCOIN() {\r\n        return 100000000;\r\n    }\r\n\r\n    /**\r\n     * @return {Number}\r\n     * @readonly\r\n     */\r\n    static get BITCOIN_PER_SATOSHI() {\r\n        return 0.00000001;\r\n    }\r\n\r\n    /**\r\n     * @returns {Class<Bitcoin>}\r\n     */\r\n    static toClass() {\r\n        return Bitcoin;\r\n    }\r\n\r\n    /**\r\n     * @returns {String}\r\n     */\r\n    static toString() {\r\n        return 'Bitcoin';\r\n    }\r\n\r\n\r\n    //region Detection\r\n    /**\r\n     * Detects if you pass in either Money or Currency of type Bitcoin <br>\r\n     * <br>\r\n     * Bitcoin -> true <br>\r\n     * money<Bitcoin> -> true <br>\r\n     *\r\n     * @param {Money|Currency|Class<Currency>} moneyOrCurrency\r\n     * @return {Boolean}\r\n     */\r\n    static isBitcoin(moneyOrCurrency) {\r\n        if (!moneyOrCurrency) {\r\n            return false;\r\n        }\r\n\r\n        let currency = Currency.optCurrency(moneyOrCurrency);\r\n\r\n        return Bitcoin.isClass(currency) || Bitcoin.isInstance(currency);\r\n    }\r\n\r\n    /**\r\n     * If {@link Bitcoin#isBitcoin} returns false, will throw.\r\n     *\r\n     * @param {Money|Currency|Class<Currency>} moneyOrCurrency\r\n     * @return {Class<Currency>}\r\n     * @throws {PreconditionsError} if not an instance of Money (for Bitcoin) or the Bitcoin class itself.\r\n     */\r\n    static shouldBeBitcoin(moneyOrCurrency) {\r\n        if (!Bitcoin.isBitcoin(moneyOrCurrency)) {\r\n            Preconditions.fail(Bitcoin, Currency.optCurrency(moneyOrCurrency) || moneyOrCurrency);\r\n        }\r\n\r\n        return moneyOrCurrency;\r\n    }\r\n\r\n    //endregion\r\n\r\n}"]}