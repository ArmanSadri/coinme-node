{"version":3,"sources":["../../../src/js/money/Bitcoin.js"],"names":[],"mappings":"AAAA;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,IAAI,6BAA6B,kBAAQ,UAAR,CAAjC;;;;;AAKA,IAAI,6BAA6B,kBAAQ,SAAR,CAAjC;;;;;;;;;;IASM,O;;;;;;;;;;;;;;;;;;gCAOiB,c,EAAgB;;;;AAI/B,UAAI,QAAQ,mBAAS,aAAT,CAAuB,cAAvB,CAAZ;;;;AAIA,UAAI,WAAW,mBAAS,WAAT,CAAqB,cAArB,CAAf;;AAEA,UAAI,QAAJ,EAAc;AACV,gBAAQ,eAAR,CAAwB,QAAxB;AACH;;AAED,aAAO,oBAAU;AACb,eAAO,KADM;AAEb,kBAAU;AAFG,OAAV,CAAP;AAIH;;;;;;;;;;gCAOkB,e,EAAiB;AAChC,aAAO,QAAQ,WAAR,CAAoB,mBAAS,aAAT,CAAuB,eAAvB,EAAwC,GAAxC,CAA4C,QAAQ,oBAApD,CAApB,CAAP;AACH;;;;;;;;;;;;;;8BAqBgB;AACb,aAAO,IAAP;AACH;;;;;;;;+BAKiB;AACd,aAAO,SAAP;AACH;;;;;;;;;;;;;;;8BAYgB,e,EAAiB;AAC9B,UAAI,CAAC,eAAL,EAAsB;AAClB,eAAO,KAAP;AACH;;AAED,UAAI,WAAW,mBAAS,WAAT,CAAqB,eAArB,CAAf;;AAEA,aAAO,QAAQ,OAAR,CAAgB,QAAhB,KAA6B,QAAQ,UAAR,CAAmB,QAAnB,CAApC;AACH;;;;;;;;;;;;oCASsB,e,EAAiB;AACpC,UAAI,CAAC,QAAQ,SAAR,CAAkB,eAAlB,CAAL,EAAyC;AACrC,gCAAc,IAAd,CAAmB,OAAnB,EAA4B,mBAAS,WAAT,CAAqB,eAArB,KAAyC,eAArE;AACH;;AAED,aAAO,eAAP;AACH;;;;;;wBA3DiC;AAC9B,aAAO,0BAAP;AACH;;;;;;;;;wBAMgC;AAC7B,aAAO,0BAAP;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAkIU,O","file":"Bitcoin.js","sourcesContent":["'use strict';\n\nimport Preconditions from \"../Preconditions\";\nimport Currency from \"./Currency\";\nimport Money from \"./Money\";\nimport Big from \"big.js/big\";\n\n//\n// /**\n//  * @private\n//  * @type {Converter}\n//  */\n// let conversions = {\n//\n//     /**\n//      *\n//      * @param {Number} valueInBitcoin\n//      * @returns {Number}\n//      */\n//     'Bitcoin->Satoshi': function (valueInBitcoin) {\n//         Preconditions.shouldBeNumber(valueInBitcoin);\n//\n//         return valueInBitcoin * Bitcoin.SATOSHIS_PER_BITCOIN\n//     },\n//\n//     /**\n//      *\n//      * @param {Number} valueInSatoshi\n//      * @returns {Number}\n//      */\n//     'Satoshi->Bitcoin': function (valueInSatoshi) {\n//         Preconditions.shouldBeNumber(valueInSatoshi);\n//\n//         return valueInSatoshi * Bitcoin.BITCOIN_PER_SATOSHI;\n//     }\n// };\n//\n// // Register our known conversions.\n// Currency.converter.register(conversions);\n\n/**\n * @type {Big|BigJsLibrary.BigJS}\n */\nlet STATIC_BITCOIN_PER_SATOSHI = new Big(0.00000001);\n\n/**\n * @type {Big|BigJsLibrary.BigJS}\n */\nlet STATIC_SATOSHI_PER_BITCOIN = new Big(100000000);\n\n/**\n * Represents the Bitcoin currency in memory.\n *\n * This class cannot be instantiated. Everything is static and the constructor throws, so treat it like a singleton.\n *\n * @class Bitcoin\n */\nclass Bitcoin extends Currency {\n\n    /**\n     *\n     * @param {Money|String|Number|null|undefined|Big|BigJsLibrary.BigJS} valueInBitcoin\n     * @returns {Money}\n     */\n    static fromBitcoin(valueInBitcoin) {\n        /**\n         * @type {Big|BigJsLibrary.BigJS}\n         */\n        let value = Currency.toValueOrFail(valueInBitcoin);\n        /**\n         * @type {Class.<Currency>|undefined}\n         */\n        let currency = Currency.optCurrency(valueInBitcoin);\n\n        if (currency) {\n            Bitcoin.shouldBeBitcoin(currency);\n        }\n\n        return new Money({\n            value: value,\n            currency: Bitcoin\n        });\n    }\n\n    /**\n     *\n     * @param {Money|String|Number|null|undefined} valueInSatoshis\n     * @returns {Money}\n     */\n    static fromSatoshi(valueInSatoshis) {\n        return Bitcoin.fromBitcoin(Currency.toValueOrFail(valueInSatoshis).div(Bitcoin.SATOSHIS_PER_BITCOIN));\n    }\n\n    /**\n     * @return {BigJsLibrary.BigJS}\n     * @readonly\n     */\n    static get SATOSHIS_PER_BITCOIN() {\n        return STATIC_SATOSHI_PER_BITCOIN;\n    }\n\n    /**\n     * @return {BigJsLibrary.BigJS}\n     * @readonly\n     */\n    static get BITCOIN_PER_SATOSHI() {\n        return STATIC_BITCOIN_PER_SATOSHI;\n    }\n\n    /**\n     * @returns {Class<Bitcoin>}\n     */\n    static toClass() {\n        return this;\n    }\n\n    /**\n     * @returns {String}\n     */\n    static toString() {\n        return 'Bitcoin';\n    }\n\n    //region Detection\n    /**\n     * Detects if you pass in either Money or Currency of type Bitcoin <br>\n     * <br>\n     * Bitcoin -> true <br>\n     * money<Bitcoin> -> true <br>\n     *\n     * @param {Money|Currency|Class<Currency>} moneyOrCurrency\n     * @return {Boolean}\n     */\n    static isBitcoin(moneyOrCurrency) {\n        if (!moneyOrCurrency) {\n            return false;\n        }\n\n        let currency = Currency.optCurrency(moneyOrCurrency);\n\n        return Bitcoin.isClass(currency) || Bitcoin.isInstance(currency);\n    }\n\n    /**\n     * If {@link Bitcoin#isBitcoin} returns false, will throw.\n     *\n     * @param {Money|Currency|Class<Currency>} moneyOrCurrency\n     * @return {Class<Currency>}\n     * @throws {PreconditionsError} if not an instance of Money (for Bitcoin) or the Bitcoin class itself.\n     */\n    static shouldBeBitcoin(moneyOrCurrency) {\n        if (!Bitcoin.isBitcoin(moneyOrCurrency)) {\n            Preconditions.fail(Bitcoin, Currency.optCurrency(moneyOrCurrency) || moneyOrCurrency);\n        }\n\n        return moneyOrCurrency;\n    }\n\n    //endregion\n\n}\n\n// /**\n//  *\n//  * @param {Money} money\n//  * @param {Number} [places]\n//  * @returns {String}\n//  */\n// static serialize(money, places) {\n//     let value = this.toBitcoin();\n//\n//     if (isNaN(value)) {\n//         return 'NaN';\n//     }\n//\n//     if (!places) {\n//         places = 8;\n//     }\n//\n//     let parts = String(value).split('.');\n//\n//     if (parts.length === 1) {\n//         parts.push('0');\n//     }\n//\n//     let needed = places - parts[1].length;\n//\n//     for (let i = 0; i < needed; i++) {\n//         parts[1] += '0';\n//     }\n//\n//     return parts[0] + '.' + parts[1];\n// }\n// /**\n//  *\n//  * @param number\n//  * @returns {Number}\n//  */\n// static calculateSatoshisFromBitcoin(number) {\n//     Preconditions.shouldBeDefined(Currency);\n//     number = Currency.toValueOrFail(number);\n//\n//     if (isNaN(number)) {\n//         return NaN;\n//     }\n//\n//     if (number === 0) {\n//         return 0;\n//     }\n//\n//     let str = String(number);\n//     let sign = (str.indexOf('-') === 0) ? '-' : '';\n//\n//     str = str.replace(/^-/, '');\n//\n//     if (str.indexOf('e') >= 0) {\n//         return parseInt(sign + str.replace('.', '').replace(/e-8/, '').replace(/e-7/, '0'), 10);\n//     } else {\n//         if (!(/\\./).test(str)) {\n//             str += '.0';\n//         }\n//\n//         let parts = str.split('.');\n//\n//         str = parts[0] + '.' + parts[1].slice(0, 8);\n//\n//         while (!(/\\.[0-9]{8}/).test(str)) {\n//             str += '0';\n//         }\n//\n//         return parseInt(sign + str.replace('.', '').replace(/^0+/, ''), 10);\n//     }\n// }\n\n// Currency.types.register('Bitcoin', Bitcoin);\n// Currency.types.register('btc', Bitcoin);\n\nexport default Bitcoin;"]}