{"version":3,"sources":["../../../src/js/money/Currency.js"],"names":[],"mappings":"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","file":"Currency.js","sourcesContent":["import Utility from '../Utility';\r\nimport CoreObject from '../CoreObject';\r\nimport Preconditions from '../Preconditions';\r\n// import {Utility, CoreObject, Preconditions} from '../index';\r\nimport Money from \"./Money\";\r\nimport Converter from \"./Converter\";\r\n\r\nlet _converter = new Converter({\r\n    conversions: {\r\n\r\n    }\r\n});\r\n\r\n/**\r\n * @class\r\n */\r\nexport default class Currency extends CoreObject {\r\n\r\n    constructor() {\r\n        super();\r\n        \r\n        // if (this.constructor === Currency) {\r\n            throw new TypeError('Cannot construct Currency instances directly');\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * @return {Converter}\r\n     */\r\n    get converter() {\r\n        return this.toClass().converter;\r\n    }\r\n\r\n    static equals(currency) {\r\n        currency = Currency.optCurrency(currency);\r\n\r\n        if (!Currency.isCurrency(currency)) {\r\n            return false;\r\n        }\r\n\r\n        let clazz1 = this.toClass();\r\n        let clazz2 = currency.toClass();\r\n\r\n        return (clazz1 === clazz2);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Number|Money|String} value\r\n     * @param {Number|Money|String|function|Converter} [optionalConversion]\r\n     * @returns {Money}\r\n     */\r\n    static create(value, optionalConversion) {\r\n        let money = Money.optMoney(\r\n            Currency.toValueOrFail(value), \r\n            Currency.optCurrency(value) || this.getChildCurrencyTypeOrFail());\r\n        \r\n        Money.shouldBeMoney(money);\r\n        \r\n        return money.convertTo(this.getChildCurrencyTypeOrFail(), optionalConversion);\r\n    }\r\n\r\n    static toString() {\r\n        return 'Currency';\r\n    }\r\n\r\n    /**\r\n     * @returns {Converter}\r\n     */\r\n    static get converter() {\r\n        return _converter;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Converter} value\r\n     */\r\n    static set converter(value) {\r\n        _converter = value;\r\n    }\r\n\r\n    /**\r\n     * @param {Money} money\r\n     * @param {Number|Function|Converter} [optionalConversion]\r\n     * @return {Money}\r\n     * @throws {PreconditionsError} if money is not of the correct type.\r\n     */\r\n    static convertFrom(money, optionalConversion) {\r\n        Money.shouldBeMoney(money);\r\n        Money.shouldBeInstance(money);\r\n        \r\n        return money.currency.converter.convert(money, this.getChildCurrencyTypeOrFail(), optionalConversion);\r\n    }\r\n\r\n\r\n    static canConvertFrom(money, optionalConversion) {\r\n        return money.currency.canConvertFrom(money, optionalConversion);\r\n    }\r\n\r\n    //\r\n    // /**\r\n    //  * If you are using it statically on Currency, then the signature is Currency.convertTo(money, destinationCurrency);\r\n    //  * If you are using it on a subclass of Currency, then the signature is Currency.convertTo(money);\r\n    //  *\r\n    //  * @param {Number|Money|String} valueOrMoney\r\n    //  * @param {Currency} [destinationCurrency]\r\n    //  */\r\n    // static convertTo(valueOrMoney, destinationCurrency) {\r\n    //     if (!destinationCurrency) {\r\n    //         destinationCurrency = this.getChildCurrencyTypeOrFail();\r\n    //     } else {\r\n    //         if (this.isChildCurrency()) {\r\n    //\r\n    //         }\r\n    //     }\r\n    //\r\n    //     Currency.shouldBeCurrency(destinationCurrency);\r\n    //\r\n    //     /**\r\n    //      * @type {Currency}\r\n    //      */\r\n    //     let sourceCurrency = (/** @type {Currency} */(destinationCurrency || this.getChildCurrencyTypeOrFail()));\r\n    //\r\n    //     /**\r\n    //      * @type {Money}\r\n    //      */\r\n    //     let money = sourceCurrency.create(valueOrMoney);\r\n    //\r\n    //     return this.converter.convert(money, destinationCurrency);\r\n    // }\r\n\r\n    /**\r\n     * @private\r\n     * @returns {Currency}\r\n     */\r\n    static getChildCurrencyTypeOrFail() {\r\n        var currency = this;\r\n\r\n        Currency.shouldBeCurrency(currency);\r\n\r\n        Preconditions.shouldBeTrue(this.isChildCurrency(), 'Cannot be the Currency class directly. Use a subclass, like Bitcoin. You used: ' + this.toClass().toString());\r\n\r\n        return currency;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @returns {boolean}\r\n     */\r\n    static isChildCurrency() {\r\n        return this.toClass() !== Currency && Currency.isClass(this);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Money|String|Number} valueOrMoney\r\n     * @param {Currency} [defaultCurrency]\r\n     * @returns {Money}\r\n     */\r\n    static toMoney(valueOrMoney, defaultCurrency) {\r\n        let value = Currency.toValueOrFail(valueOrMoney);\r\n        let currency = Currency.optCurrency(valueOrMoney) || Currency.optCurrency(defaultCurrency);\r\n\r\n        if (!currency) {\r\n            currency = this;\r\n        }\r\n\r\n        Currency.shouldBeCurrency(currency);\r\n\r\n        if (Object.getPrototypeOf(currency) === Currency) {\r\n            throw new Error('Cannot have myself as a currency. Must use a subclass, like Bitcoin');\r\n        }\r\n\r\n        return new Money({\r\n            value: value,\r\n            currency: this\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {Class<Currency>|Currency|Object} objectOrCurrency\r\n     * @return {Class<Currency>}\r\n     * @throws error if not a currency type\r\n     */\r\n    static getCurrency(objectOrCurrency) {\r\n        let instance = Currency.optCurrency(objectOrCurrency);\r\n\r\n        Currency.shouldBeCurrency(instance);\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * @param {Class<Currency>|Currency|Object|Money|String} objectOrCurrency\r\n     * @return {Class<Currency>|Currency|undefined}\r\n     */\r\n    static optCurrency(objectOrCurrency) {\r\n        if (Currency.isCurrency(objectOrCurrency)) {\r\n            return objectOrCurrency;\r\n        } else if (Currency.isInstance(objectOrCurrency)) {\r\n            console.log('object', objectOrCurrency);\r\n            return objectOrCurrency.toClass();\r\n        } else if (Money.isInstance(objectOrCurrency)) {\r\n            return objectOrCurrency.currency;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    // static toString(numberOrStringOrMoney, currencyInstanceOrClass) {\r\n    //     Preconditions.shouldBeDefined(Money, 'money should be defined!');\r\n    //\r\n    //     let currency;\r\n    //     let value;\r\n    //\r\n    //     if (numberOrStringOrMoney instanceof Money) {\r\n    //         currency = numberOrStringOrMoney.currency;\r\n    //         value = numberOrStringOrMoney.value;\r\n    //     } else {\r\n    //         currency = Currency.getCurrency(currencyInstanceOrClass);\r\n    //         value = Currency.toValueOrFail(numberOrStringOrMoney);\r\n    //     }\r\n    //\r\n    //     Preconditions.shouldBeDefined(currency);\r\n    //     Currency.shouldBeCurrency(currency);\r\n    //\r\n    //     return currency.toString(value);\r\n    // }\r\n\r\n    /**\r\n     * \r\n     * @param {*} clazz\r\n     * @param {String} [message]\r\n     *\r\n     * @returns {Class<Currency>}\r\n     */\r\n    static shouldBeCurrency(clazz, message) {\r\n        Preconditions.shouldBeClass(clazz, Currency, 'Must be currency: ' + message);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Class<Currency>|Currency|Object|*} object\r\n     * @returns {boolean}\r\n     */\r\n    static isCurrency(object) {\r\n        if (Currency.isClass(object)) {\r\n            return true;\r\n        }\r\n\r\n        if (Currency.isInstance(object)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * If the type is correct, will unwrap to the value.\r\n     * If the type is not correct, will throw an exception.\r\n     *\r\n     * @type {Money|Number|String|undefined|null}\r\n     * @return {Number}\r\n     * @throws err if not correct type.\r\n     */\r\n    static toValueOrFail(numberOrMoney) {\r\n        if (Utility.isNullOrUndefined(numberOrMoney)) {\r\n            return 0;\r\n        } else if (Money.isInstance(numberOrMoney)) {\r\n            return numberOrMoney.value;\r\n        } else if (Utility.isNumber(numberOrMoney)) {\r\n            return numberOrMoney;\r\n        } else if (Utility.isString(numberOrMoney)) {\r\n            return parseFloat(numberOrMoney);\r\n        } else {\r\n            console.log(numberOrMoney);\r\n\r\n            Preconditions.fail('Number|Currency', Utility.typeOf(numberOrMoney), 'This method fails with the wrong type.');\r\n        }\r\n    }\r\n\r\n    static toClass() {\r\n        return this;\r\n    }\r\n\r\n}"]}