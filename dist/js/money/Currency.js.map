{"version":3,"sources":["../../../src/js/money/Currency.js"],"names":["Currency","TypeError","toClass","toString","currency","optCurrency","isCurrency","clazz1","clazz2","value","money","optMoney","toValueOrFail","getChildCurrencyTypeOrFail","shouldBeDefined","shouldBeMoney","shouldBeCurrency","shouldBeTrue","isChildCurrency","isClass","valueOrMoney","defaultCurrency","Error","objectOrCurrency","instance","isInstance","isString","isNumeric","undefined","clazz","message","shouldBeClass","object","numberOrMoney","optValue","fail","typeOf","isNullOrUndefined","isNumber"],"mappings":"AAAA;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;IAGqBA,Q;;;AAEjB,wBAAc;AAAA;;AAGV;AAHU;;AAIV,cAAM,IAAIC,SAAJ,CAAc,8CAAd,CAAN;AACA;AALU;AAMb;;AAED;;;;;;;mCAGW;AACP,mBAAO,KAAKC,OAAL,GAAeC,QAAf,EAAP;AACH;;AAED;AACA;AACA;AACA;AACA;AACA;;;;+BAEcC,Q,EAAU;AACpBA,uBAAWJ,SAASK,WAAT,CAAqBD,QAArB,CAAX;;AAEA,gBAAI,CAACJ,SAASM,UAAT,CAAoBF,QAApB,CAAL,EAAoC;AAChC,uBAAO,KAAP;AACH;;AAED,gBAAIG,SAAS,KAAKL,OAAL,EAAb;AACA,gBAAIM,SAASJ,SAASF,OAAT,EAAb;;AAEA,mBAAQK,WAAWC,MAAnB;AACH;;AAED;;;;;;;;+BAKcC,K,EAAO;AACjB,gBAAIC,QAAQ,gBAAMC,QAAN,CACRX,SAASY,aAAT,CAAuBH,KAAvB,CADQ,EAERT,SAASK,WAAT,CAAqBI,KAArB,KAA+B,KAAKI,0BAAL,EAFvB,CAAZ;;AAIA,oCAAcC,eAAd,CAA8BJ,KAA9B,EAAqC,+BAArC;AACA,4BAAMK,aAAN,CAAoBL,KAApB;;AAEA,mBAAOA,KAAP;AACA;AACH;;AAED;;;;;;mCAGkB;AACd,mBAAO,UAAP;AACH;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"Currency.js","sourcesContent":["'use strict';\n\nimport Utility from \"../Utility\";\nimport CoreObject from \"../CoreObject\";\nimport Preconditions from \"../Preconditions\";\nimport Money from \"./Money\";\nimport Big from \"big.js/big\";\n// import {Utility, CoreObject, Preconditions} from '../index';\n// import Converter from \"./Converter\";\n\n// let _converter = new Converter({\n//     conversions: {\n//\n//     }\n// });\n//\n// let _types = {\n//\n//     /**\n//      *\n//      * @param {String|Class} stringOrClass\n//      * @param {Class} [clazz]\n//      */\n//     register: function(stringOrClass, clazz) {\n//         let name = (stringOrClass.toString().toLowerCase());\n//\n//         if (!clazz && Currency.isClass(stringOrClass)) {\n//             clazz = stringOrClass;\n//         }\n//\n//         this[name] = clazz;\n//\n//         return this;\n//     }\n// };\n\n/**\n * @class\n */\nexport default class Currency extends CoreObject {\n\n    constructor() {\n        super();\n\n        // if (this.constructor === Currency) {\n        throw new TypeError('Cannot construct Currency instances directly');\n        // }\n    }\n\n    /**\n     * @returns {String}\n     */\n    toString() {\n        return this.toClass().toString();\n    }\n\n    // /**\n    //  * @return {Converter}\n    //  */\n    // get converter() {\n    //     return this.toClass().converter;\n    // }\n\n    static equals(currency) {\n        currency = Currency.optCurrency(currency);\n\n        if (!Currency.isCurrency(currency)) {\n            return false;\n        }\n\n        let clazz1 = this.toClass();\n        let clazz2 = currency.toClass();\n\n        return (clazz1 === clazz2);\n    }\n\n    /**\n     *\n     * @param {Number|Money|String} value\n     * @returns {Money}\n     */\n    static create(value) {\n        let money = Money.optMoney(\n            Currency.toValueOrFail(value),\n            Currency.optCurrency(value) || this.getChildCurrencyTypeOrFail());\n\n        Preconditions.shouldBeDefined(money, 'Money.optMoney has failed us.');\n        Money.shouldBeMoney(money);\n\n        return money;\n        // return money.convertTo(this.getChildCurrencyTypeOrFail(), optionalConversion);\n    }\n\n    /**\n     * @returns {String}\n     */\n    static toString() {\n        return 'Currency';\n    }\n\n    // /**\n    //  * @returns {Converter}\n    //  */\n    // static get converter() {\n    //     return _converter;\n    // }\n\n    // /**\n    //  * @returns {{register: function(name:string, type:Currency)}}\n    //  */\n    // static get types() {\n    //     return _types;\n    // }\n\n    // /**\n    //  *\n    //  * @param {Converter} value\n    //  */\n    // static set converter(value) {\n    //     _converter = value;\n    // }\n\n    // /**\n    //  * @param {Money} money\n    //  * @param {Number|Function|Converter} [optionalConversion]\n    //  * @return {Money}\n    //  * @throws {PreconditionsError} if money is not of the correct type.\n    //  */\n    // static convertFrom(money, optionalConversion) {\n    //     Money.shouldBeMoney(money);\n    //     Money.shouldBeInstance(money);\n    //\n    //     return money.currency.converter.convert(money, this.getChildCurrencyTypeOrFail(), optionalConversion);\n    // }\n\n    //\n    // static canConvertFrom(money, optionalConversion) {\n    //     return money.currency.canConvertFrom(money, optionalConversion);\n    // }\n\n    //\n    // /**\n    //  * If you are using it statically on Currency, then the signature is Currency.convertTo(money, destinationCurrency);\n    //  * If you are using it on a subclass of Currency, then the signature is Currency.convertTo(money);\n    //  *\n    //  * @param {Number|Money|String} valueOrMoney\n    //  * @param {Currency} [destinationCurrency]\n    //  */\n    // static convertTo(valueOrMoney, destinationCurrency) {\n    //     if (!destinationCurrency) {\n    //         destinationCurrency = this.getChildCurrencyTypeOrFail();\n    //     } else {\n    //         if (this.isChildCurrency()) {\n    //\n    //         }\n    //     }\n    //\n    //     Currency.shouldBeCurrency(destinationCurrency);\n    //\n    //     /**\n    //      * @type {Currency}\n    //      */\n    //     let sourceCurrency = (/** @type {Currency} */(destinationCurrency || this.getChildCurrencyTypeOrFail()));\n    //\n    //     /**\n    //      * @type {Money}\n    //      */\n    //     let money = sourceCurrency.create(valueOrMoney);\n    //\n    //     return this.converter.convert(money, destinationCurrency);\n    // }\n\n    /**\n     * @private\n     * @returns {Currency}\n     */\n    static getChildCurrencyTypeOrFail() {\n        var currency = this;\n\n        Currency.shouldBeCurrency(currency);\n\n        Preconditions.shouldBeTrue(this.isChildCurrency(), 'Cannot be the Currency class directly. Use a subclass, like Bitcoin. You used: ' + this.toClass().toString());\n\n        return currency;\n    }\n\n    /**\n     * @private\n     * @returns {boolean}\n     */\n    static isChildCurrency() {\n        return this.toClass() !== Currency && Currency.isClass(this);\n    }\n\n    /**\n     *\n     * @param {Money|String|Number} valueOrMoney\n     * @param {Class<Currency>|Currency} [defaultCurrency]\n     * @returns {Money}\n     */\n    static toMoney(valueOrMoney, defaultCurrency) {\n        if (valueOrMoney instanceof Money) {\n            return valueOrMoney;\n        }\n\n        let value = Currency.toValueOrFail(valueOrMoney);\n        let currency = Currency.optCurrency(valueOrMoney) || Currency.optCurrency(defaultCurrency);\n\n        if (!currency) {\n            currency = this.getChildCurrencyTypeOrFail();\n        }\n\n        Currency.shouldBeCurrency(currency);\n\n        if (currency === Currency) {\n        // if (Object.getPrototypeOf(currency) === Currency) {\n            throw new Error(`Cannot have myself as a currency. Must use a subclass, like Bitcoin or USD. This is usually because I do Currency.toMoney() instead of Bitcoin.toMoney()`);\n        }\n\n        return new Money({\n            value: value,\n            currency: currency\n        });\n    }\n\n    /**\n     * @param {Class<Currency>|Currency|Object} objectOrCurrency\n     * @return {Class<Currency>}\n     * @throws error if not a currency type\n     */\n    static getCurrency(objectOrCurrency) {\n        let instance = Currency.optCurrency(objectOrCurrency);\n\n        Currency.shouldBeCurrency(instance, 'Currency not found: ' + objectOrCurrency);\n\n        return instance;\n    }\n\n    /**\n     * @param {Class<Currency>|Currency|Object|Money|String} objectOrCurrency\n     * @return {Class<Currency>|Currency|undefined}\n     */\n    static optCurrency(objectOrCurrency) {\n        if (Currency.isCurrency(objectOrCurrency)) {\n            return objectOrCurrency;\n        } else if (Currency.isInstance(objectOrCurrency)) {\n            return objectOrCurrency.toClass();\n        } else if (Money.isInstance(objectOrCurrency)) {\n            return objectOrCurrency.currency;\n        } else if (Utility.isString(objectOrCurrency)) {\n            // let string = objectOrCurrency.toLowerCase();\n\n            if (Utility.isNumeric(objectOrCurrency)) {\n                return undefined;\n            }\n\n            throw new Error(`Not sure what to do with ${objectOrCurrency}`);\n        }\n\n        return undefined;\n    }\n\n    /**\n     *\n     * @param {*} clazz\n     * @param {String} [message]\n     *\n     * @returns {Class<Currency>}\n     */\n    static shouldBeCurrency(clazz, message) {\n        Preconditions.shouldBeClass(clazz, Currency, 'Must be currency: ' + message);\n\n        return clazz;\n    }\n\n    /**\n     *\n     * @param {Class<Currency>|Currency|Object|*} object\n     * @returns {boolean}\n     */\n    static isCurrency(object) {\n        if (Currency.isClass(object)) {\n            return true;\n        }\n\n        if (Currency.isInstance(object)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * If the type is correct, will unwrap to the value.\n     * If the type is not correct, will throw an exception.\n     *\n     * @type {Money|Number|String|undefined|null|Big|BigJsLibrary.BigJS}\n     * @return {Big|BigJsLibrary.BigJS}\n     * @throws err if not correct type.\n     */\n    static toValueOrFail(numberOrMoney) {\n        let value = this.optValue(numberOrMoney);\n\n        if (value) {\n            return value;\n        } else {\n            Preconditions.fail('Number|Currency', Utility.typeOf(numberOrMoney), `This method fails with the wrong type. You provided ${numberOrMoney} (type: ${Utility.typeOf(numberOrMoney)})`);\n        }\n    }\n\n    /**\n     * Will return undefined if it cannot figure out what to do.\n     * Defaults to Zero.\n     *\n     * @param numberOrMoney\n     * @return {Big|BigJsLibrary.BigJS|undefined}\n     */\n    static optValue(numberOrMoney) {\n        if (Utility.isNullOrUndefined(numberOrMoney)) {\n            return new Big(0);\n        } else if (Money.isInstance(numberOrMoney)) {\n            return numberOrMoney.value;\n        } else if (Utility.isNumber(numberOrMoney)) {\n            return new Big(numberOrMoney);\n        } else if (Utility.isString(numberOrMoney)) {\n            return new Big(numberOrMoney);\n        } else if (numberOrMoney instanceof Big) {\n            return numberOrMoney;\n        } else {\n            return undefined;\n        }\n    }\n}"]}