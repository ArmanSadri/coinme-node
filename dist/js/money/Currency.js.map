{"version":3,"sources":["../../../src/js/money/Currency.js"],"names":[],"mappings":"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","file":"Currency.js","sourcesContent":["import Utility from '../Utility';\nimport CoreObject from '../CoreObject';\nimport Preconditions from '../Preconditions';\n// import {Utility, CoreObject, Preconditions} from '../index';\nimport Money from \"./Money\";\nimport Converter from \"./Converter\";\n\nlet _converter = new Converter({\n    conversions: {\n\n    }\n});\n\n/**\n * @class\n */\nexport default class Currency extends CoreObject {\n\n    constructor() {\n        super();\n        \n        // if (this.constructor === Currency) {\n            throw new TypeError('Cannot construct Currency instances directly');\n        // }\n    }\n\n    /**\n     * @return {Converter}\n     */\n    get converter() {\n        return this.toClass().converter;\n    }\n\n    static equals(currency) {\n        currency = Currency.optCurrency(currency);\n\n        if (!Currency.isCurrency(currency)) {\n            return false;\n        }\n\n        let clazz1 = this.toClass();\n        let clazz2 = currency.toClass();\n\n        return (clazz1 === clazz2);\n    }\n\n    /**\n     *\n     * @param {Number|Money|String} value\n     * @param {Number|Money|String|function|Converter} [optionalConversion]\n     * @returns {Money}\n     */\n    static create(value, optionalConversion) {\n        let money = Money.optMoney(\n            Currency.toValueOrFail(value), \n            Currency.optCurrency(value) || this.getChildCurrencyTypeOrFail());\n        \n        Money.shouldBeMoney(money);\n        \n        return money.convertTo(this.getChildCurrencyTypeOrFail(), optionalConversion);\n    }\n\n    static toString() {\n        return 'Currency';\n    }\n\n    /**\n     * @returns {Converter}\n     */\n    static get converter() {\n        return _converter;\n    }\n\n    /**\n     *\n     * @param {Converter} value\n     */\n    static set converter(value) {\n        _converter = value;\n    }\n\n    /**\n     * @param {Money} money\n     * @param {Number|Function|Converter} [optionalConversion]\n     * @return {Money}\n     * @throws {PreconditionsError} if money is not of the correct type.\n     */\n    static convertFrom(money, optionalConversion) {\n        Money.shouldBeMoney(money);\n        Money.shouldBeInstance(money);\n        \n        return money.currency.converter.convert(money, this.getChildCurrencyTypeOrFail(), optionalConversion);\n    }\n\n\n    static canConvertFrom(money, optionalConversion) {\n        return money.currency.canConvertFrom(money, optionalConversion);\n    }\n\n    //\n    // /**\n    //  * If you are using it statically on Currency, then the signature is Currency.convertTo(money, destinationCurrency);\n    //  * If you are using it on a subclass of Currency, then the signature is Currency.convertTo(money);\n    //  *\n    //  * @param {Number|Money|String} valueOrMoney\n    //  * @param {Currency} [destinationCurrency]\n    //  */\n    // static convertTo(valueOrMoney, destinationCurrency) {\n    //     if (!destinationCurrency) {\n    //         destinationCurrency = this.getChildCurrencyTypeOrFail();\n    //     } else {\n    //         if (this.isChildCurrency()) {\n    //\n    //         }\n    //     }\n    //\n    //     Currency.shouldBeCurrency(destinationCurrency);\n    //\n    //     /**\n    //      * @type {Currency}\n    //      */\n    //     let sourceCurrency = (/** @type {Currency} */(destinationCurrency || this.getChildCurrencyTypeOrFail()));\n    //\n    //     /**\n    //      * @type {Money}\n    //      */\n    //     let money = sourceCurrency.create(valueOrMoney);\n    //\n    //     return this.converter.convert(money, destinationCurrency);\n    // }\n\n    /**\n     * @private\n     * @returns {Currency}\n     */\n    static getChildCurrencyTypeOrFail() {\n        var currency = this;\n\n        Currency.shouldBeCurrency(currency);\n\n        Preconditions.shouldBeTrue(this.isChildCurrency(), 'Cannot be the Currency class directly. Use a subclass, like Bitcoin. You used: ' + this.toClass().toString());\n\n        return currency;\n    }\n\n    /**\n     * @private\n     * @returns {boolean}\n     */\n    static isChildCurrency() {\n        return this.toClass() !== Currency && Currency.isClass(this);\n    }\n\n    /**\n     *\n     * @param {Money|String|Number} valueOrMoney\n     * @param {Currency} [defaultCurrency]\n     * @returns {Money}\n     */\n    static toMoney(valueOrMoney, defaultCurrency) {\n        let value = Currency.toValueOrFail(valueOrMoney);\n        let currency = Currency.optCurrency(valueOrMoney) || Currency.optCurrency(defaultCurrency);\n\n        if (!currency) {\n            currency = this;\n        }\n\n        Currency.shouldBeCurrency(currency);\n\n        if (Object.getPrototypeOf(currency) === Currency) {\n            throw new Error('Cannot have myself as a currency. Must use a subclass, like Bitcoin');\n        }\n\n        return new Money({\n            value: value,\n            currency: this\n        });\n    }\n\n    /**\n     * @param {Class<Currency>|Currency|Object} objectOrCurrency\n     * @return {Class<Currency>}\n     * @throws error if not a currency type\n     */\n    static getCurrency(objectOrCurrency) {\n        let instance = Currency.optCurrency(objectOrCurrency);\n\n        Currency.shouldBeCurrency(instance);\n\n        return instance;\n    }\n\n    /**\n     * @param {Class<Currency>|Currency|Object|Money|String} objectOrCurrency\n     * @return {Class<Currency>|Currency|undefined}\n     */\n    static optCurrency(objectOrCurrency) {\n        if (Currency.isCurrency(objectOrCurrency)) {\n            return objectOrCurrency;\n        } else if (Currency.isInstance(objectOrCurrency)) {\n            console.log('object', objectOrCurrency);\n            return objectOrCurrency.toClass();\n        } else if (Money.isInstance(objectOrCurrency)) {\n            return objectOrCurrency.currency;\n        }\n\n        return undefined;\n    }\n\n    // static toString(numberOrStringOrMoney, currencyInstanceOrClass) {\n    //     Preconditions.shouldBeDefined(Money, 'money should be defined!');\n    //\n    //     let currency;\n    //     let value;\n    //\n    //     if (numberOrStringOrMoney instanceof Money) {\n    //         currency = numberOrStringOrMoney.currency;\n    //         value = numberOrStringOrMoney.value;\n    //     } else {\n    //         currency = Currency.getCurrency(currencyInstanceOrClass);\n    //         value = Currency.toValueOrFail(numberOrStringOrMoney);\n    //     }\n    //\n    //     Preconditions.shouldBeDefined(currency);\n    //     Currency.shouldBeCurrency(currency);\n    //\n    //     return currency.toString(value);\n    // }\n\n    /**\n     * \n     * @param {*} clazz\n     * @param {String} [message]\n     *\n     * @returns {Class<Currency>}\n     */\n    static shouldBeCurrency(clazz, message) {\n        Preconditions.shouldBeClass(clazz, Currency, 'Must be currency: ' + message);\n\n        return clazz;\n    }\n\n    /**\n     *\n     * @param {Class<Currency>|Currency|Object|*} object\n     * @returns {boolean}\n     */\n    static isCurrency(object) {\n        if (Currency.isClass(object)) {\n            return true;\n        }\n\n        if (Currency.isInstance(object)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * If the type is correct, will unwrap to the value.\n     * If the type is not correct, will throw an exception.\n     *\n     * @type {Money|Number|String|undefined|null}\n     * @return {Number}\n     * @throws err if not correct type.\n     */\n    static toValueOrFail(numberOrMoney) {\n        if (Utility.isNullOrUndefined(numberOrMoney)) {\n            return 0;\n        } else if (Money.isInstance(numberOrMoney)) {\n            return numberOrMoney.value;\n        } else if (Utility.isNumber(numberOrMoney)) {\n            return numberOrMoney;\n        } else if (Utility.isString(numberOrMoney)) {\n            return parseFloat(numberOrMoney);\n        } else {\n            console.log(numberOrMoney);\n\n            Preconditions.fail('Number|Currency', Utility.typeOf(numberOrMoney), 'This method fails with the wrong type.');\n        }\n    }\n\n    static toClass() {\n        return this;\n    }\n\n}"]}