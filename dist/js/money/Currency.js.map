{"version":3,"sources":["../../../src/js/money/Currency.js"],"names":[],"mappings":"AAAA;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiCqB,Q;;;AAEjB,wBAAc;AAAA;;;AAAA;;AAIV,cAAM,IAAI,SAAJ,CAAc,8CAAd,CAAN;;AAJU;AAMb;;;;;;;;;mCAKU;AACP,mBAAO,KAAK,OAAL,GAAe,QAAf,EAAP;AACH;;;;;;;;;;;+BASa,Q,EAAU;AACpB,uBAAW,SAAS,WAAT,CAAqB,QAArB,CAAX;;AAEA,gBAAI,CAAC,SAAS,UAAT,CAAoB,QAApB,CAAL,EAAoC;AAChC,uBAAO,KAAP;AACH;;AAED,gBAAI,SAAS,KAAK,OAAL,EAAb;AACA,gBAAI,SAAS,SAAS,OAAT,EAAb;;AAEA,mBAAQ,WAAW,MAAnB;AACH;;;;;;;;;;+BAOa,K,EAAO;AACjB,gBAAI,QAAQ,gBAAM,QAAN,CACR,SAAS,aAAT,CAAuB,KAAvB,CADQ,EAER,SAAS,WAAT,CAAqB,KAArB,KAA+B,KAAK,0BAAL,EAFvB,CAAZ;;AAIA,oCAAc,eAAd,CAA8B,KAA9B,EAAqC,+BAArC;AACA,4BAAM,aAAN,CAAoB,KAApB;;AAEA,mBAAO,KAAP;;AAEH;;;;;;;;mCAKiB;AACd,mBAAO,KAAK,WAAL,CAAiB,IAAxB;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDA8EmC;AAChC,gBAAI,WAAW,IAAf;;AAEA,qBAAS,gBAAT,CAA0B,QAA1B;;AAEA,oCAAc,YAAd,CAA2B,KAAK,eAAL,EAA3B,EAAmD,oFAAoF,KAAK,OAAL,GAAe,QAAf,EAAvI;;AAEA,mBAAO,QAAP;AACH;;;;;;;;;0CAMwB;AACrB,mBAAO,KAAK,OAAL,OAAmB,QAAnB,IAA+B,SAAS,OAAT,CAAiB,IAAjB,CAAtC;AACH;;;;;;;;;;;gCAQc,Y,EAAc,e,EAAiB;AAC1C,gBAAI,QAAQ,SAAS,aAAT,CAAuB,YAAvB,CAAZ;AACA,gBAAI,WAAW,SAAS,WAAT,CAAqB,YAArB,KAAsC,SAAS,WAAT,CAAqB,eAArB,CAArD;;AAEA,gBAAI,CAAC,QAAL,EAAe;AACX,2BAAW,IAAX;AACH;;AAED,qBAAS,gBAAT,CAA0B,QAA1B;;AAEA,gBAAI,OAAO,cAAP,CAAsB,QAAtB,MAAoC,QAAxC,EAAkD;AAC9C,sBAAM,IAAI,KAAJ,CAAU,qEAAV,CAAN;AACH;;AAED,mBAAO,oBAAU;AACb,uBAAO,KADM;AAEb,0BAAU;AAFG,aAAV,CAAP;AAIH;;;;;;;;;;oCAOkB,gB,EAAkB;AACjC,gBAAI,WAAW,SAAS,WAAT,CAAqB,gBAArB,CAAf;;AAEA,qBAAS,gBAAT,CAA0B,QAA1B,EAAoC,yBAAyB,gBAA7D;;AAEA,mBAAO,QAAP;AACH;;;;;;;;;oCAMkB,gB,EAAkB;AACjC,gBAAI,SAAS,UAAT,CAAoB,gBAApB,CAAJ,EAA2C;AACvC,uBAAO,gBAAP;AACH,aAFD,MAEO,IAAI,SAAS,UAAT,CAAoB,gBAApB,CAAJ,EAA2C;AAC9C,uBAAO,iBAAiB,OAAjB,EAAP;AACH,aAFM,MAEA,IAAI,gBAAM,UAAN,CAAiB,gBAAjB,CAAJ,EAAwC;AAC3C,uBAAO,iBAAiB,QAAxB;AACH,aAFM,MAEA,IAAI,kBAAQ,QAAR,CAAiB,gBAAjB,CAAJ,EAAwC;AAC3C,oBAAI,SAAS,iBAAiB,WAAjB,EAAb;;AAEA,uBAAO,KAAK,KAAL,CAAW,MAAX,CAAP;AACH;;AAED,mBAAO,SAAP;AACH;;;;;;;;;;;;yCASuB,K,EAAO,O,EAAS;AACpC,oCAAc,aAAd,CAA4B,KAA5B,EAAmC,QAAnC,EAA6C,uBAAuB,OAApE;;AAEA,mBAAO,KAAP;AACH;;;;;;;;;;mCAOiB,M,EAAQ;AACtB,gBAAI,SAAS,OAAT,CAAiB,MAAjB,CAAJ,EAA8B;AAC1B,uBAAO,IAAP;AACH;;AAED,gBAAI,SAAS,UAAT,CAAoB,MAApB,CAAJ,EAAiC;AAC7B,uBAAO,IAAP;AACH;;AAED,mBAAO,KAAP;AACH;;;;;;;;;;;;;sCAUoB,a,EAAe;AAChC,gBAAI,kBAAQ,iBAAR,CAA0B,aAA1B,CAAJ,EAA8C;AAC1C,uBAAO,kBAAQ,CAAR,CAAP;AACH,aAFD,MAEO,IAAI,gBAAM,UAAN,CAAiB,aAAjB,CAAJ,EAAqC;AACxC,uBAAO,cAAc,KAArB;AACH,aAFM,MAEA,IAAI,kBAAQ,QAAR,CAAiB,aAAjB,CAAJ,EAAqC;AACxC,uBAAO,kBAAQ,aAAR,CAAP;AACH,aAFM,MAEA,IAAI,kBAAQ,QAAR,CAAiB,aAAjB,CAAJ,EAAqC;AACxC,uBAAO,kBAAQ,aAAR,CAAP;AACH,aAFM,MAEA,IAAI,sCAAJ,EAAkC;AACrC,uBAAO,aAAP;AACH,aAFM,MAEA;AACH,wCAAc,IAAd,CAAmB,iBAAnB,EAAsC,kBAAQ,MAAR,CAAe,aAAf,CAAtC,EAAqE,wCAArE;AACH;AACJ;;;kCAEgB;AACb,mBAAO,IAAP;AACH;;;;;;kBA9QgB,Q","file":"Currency.js","sourcesContent":["'use strict';\n\nimport Utility from \"../Utility\";\nimport CoreObject from \"../CoreObject\";\nimport Preconditions from \"../Preconditions\";\nimport Money from \"./Money\";\nimport Big from \"big.js/big\";\n// import {Utility, CoreObject, Preconditions} from '../index';\n// import Converter from \"./Converter\";\n\n// let _converter = new Converter({\n//     conversions: {\n//\n//     }\n// });\n//\n// let _types = {\n//\n//     /**\n//      *\n//      * @param {String|Class} stringOrClass\n//      * @param {Class} [clazz]\n//      */\n//     register: function(stringOrClass, clazz) {\n//         let name = (stringOrClass.toString().toLowerCase());\n//\n//         if (!clazz && Currency.isClass(stringOrClass)) {\n//             clazz = stringOrClass;\n//         }\n//\n//         this[name] = clazz;\n//\n//         return this;\n//     }\n// };\n\n/**\n * @class\n */\nexport default class Currency extends CoreObject {\n\n    constructor() {\n        super();\n\n        // if (this.constructor === Currency) {\n        throw new TypeError('Cannot construct Currency instances directly');\n        // }\n    }\n\n    /**\n     * @returns {String}\n     */\n    toString() {\n        return this.toClass().toString();\n    }\n\n    // /**\n    //  * @return {Converter}\n    //  */\n    // get converter() {\n    //     return this.toClass().converter;\n    // }\n\n    static equals(currency) {\n        currency = Currency.optCurrency(currency);\n\n        if (!Currency.isCurrency(currency)) {\n            return false;\n        }\n\n        let clazz1 = this.toClass();\n        let clazz2 = currency.toClass();\n\n        return (clazz1 === clazz2);\n    }\n\n    /**\n     *\n     * @param {Number|Money|String} value\n     * @returns {Money}\n     */\n    static create(value) {\n        let money = Money.optMoney(\n            Currency.toValueOrFail(value),\n            Currency.optCurrency(value) || this.getChildCurrencyTypeOrFail());\n\n        Preconditions.shouldBeDefined(money, 'Money.optMoney has failed us.');\n        Money.shouldBeMoney(money);\n\n        return money;\n        // return money.convertTo(this.getChildCurrencyTypeOrFail(), optionalConversion);\n    }\n\n    /**\n     * @returns {String}\n     */\n    static toString() {\n        return this.constructor.name;\n    }\n\n    // /**\n    //  * @returns {Converter}\n    //  */\n    // static get converter() {\n    //     return _converter;\n    // }\n\n    // /**\n    //  * @returns {{register: function(name:string, type:Currency)}}\n    //  */\n    // static get types() {\n    //     return _types;\n    // }\n\n    // /**\n    //  *\n    //  * @param {Converter} value\n    //  */\n    // static set converter(value) {\n    //     _converter = value;\n    // }\n\n    // /**\n    //  * @param {Money} money\n    //  * @param {Number|Function|Converter} [optionalConversion]\n    //  * @return {Money}\n    //  * @throws {PreconditionsError} if money is not of the correct type.\n    //  */\n    // static convertFrom(money, optionalConversion) {\n    //     Money.shouldBeMoney(money);\n    //     Money.shouldBeInstance(money);\n    //\n    //     return money.currency.converter.convert(money, this.getChildCurrencyTypeOrFail(), optionalConversion);\n    // }\n\n    //\n    // static canConvertFrom(money, optionalConversion) {\n    //     return money.currency.canConvertFrom(money, optionalConversion);\n    // }\n\n    //\n    // /**\n    //  * If you are using it statically on Currency, then the signature is Currency.convertTo(money, destinationCurrency);\n    //  * If you are using it on a subclass of Currency, then the signature is Currency.convertTo(money);\n    //  *\n    //  * @param {Number|Money|String} valueOrMoney\n    //  * @param {Currency} [destinationCurrency]\n    //  */\n    // static convertTo(valueOrMoney, destinationCurrency) {\n    //     if (!destinationCurrency) {\n    //         destinationCurrency = this.getChildCurrencyTypeOrFail();\n    //     } else {\n    //         if (this.isChildCurrency()) {\n    //\n    //         }\n    //     }\n    //\n    //     Currency.shouldBeCurrency(destinationCurrency);\n    //\n    //     /**\n    //      * @type {Currency}\n    //      */\n    //     let sourceCurrency = (/** @type {Currency} */(destinationCurrency || this.getChildCurrencyTypeOrFail()));\n    //\n    //     /**\n    //      * @type {Money}\n    //      */\n    //     let money = sourceCurrency.create(valueOrMoney);\n    //\n    //     return this.converter.convert(money, destinationCurrency);\n    // }\n\n    /**\n     * @private\n     * @returns {Currency}\n     */\n    static getChildCurrencyTypeOrFail() {\n        var currency = this;\n\n        Currency.shouldBeCurrency(currency);\n\n        Preconditions.shouldBeTrue(this.isChildCurrency(), 'Cannot be the Currency class directly. Use a subclass, like Bitcoin. You used: ' + this.toClass().toString());\n\n        return currency;\n    }\n\n    /**\n     * @private\n     * @returns {boolean}\n     */\n    static isChildCurrency() {\n        return this.toClass() !== Currency && Currency.isClass(this);\n    }\n\n    /**\n     *\n     * @param {Money|String|Number} valueOrMoney\n     * @param {Currency} [defaultCurrency]\n     * @returns {Money}\n     */\n    static toMoney(valueOrMoney, defaultCurrency) {\n        let value = Currency.toValueOrFail(valueOrMoney);\n        let currency = Currency.optCurrency(valueOrMoney) || Currency.optCurrency(defaultCurrency);\n\n        if (!currency) {\n            currency = this;\n        }\n\n        Currency.shouldBeCurrency(currency);\n\n        if (Object.getPrototypeOf(currency) === Currency) {\n            throw new Error('Cannot have myself as a currency. Must use a subclass, like Bitcoin');\n        }\n\n        return new Money({\n            value: value,\n            currency: this\n        });\n    }\n\n    /**\n     * @param {Class<Currency>|Currency|Object} objectOrCurrency\n     * @return {Class<Currency>}\n     * @throws error if not a currency type\n     */\n    static getCurrency(objectOrCurrency) {\n        let instance = Currency.optCurrency(objectOrCurrency);\n\n        Currency.shouldBeCurrency(instance, 'Currency not found: ' + objectOrCurrency);\n\n        return instance;\n    }\n\n    /**\n     * @param {Class<Currency>|Currency|Object|Money|String} objectOrCurrency\n     * @return {Class<Currency>|Currency|undefined}\n     */\n    static optCurrency(objectOrCurrency) {\n        if (Currency.isCurrency(objectOrCurrency)) {\n            return objectOrCurrency;\n        } else if (Currency.isInstance(objectOrCurrency)) {\n            return objectOrCurrency.toClass();\n        } else if (Money.isInstance(objectOrCurrency)) {\n            return objectOrCurrency.currency;\n        } else if (Utility.isString(objectOrCurrency)) {\n            let string = objectOrCurrency.toLowerCase();\n\n            return this.types[string];\n        }\n\n        return undefined;\n    }\n\n    /**\n     *\n     * @param {*} clazz\n     * @param {String} [message]\n     *\n     * @returns {Class<Currency>}\n     */\n    static shouldBeCurrency(clazz, message) {\n        Preconditions.shouldBeClass(clazz, Currency, 'Must be currency: ' + message);\n\n        return clazz;\n    }\n\n    /**\n     *\n     * @param {Class<Currency>|Currency|Object|*} object\n     * @returns {boolean}\n     */\n    static isCurrency(object) {\n        if (Currency.isClass(object)) {\n            return true;\n        }\n\n        if (Currency.isInstance(object)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * If the type is correct, will unwrap to the value.\n     * If the type is not correct, will throw an exception.\n     *\n     * @type {Money|Number|String|undefined|null|Big|BigJsLibrary.BigJS}\n     * @return {Big|BigJsLibrary.BigJS}\n     * @throws err if not correct type.\n     */\n    static toValueOrFail(numberOrMoney) {\n        if (Utility.isNullOrUndefined(numberOrMoney)) {\n            return new Big(0);\n        } else if (Money.isInstance(numberOrMoney)) {\n            return numberOrMoney.value;\n        } else if (Utility.isNumber(numberOrMoney)) {\n            return new Big(numberOrMoney);\n        } else if (Utility.isString(numberOrMoney)) {\n            return new Big(numberOrMoney);\n        } else if (numberOrMoney instanceof Big) {\n            return numberOrMoney;\n        } else {\n            Preconditions.fail('Number|Currency', Utility.typeOf(numberOrMoney), 'This method fails with the wrong type.');\n        }\n    }\n\n    static toClass() {\n        return this;\n    }\n}"]}