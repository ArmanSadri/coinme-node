{"version":3,"sources":["../../../src/js/money/MoneyConverter.js"],"names":["MoneyConverter","options","defaults","adapter","arguments","currency1","currency2","optCurrency","conversion","optConversion","optionalConversion","isFunction","sourceMoney","destinationCurrency","shouldBeMoney","sourceCurrency","equals","value","isNumber","isInstance","_getConversion","conversions","shouldBeObject","assign","converter","getCurrency","converterName","toString","fn","shouldBeFunction"],"mappings":"AAAA;;;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;;;IAYMA,c;;;AAEF;;;;AAIA,4BAAYC,OAAZ,EAAqB;AAAA;;AACjB,0BAAQC,QAAR,CAAiBD,OAAjB,EAA0B;AACtBE,qBAAS;AADa,SAA1B;;AADiB,gIAKRC,SALQ;AAMpB;;AAED;;;;;;;;;;;;;iCASSC,S,EAAWC,S,EAAW;AAC3BD,wBAAY,mBAASE,WAAT,CAAqBF,SAArB,CAAZ;AACAC,wBAAY,mBAASC,WAAT,CAAqBD,SAArB,CAAZ;;AAEA,gBAAIE,aAAa,KAAKC,aAAL,CAAmBJ,SAAnB,EAA8BC,SAA9B,EAAyCI,kBAAzC,CAAjB;;AAEA,mBAAO,kBAAQC,UAAR,CAAmBH,UAAnB,CAAP;AACH;;AAED;;;;;;;;;;;;;gCAUQI,W,EAAaC,mB,EAAqB;AACtC,mBAAO,gBAAMC,aAAN,yHAAkCF,WAAlC,EAA+CC,mBAA/C,GAAqEA,mBAArE,CAAP;AACH;;AAED;;;;;;;;;;;;sCAScE,c,EAAgBF,mB,EAAqBH,kB,EAAoB;AACnEK,6BAAiB,mBAASR,WAAT,CAAqBQ,cAArB,CAAjB;AACAF,kCAAsB,mBAASN,WAAT,CAAqBM,mBAArB,CAAtB;;AAEA,gBAAI,CAACE,cAAD,IAAmB,CAACF,mBAAxB,EAA6C;AACzC,uBAAO,IAAP;AACH,aAFD,MAEO,IAAIE,eAAeC,MAAf,CAAsBH,mBAAtB,CAAJ,EAAgD;AACnD,uBAAO,UAAUI,KAAV,EAAiB;AACpB,2BAAOA,KAAP;AACH,iBAFD;AAGH,aAJM,MAIA,IAAI,kBAAQN,UAAR,CAAmBD,kBAAnB,CAAJ,EAA4C;AAC/C,uBAAOA,kBAAP;AACH,aAFM,MAEA,IAAI,kBAAQQ,QAAR,CAAiBR,kBAAjB,CAAJ,EAA0C;AAC7C,uBAAO,UAAUO,KAAV,EAAiB;AACpB,2BAAOA,QAAQP,kBAAf;AACH,iBAFD;AAGH,aAJM,MAIA,IAAI,gBAAUS,UAAV,CAAqBT,kBAArB,CAAJ,EAA8C;AACjD,uBAAO,KAAKU,cAAL,CAAoBV,kBAApB,EAAwCK,cAAxC,EAAwDF,mBAAxD,CAAP;AACH,aAFM,MAEA;AACH,uBAAO,KAAKO,cAAL,CAAoB,IAApB,EAA0BL,cAA1B,EAA0CF,mBAA1C,CAAP;AACH;AACJ;;AAED;;;;;;;;;;;;;;;iCAYSQ,W,EAAa;AAClB,oCAAcC,cAAd,CAA6BD,WAA7B;;AAEA,6BAAOE,MAAP,CAAc,KAAKF,WAAnB,EAAgCA,WAAhC;;AAEA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;uCAOeG,S,EAAWT,c,EAAgBF,mB,EAAqB;AAC3DE,6BAAiB,mBAASU,WAAT,CAAqBV,cAArB,CAAjB;AACAF,kCAAsB,mBAASY,WAAT,CAAqBZ,mBAArB,CAAtB;;AAEA,gBAAIa,gBAAgBX,eAAeY,QAAf,KAA4B,IAA5B,GAAmCd,oBAAoBc,QAApB,EAAvD;AACA,gBAAIC,KAAKJ,UAAUH,WAAV,CAAsBK,aAAtB,CAAT;;AAEA,oCAAcG,gBAAd,CAA+BD,EAA/B,EAAmC,0BAA0BF,aAA7D;;AAEA,mBAAOE,EAAP;AACH;;;;;;QAGG5B,c,GAAAA,c;kBACOA,c","file":"MoneyConverter.js","sourcesContent":["'use strict';\n\nimport Money from \"./Money\";\nimport Currency from \"./Currency\";\nimport Preconditions from \"../Preconditions\";\nimport Utility from \"../Utility\";\nimport Lodash from \"lodash\";\nimport {Converter, DelegatedConverter} from \"../data\";\nimport CurrencyAdapter from './CurrencyAdapter';\n\n/**\n * Supports different conversion directions.\n *\n * The conversion map uses the Currency name for directionality. The internal conversion map is stored like:\n *\n * {<br>\n *   'Bitcoin->Satoshi' : function(value) { return value * satoshi_factor; },<br>\n *   'Satoshi->Bitcoin': function(value) { return value / satoshi_factor; }<br>\n * }<br>\n *\n * @class\n */\nclass MoneyConverter extends DelegatedConverter {\n\n    /**\n     * @param {Object} options\n     * @param {Object} options.conversions\n     */\n    constructor(options) {\n        Utility.defaults(options, {\n            adapter: new CurrencyAdapter()\n        });\n\n        super(...arguments);\n    }\n\n    /**\n     * Determines if this Converter instance can convert between the two currencies.\n     *\n     * NOTE: The direction matters.\n     *\n     * @param {Class<Currency>|Currency|String} currency1\n     * @param {Class<Currency>|Currency|String} currency2\n     * @returns {boolean}\n     */\n    supports(currency1, currency2) {\n        currency1 = Currency.optCurrency(currency1);\n        currency2 = Currency.optCurrency(currency2);\n\n        let conversion = this.optConversion(currency1, currency2, optionalConversion);\n\n        return Utility.isFunction(conversion);\n    }\n\n    /**\n     * Executes the conversion.\n     *\n     * @param {Money} sourceMoney\n     * @param {Class<Currency>|Currency} destinationCurrency\n     * @returns {Money}\n     * @throws {PreconditionsError} if the converter fails to convert into a valid number\n     * @throws {PreconditionsError} if the destinationCurrency is not a valid currency\n     * @throws {PreconditionsError} if converter cannot support the conversion\n     */\n    convert(sourceMoney, destinationCurrency) {\n        return Money.shouldBeMoney(super.convert(sourceMoney, destinationCurrency), destinationCurrency);\n    }\n\n    /**\n     * Detects the conversion function, given the inputs.\n     *\n     * @param {Class<Currency>|Currency|String} sourceCurrency\n     * @param {Class<Currency>|Currency|String} destinationCurrency\n     * @param {Function|Number|String|Converter} [optionalConversion]\n     *\n     * @returns {Function}\n     */\n    optConversion(sourceCurrency, destinationCurrency, optionalConversion) {\n        sourceCurrency = Currency.optCurrency(sourceCurrency);\n        destinationCurrency = Currency.optCurrency(destinationCurrency);\n\n        if (!sourceCurrency || !destinationCurrency) {\n            return null;\n        } else if (sourceCurrency.equals(destinationCurrency)) {\n            return function (value) {\n                return value;\n            }\n        } else if (Utility.isFunction(optionalConversion)) {\n            return optionalConversion;\n        } else if (Utility.isNumber(optionalConversion)) {\n            return function (value) {\n                return value * optionalConversion;\n            }\n        } else if (Converter.isInstance(optionalConversion)) {\n            return this._getConversion(optionalConversion, sourceCurrency, destinationCurrency);\n        } else {\n            return this._getConversion(this, sourceCurrency, destinationCurrency);\n        }\n    }\n\n    /**\n     * Register a conversion with this converter. This must be a valid object.\n     *\n     * Example:\n     *\n     * {<br>\n     *     'USD->Bitcoin': function() ...<br>\n     * }<br>\n     *\n     * @param {Object} conversions\n     * @returns {Converter}\n     */\n    register(conversions) {\n        Preconditions.shouldBeObject(conversions);\n\n        Lodash.assign(this.conversions, conversions);\n\n        return this;\n    }\n\n    /**\n     * @param {Converter} converter\n     * @param {Money|Currency|Class<Currency>|String} sourceCurrency\n     * @param {Money|Currency|Class<Currency>|String} destinationCurrency\n     * @private\n     * @return {Function}\n     */\n    _getConversion(converter, sourceCurrency, destinationCurrency) {\n        sourceCurrency = Currency.getCurrency(sourceCurrency);\n        destinationCurrency = Currency.getCurrency(destinationCurrency);\n\n        let converterName = sourceCurrency.toString() + '->' + destinationCurrency.toString();\n        let fn = converter.conversions[converterName];\n\n        Preconditions.shouldBeFunction(fn, 'Converter not found: ' + converterName);\n\n        return fn;\n    }\n}\n\nexport {MoneyConverter};\nexport default MoneyConverter;"]}