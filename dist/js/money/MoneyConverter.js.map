{"version":3,"sources":["../../../src/js/money/MoneyConverter.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;IAcM,c;;;;;;;;AAMF,4BAAY,OAAZ,EAAqB;AAAA;;AACjB,0BAAQ,QAAR,CAAiB,OAAjB,EAA0B;AACtB,qBAAS;AADa,SAA1B;;AADiB,kGAKR,SALQ;AAMpB;;;;;;;;;;;;;;;iCAWQ,S,EAAW,S,EAAW;AAC3B,wBAAY,mBAAS,WAAT,CAAqB,SAArB,CAAZ;AACA,wBAAY,mBAAS,WAAT,CAAqB,SAArB,CAAZ;;AAEA,gBAAI,aAAa,KAAK,aAAL,CAAmB,SAAnB,EAA8B,SAA9B,EAAyC,kBAAzC,CAAjB;;AAEA,mBAAO,kBAAQ,UAAR,CAAmB,UAAnB,CAAP;AACH;;;;;;;;;;;;;;;gCAYO,W,EAAa,mB,EAAqB;AACtC,mBAAO,gBAAM,aAAN,mFAAkC,WAAlC,EAA+C,mBAA/C,GAAqE,mBAArE,CAAP;AACH;;;;;;;;;;;;;;sCAWa,c,EAAgB,mB,EAAqB,kB,EAAoB;AACnE,6BAAiB,mBAAS,WAAT,CAAqB,cAArB,CAAjB;AACA,kCAAsB,mBAAS,WAAT,CAAqB,mBAArB,CAAtB;;AAEA,gBAAI,CAAC,cAAD,IAAmB,CAAC,mBAAxB,EAA6C;AACzC,uBAAO,IAAP;AACH,aAFD,MAEO,IAAI,eAAe,MAAf,CAAsB,mBAAtB,CAAJ,EAAgD;AACnD,uBAAO,UAAU,KAAV,EAAiB;AACpB,2BAAO,KAAP;AACH,iBAFD;AAGH,aAJM,MAIA,IAAI,kBAAQ,UAAR,CAAmB,kBAAnB,CAAJ,EAA4C;AAC/C,uBAAO,kBAAP;AACH,aAFM,MAEA,IAAI,kBAAQ,QAAR,CAAiB,kBAAjB,CAAJ,EAA0C;AAC7C,uBAAO,UAAU,KAAV,EAAiB;AACpB,2BAAO,QAAQ,kBAAf;AACH,iBAFD;AAGH,aAJM,MAIA,IAAI,gBAAU,UAAV,CAAqB,kBAArB,CAAJ,EAA8C;AACjD,uBAAO,KAAK,cAAL,CAAoB,kBAApB,EAAwC,cAAxC,EAAwD,mBAAxD,CAAP;AACH,aAFM,MAEA;AACH,uBAAO,KAAK,cAAL,CAAoB,IAApB,EAA0B,cAA1B,EAA0C,mBAA1C,CAAP;AACH;AACJ;;;;;;;;;;;;;;;;;iCAcQ,W,EAAa;AAClB,oCAAc,cAAd,CAA6B,WAA7B;;AAEA,6BAAO,MAAP,CAAc,KAAK,WAAnB,EAAgC,WAAhC;;AAEA,mBAAO,IAAP;AACH;;;;;;;;;;;;uCASc,S,EAAW,c,EAAgB,mB,EAAqB;AAC3D,6BAAiB,mBAAS,WAAT,CAAqB,cAArB,CAAjB;AACA,kCAAsB,mBAAS,WAAT,CAAqB,mBAArB,CAAtB;;AAEA,gBAAI,gBAAgB,eAAe,QAAf,KAA4B,IAA5B,GAAmC,oBAAoB,QAApB,EAAvD;AACA,gBAAI,KAAK,UAAU,WAAV,CAAsB,aAAtB,CAAT;;AAEA,oCAAc,gBAAd,CAA+B,EAA/B,EAAmC,0BAA0B,aAA7D;;AAEA,mBAAO,EAAP;AACH;;;;;;QAGG,c,GAAA,c;kBACO,c","file":"MoneyConverter.js","sourcesContent":["'use strict';\n\nimport Money from \"./Money\";\nimport Currency from \"./Currency\";\nimport Preconditions from \"../Preconditions\";\nimport Utility from \"../Utility\";\nimport Lodash from \"lodash\";\nimport {Converter, DelegatedConverter} from \"../data\";\nimport CurrencyAdapter from './CurrencyAdapter';\n\n/**\n * Supports different conversion directions.\n *\n * The conversion map uses the Currency name for directionality. The internal conversion map is stored like:\n *\n * {<br>\n *   'Bitcoin->Satoshi' : function(value) { return value * satoshi_factor; },<br>\n *   'Satoshi->Bitcoin': function(value) { return value / satoshi_factor; }<br>\n * }<br>\n *\n * @class\n */\nclass MoneyConverter extends DelegatedConverter {\n\n    /**\n     * @param {Object} options\n     * @param {Object} options.conversions\n     */\n    constructor(options) {\n        Utility.defaults(options, {\n            adapter: new CurrencyAdapter()\n        });\n\n        super(...arguments);\n    }\n\n    /**\n     * Determines if this Converter instance can convert between the two currencies.\n     *\n     * NOTE: The direction matters.\n     *\n     * @param {Class<Currency>|Currency|String} currency1\n     * @param {Class<Currency>|Currency|String} currency2\n     * @returns {boolean}\n     */\n    supports(currency1, currency2) {\n        currency1 = Currency.optCurrency(currency1);\n        currency2 = Currency.optCurrency(currency2);\n\n        let conversion = this.optConversion(currency1, currency2, optionalConversion);\n\n        return Utility.isFunction(conversion);\n    }\n\n    /**\n     * Executes the conversion.\n     *\n     * @param {Money} sourceMoney\n     * @param {Class<Currency>|Currency} destinationCurrency\n     * @returns {Money}\n     * @throws {PreconditionsError} if the converter fails to convert into a valid number\n     * @throws {PreconditionsError} if the destinationCurrency is not a valid currency\n     * @throws {PreconditionsError} if converter cannot support the conversion\n     */\n    convert(sourceMoney, destinationCurrency) {\n        return Money.shouldBeMoney(super.convert(sourceMoney, destinationCurrency), destinationCurrency);\n    }\n\n    /**\n     * Detects the conversion function, given the inputs.\n     *\n     * @param {Class<Currency>|Currency|String} sourceCurrency\n     * @param {Class<Currency>|Currency|String} destinationCurrency\n     * @param {Function|Number|String|Converter} [optionalConversion]\n     *\n     * @returns {Function}\n     */\n    optConversion(sourceCurrency, destinationCurrency, optionalConversion) {\n        sourceCurrency = Currency.optCurrency(sourceCurrency);\n        destinationCurrency = Currency.optCurrency(destinationCurrency);\n\n        if (!sourceCurrency || !destinationCurrency) {\n            return null;\n        } else if (sourceCurrency.equals(destinationCurrency)) {\n            return function (value) {\n                return value;\n            }\n        } else if (Utility.isFunction(optionalConversion)) {\n            return optionalConversion;\n        } else if (Utility.isNumber(optionalConversion)) {\n            return function (value) {\n                return value * optionalConversion;\n            }\n        } else if (Converter.isInstance(optionalConversion)) {\n            return this._getConversion(optionalConversion, sourceCurrency, destinationCurrency);\n        } else {\n            return this._getConversion(this, sourceCurrency, destinationCurrency);\n        }\n    }\n\n    /**\n     * Register a conversion with this converter. This must be a valid object.\n     *\n     * Example:\n     *\n     * {<br>\n     *     'USD->Bitcoin': function() ...<br>\n     * }<br>\n     *\n     * @param {Object} conversions\n     * @returns {Converter}\n     */\n    register(conversions) {\n        Preconditions.shouldBeObject(conversions);\n\n        Lodash.assign(this.conversions, conversions);\n\n        return this;\n    }\n\n    /**\n     * @param {Converter} converter\n     * @param {Money|Currency|Class<Currency>|String} sourceCurrency\n     * @param {Money|Currency|Class<Currency>|String} destinationCurrency\n     * @private\n     * @return {Function}\n     */\n    _getConversion(converter, sourceCurrency, destinationCurrency) {\n        sourceCurrency = Currency.getCurrency(sourceCurrency);\n        destinationCurrency = Currency.getCurrency(destinationCurrency);\n\n        let converterName = sourceCurrency.toString() + '->' + destinationCurrency.toString();\n        let fn = converter.conversions[converterName];\n\n        Preconditions.shouldBeFunction(fn, 'Converter not found: ' + converterName);\n\n        return fn;\n    }\n}\n\nexport {MoneyConverter};\nexport default MoneyConverter;"]}