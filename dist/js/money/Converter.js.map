{"version":3,"sources":["../../../src/js/money/Converter.js"],"names":[],"mappings":"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","file":"Converter.js","sourcesContent":["'use strict';\r\n\r\nimport CoreObject from \"../CoreObject\";\r\nimport Money from \"./Money\";\r\nimport Currency from \"./Currency\";\r\nimport Preconditions from \"../Preconditions\";\r\nimport Utility from \"../Utility\";\r\nimport Lodash from \"lodash\";\r\n\r\n/**\r\n * Supports different conversion directions.\r\n *\r\n * The conversion map uses the Currency name for directionality. The internal conversion map is stored like:\r\n *\r\n * {<br>\r\n *   'Bitcoin->Satoshi' : function(value) { return value * satoshi_factor; },<br>\r\n *   'Satoshi->Bitcoin': function(value) { return value / satoshi_factor; }<br>\r\n * }<br>\r\n *\r\n * @class\r\n */\r\nexport default class Converter extends CoreObject {\r\n\r\n    /**\r\n     * @param {Object} options\r\n     * @param {Object} options.conversions\r\n     */\r\n    constructor(options) {\r\n        let conversions = Utility.take(options, 'conversions');\r\n\r\n        super(...arguments);\r\n\r\n        /**\r\n         * @type {Object}\r\n         */\r\n        this._conversions = conversions || {};\r\n    }\r\n\r\n    /**\r\n     * This is the conversion map. The keys of this object should be 'Currency1->Currency2'\r\n     *\r\n     * The value of each key should be a conversion function of 'function(valueInSource) { return valueInDestination; }\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    get conversions() {\r\n        return this._conversions;\r\n    }\r\n\r\n    /**\r\n     * Determines if this Converter instance can convert between the two currencies.\r\n     *\r\n     * NOTE: The direction matters.\r\n     *\r\n     * @param {Class<Currency>|Currency|String} currency1\r\n     * @param {Class<Currency>|Currency|String} currency2\r\n     * @param {Number|String|Function|Converter} [optionalConversion]\r\n     * @returns {boolean}\r\n     */\r\n    canConvert(currency1, currency2, optionalConversion) {\r\n        currency1 = Currency.optCurrency(currency1);\r\n        currency2 = Currency.optCurrency(currency2);\r\n\r\n        let conversion = this.optConversion(currency1, currency2, optionalConversion);\r\n\r\n        return Utility.isFunction(conversion);\r\n    }\r\n\r\n    /**\r\n     * Executes the conversion.\r\n     *\r\n     * @param {Money} sourceMoney\r\n     * @param {Class<Currency>|Currency} destinationCurrency\r\n     * @param {Function} [optionalConversion]\r\n     * @returns {Money}\r\n     * @throws {PreconditionsError} if the converter fails to convert into a valid number\r\n     * @throws {PreconditionsError} if the destinationCurrency is not a valid currency\r\n     * @throws {PreconditionsError} if converter cannot support the conversion\r\n     */\r\n    convert(sourceMoney, destinationCurrency, optionalConversion) {\r\n        destinationCurrency = Currency.getCurrency(destinationCurrency);\r\n\r\n        let fn = this.optConversion(sourceMoney.currency, destinationCurrency, optionalConversion);\r\n        let scope = (Converter.isInstance(optionalConversion)) ? optionalConversion : this;\r\n        let value = fn.call(scope, sourceMoney.value);\r\n        \r\n        Preconditions.shouldBeNumber(value, 'Sanity check failure, the value should be a number: ' + value);\r\n\r\n        return new Money({\r\n            value: value,\r\n            currency: destinationCurrency\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detects the conversion function, given the inputs.\r\n     *\r\n     * @param {Class<Currency>|Currency|String} sourceCurrency\r\n     * @param {Class<Currency>|Currency|String} destinationCurrency\r\n     * @param {Function|Number|String|Converter} [optionalConversion]\r\n     *\r\n     * @returns {Function}\r\n     */\r\n    optConversion(sourceCurrency, destinationCurrency, optionalConversion) {\r\n        sourceCurrency = Currency.optCurrency(sourceCurrency);\r\n        destinationCurrency = Currency.optCurrency(destinationCurrency);\r\n\r\n        if (!sourceCurrency || !destinationCurrency) {\r\n            return null;\r\n        } else if (sourceCurrency.equals(destinationCurrency)) {\r\n            return function(value) { return value; }\r\n        } else if (Utility.isFunction(optionalConversion)) {\r\n            return optionalConversion;\r\n        } else if (Utility.isNumber(optionalConversion)) {\r\n            return function(value) { return value * optionalConversion; }\r\n        } else if (Converter.isInstance(optionalConversion)) {\r\n            return this._getConversion(optionalConversion, sourceCurrency, destinationCurrency);\r\n        } else {\r\n            return this._getConversion(this, sourceCurrency, destinationCurrency);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a conversion with this converter. This must be a valid object.\r\n     *\r\n     * Example:\r\n     *\r\n     * {<br>\r\n     *     'USD->Bitcoin': function() ...<br>\r\n     * }<br>\r\n     *\r\n     * @param {Object} conversions\r\n     * @returns {Converter}\r\n     */\r\n    register(conversions) {\r\n        Preconditions.shouldBeObject(conversions);\r\n\r\n        Lodash.assign(this.conversions, conversions);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {Converter} converter\r\n     * @param {Money|Currency|Class<Currency>|String} sourceCurrency\r\n     * @param {Money|Currency|Class<Currency>|String} destinationCurrency\r\n     * @private\r\n     * @return {Function}\r\n     */\r\n    _getConversion(converter, sourceCurrency, destinationCurrency) {\r\n        sourceCurrency = Currency.getCurrency(sourceCurrency);\r\n        destinationCurrency = Currency.getCurrency(destinationCurrency);\r\n\r\n        let converterName = sourceCurrency.toString() + '->' + destinationCurrency.toString();\r\n        let fn = converter.conversions[converterName];\r\n\r\n        Preconditions.shouldBeFunction(fn, 'Converter not found: ' + converterName);\r\n\r\n        return fn;\r\n    }\r\n}"]}