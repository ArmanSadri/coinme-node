{"version":3,"sources":["../../../src/js/money/Converter.js"],"names":[],"mappings":"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","file":"Converter.js","sourcesContent":["'use strict';\n\nimport CoreObject from \"../CoreObject\";\nimport Money from \"./Money\";\nimport Currency from \"./Currency\";\nimport Preconditions from \"../Preconditions\";\nimport Utility from \"../Utility\";\nimport Lodash from \"lodash\";\n\n/**\n * Supports different conversion directions.\n *\n * The conversion map uses the Currency name for directionality. The internal conversion map is stored like:\n *\n * {<br>\n *   'Bitcoin->Satoshi' : function(value) { return value * satoshi_factor; },<br>\n *   'Satoshi->Bitcoin': function(value) { return value / satoshi_factor; }<br>\n * }<br>\n *\n * @class\n */\nexport default class Converter extends CoreObject {\n\n    /**\n     * @param {Object} options\n     * @param {Object} options.conversions\n     */\n    constructor(options) {\n        let conversions = Utility.take(options, 'conversions');\n\n        super(...arguments);\n\n        /**\n         * @type {Object}\n         */\n        this._conversions = conversions || {};\n    }\n\n    /**\n     * This is the conversion map. The keys of this object should be 'Currency1->Currency2'\n     *\n     * The value of each key should be a conversion function of 'function(valueInSource) { return valueInDestination; }\n     *\n     * @returns {Object}\n     */\n    get conversions() {\n        return this._conversions;\n    }\n\n    /**\n     * Determines if this Converter instance can convert between the two currencies.\n     *\n     * NOTE: The direction matters.\n     *\n     * @param {Class<Currency>|Currency|String} currency1\n     * @param {Class<Currency>|Currency|String} currency2\n     * @param {Number|String|Function|Converter} [optionalConversion]\n     * @returns {boolean}\n     */\n    canConvert(currency1, currency2, optionalConversion) {\n        currency1 = Currency.optCurrency(currency1);\n        currency2 = Currency.optCurrency(currency2);\n\n        let conversion = this.optConversion(currency1, currency2, optionalConversion);\n\n        return Utility.isFunction(conversion);\n    }\n\n    /**\n     * Executes the conversion.\n     *\n     * @param {Money} sourceMoney\n     * @param {Class<Currency>|Currency} destinationCurrency\n     * @param {Function} [optionalConversion]\n     * @returns {Money}\n     * @throws {PreconditionsError} if the converter fails to convert into a valid number\n     * @throws {PreconditionsError} if the destinationCurrency is not a valid currency\n     * @throws {PreconditionsError} if converter cannot support the conversion\n     */\n    convert(sourceMoney, destinationCurrency, optionalConversion) {\n        destinationCurrency = Currency.getCurrency(destinationCurrency);\n\n        let fn = this.optConversion(sourceMoney.currency, destinationCurrency, optionalConversion);\n        let scope = (Converter.isInstance(optionalConversion)) ? optionalConversion : this;\n        let value = fn.call(scope, sourceMoney.value);\n        \n        Preconditions.shouldBeNumber(value, 'Sanity check failure, the value should be a number: ' + value);\n\n        return new Money({\n            value: value,\n            currency: destinationCurrency\n        });\n    }\n\n    /**\n     * Detects the conversion function, given the inputs.\n     *\n     * @param {Class<Currency>|Currency|String} sourceCurrency\n     * @param {Class<Currency>|Currency|String} destinationCurrency\n     * @param {Function|Number|String|Converter} [optionalConversion]\n     *\n     * @returns {Function}\n     */\n    optConversion(sourceCurrency, destinationCurrency, optionalConversion) {\n        sourceCurrency = Currency.optCurrency(sourceCurrency);\n        destinationCurrency = Currency.optCurrency(destinationCurrency);\n\n        if (!sourceCurrency || !destinationCurrency) {\n            return null;\n        } else if (sourceCurrency.equals(destinationCurrency)) {\n            return function(value) { return value; }\n        } else if (Utility.isFunction(optionalConversion)) {\n            return optionalConversion;\n        } else if (Utility.isNumber(optionalConversion)) {\n            return function(value) { return value * optionalConversion; }\n        } else if (Converter.isInstance(optionalConversion)) {\n            return this._getConversion(optionalConversion, sourceCurrency, destinationCurrency);\n        } else {\n            return this._getConversion(this, sourceCurrency, destinationCurrency);\n        }\n    }\n\n    /**\n     * Register a conversion with this converter. This must be a valid object.\n     *\n     * Example:\n     *\n     * {<br>\n     *     'USD->Bitcoin': function() ...<br>\n     * }<br>\n     *\n     * @param {Object} conversions\n     * @returns {Converter}\n     */\n    register(conversions) {\n        Preconditions.shouldBeObject(conversions);\n\n        Lodash.assign(this.conversions, conversions);\n\n        return this;\n    }\n\n    /**\n     * @param {Converter} converter\n     * @param {Money|Currency|Class<Currency>|String} sourceCurrency\n     * @param {Money|Currency|Class<Currency>|String} destinationCurrency\n     * @private\n     * @return {Function}\n     */\n    _getConversion(converter, sourceCurrency, destinationCurrency) {\n        sourceCurrency = Currency.getCurrency(sourceCurrency);\n        destinationCurrency = Currency.getCurrency(destinationCurrency);\n\n        let converterName = sourceCurrency.toString() + '->' + destinationCurrency.toString();\n        let fn = converter.conversions[converterName];\n\n        Preconditions.shouldBeFunction(fn, 'Converter not found: ' + converterName);\n\n        return fn;\n    }\n}"]}