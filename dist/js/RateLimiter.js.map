{"version":3,"sources":["../../src/js/RateLimiter.js"],"names":[],"mappings":"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","file":"RateLimiter.js","sourcesContent":["import Preconditions from \"./Preconditions\";\nimport TimeUnit from \"./TimeUnit\";\nimport Utility from \"./Utility\";\nimport CoreObject from \"./CoreObject\";\nimport Stopwatch from \"./Stopwatch\";\nimport Errors from \"./errors/Errors\";\nimport Logger from 'winston';\n\nclass RateLimiter extends CoreObject {\n\n    _permitsPerSecond;\n\n    constructor(options) {\n        super(options);\n\n        /**\n         * @type {Stopwatch}\n         * @private\n         */\n        this._stopwatch = new Stopwatch({ start: true });\n\n        // /**\n        //  * @type {String}\n        //  * @private\n        //  */\n        // this._failAction = Utility.take(options, 'failAction', {\n        //         type: 'string',\n        //         required: false,\n        //         defaultValue: 'wait'\n        //     });\n    }\n\n    //region property: {Stopwatch} stopwatch\n    /**\n     * @returns {Stopwatch}\n     */\n    get stopwatch() {\n        return this._stopwatch;\n    }\n\n    //endregion\n\n    //region property: {Ticker} ticker\n    /**\n     *\n     * @return {Ticker}\n     */\n    get ticker() {\n        return this.stopwatch.ticker;\n    }\n    //endregion\n\n    //region property: {Number} permitsPerSecond\n\n    /**\n     * Updates the stable rate of this {@code RateLimiter}, that is, the\n     * {@code permitsPerSecond} argument provided in the factory method that\n     * constructed the {@code RateLimiter}. Currently throttled threads will <b>not</b>\n     * be awakened as a result of this invocation, thus they do not observe the new rate;\n     * only subsequent requests will.\n     *\n     * <p>Note though that, since each request repays (by waiting, if necessary) the cost\n     * of the <i>previous</i> request, this means that the very next request\n     * after an invocation to {@code setRate} will not be affected by the new rate;\n     * it will pay the cost of the previous request, which is in terms of the previous rate.\n     *\n     * <p>The behavior of the {@code RateLimiter} is not modified in any other way,\n     * e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds,\n     * it still has a warmup period of 20 seconds after this method invocation.\n     *\n     * @param {Number} permitsPerSecond the new stable rate of this {@code RateLimiter}\n     * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero\n     */\n    set permitsPerSecond(permitsPerSecond) {\n        Preconditions.shouldBeExisting(permitsPerSecond);\n        Preconditions.shouldBeTrue(permitsPerSecond > 0.0 && !Utility.isNaN(permitsPerSecond), \"rate must be positive\");\n\n        this._permitsPerSecond = Preconditions.shouldBePositiveNumber(permitsPerSecond, 'Rate must be positive');\n\n        this.doSetRate(permitsPerSecond, this.stopwatch.elapsedMicros());\n    }\n\n    /**\n     *\n     * @returns {Number}\n     */\n    get permitsPerSecond() {\n        return this._permitsPerSecond;\n    }\n\n    //endregion\n\n    /**\n     * Acquires a single permit from this {@code RateLimiter}. Returns a Promise that will resolve or reject.\n     * The default maximum time to wait is 30 seconds.\n     *\n     * <p>This method is equivalent to {@code acquire(1)}.\n     *\n     * @param {Number} [permits] defaults to 1\n     * @param {Number} [timeout] defaults to 30\n     * @param {TimeUnit} [timeUnit] defaults to seconds\n     * @return {Promise} time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited\n     * @since 16.0 (present in 13.0 with {@code void} return type})\n     */\n    acquire(permits, timeout, timeUnit) {\n        return this.tryAcquire(permits, timeout, timeUnit);\n    }\n\n    /**\n     * Reserves the given number of permits from this {@code RateLimiter} for future use, returning\n     * the number of microseconds until the reservation can be consumed.\n     *\n     * @param {Number} [permits]\n     * @return {Number} time in microseconds to wait until the resource can be acquired, never negative\n     */\n    reserve(permits) {\n        permits = this.checkPermits(permits);\n\n        return this.reserveAndGetWaitLength(permits, this.stopwatch.elapsedMicros());\n    }\n\n    /**\n     * Reserves next ticket and returns the wait time that the caller must wait for.\n     *\n     * @private\n     * @param {Number} permits\n     * @param {Number} nowMicros\n     * @return {Number} the required wait time, never negative\n     */\n    reserveAndGetWaitLength(permits, nowMicros) {\n        let momentAvailable = this.reserveEarliestAvailable(permits, nowMicros);\n        let waitLength = Math.max(momentAvailable - nowMicros, 0);\n\n        console.log(`${this}.reserveAndGetWaitLength(${permits}, ${nowMicros}) ==> ${waitLength}`);\n        // Logger.debug(`${this}.reserveAndGetWaitLength(${permits}, ${nowMicros}) ==> ${waitLength}`);\n\n        return waitLength;\n    }\n\n    /**\n     * @private\n     * @param {Number} nowMicros\n     * @param {Number} timeoutMicros\n     * @returns {boolean}\n     */\n    canAcquire(nowMicros, timeoutMicros) {\n        return this.queryEarliestAvailable(nowMicros) - timeoutMicros <= nowMicros;\n    }\n\n    /**\n     * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained\n     * without exceeding the specified {@code timeout}, or returns {@code false}\n     * immediately (without waiting) if the permits would not have been granted\n     * before the timeout expired.\n     *\n     * @param {Number} [permits] the number of permits to acquire\n     * @param {Number} [timeout] the maximum time to wait for the permits. Negative values are treated as zero.\n     * @param {TimeUnit} [unit] the time unit of the timeout argument\n     * @return {Promise} if the permits were acquired\n     * @throws IllegalArgumentException if the requested number of permits is negative or zero\n     */\n    tryAcquire(permits, timeout, unit) {\n        Preconditions.shouldBeNumber(this.permitsPerSecond, 'Rate must be defined.');\n\n        permits = RateLimiter.checkPermits(permits);\n        timeout = Utility.defaultNumber(timeout, 30);\n        unit = Utility.defaultObject(unit, TimeUnit.SECONDS);\n\n        let timeoutMicros = Math.max(unit.toMicros(timeout), 0);\n\n        let microsToWait;\n        let nowMicros = this.stopwatch.elapsedMicros();\n        let goalMicros = this.queryEarliestAvailable(nowMicros);\n\n        if (!this.canAcquire(nowMicros, timeoutMicros)) {\n            return Promise.reject(new Error(`RateLimit exceeded: (rate:${this.permitsPerSecond}/sec) (timeoutMicros:${timeoutMicros}) (goalMicros: ${goalMicros}) (differenceMicros:${goalMicros - nowMicros})`));\n        } else {\n            microsToWait = this.reserveAndGetWaitLength(permits, nowMicros);\n        }\n\n        Preconditions.shouldBeExisting(this.ticker, 'ticker');\n        return this.ticker.wait(microsToWait, TimeUnit.MICROSECONDS);\n    }\n\n    //region abstract\n    /**\n     * Returns the earliest time that permits are available (with one caveat).\n     *\n     * @param {Number} nowMicros\n     * @return the time that permits are available, or, if permits are available immediately, an\n     *     arbitrary past or present time\n     */\n    queryEarliestAvailable(nowMicros) {\n        Errors.throwNotImplemented();\n    }\n\n    /**\n     * Reserves the requested number of permits and returns the time that those permits can be used\n     * (with one caveat).\n     *\n     * @param {Number} permits\n     * @param {Number} nowMicros\n     * @return {Number} the time that the permits may be used, or, if the permits may be used immediately, an\n     *     arbitrary past or present time\n     */\n    reserveEarliestAvailable(permits, nowMicros) {\n        Errors.throwNotImplemented();\n    }\n\n    //endregion\n\n    //region statics\n    /**\n     * @private\n     * @param {Number} [permits]\n     * @returns {Number}\n     */\n    static checkPermits(permits) {\n        if (Utility.isNotExisting(permits)) {\n            return 1;\n        }\n\n        Preconditions.shouldBeNumber(permits, `Requested permits (${permits}) must be positive`);\n        Preconditions.shouldBeTrue(permits > 0, `Requested permits (${permits}) must be positive`);\n\n        return permits;\n    }\n\n    //endregion\n}\n\nclass SmoothRateLimiter extends RateLimiter {\n\n    constructor(options) {\n        super(options);\n\n        /**\n         * The currently stored permits.\n         */\n        this._storedPermits = 0;\n\n        /**\n         * The maximum number of stored permits.\n         * @type {Number}\n         * @private\n         */\n        this._maxPermits = 0;\n\n        /**\n         * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits\n         * per second has a stable interval of 200ms.\n         */\n        this._stableIntervalMicros = 0;\n\n        /**\n         * The time when the next request (no matter its size) will be granted. After granting a\n         * request, this is pushed further in the future. Large requests push this further than small\n         * requests.\n         * @type {Number}\n         * @private\n         */\n        this._nextFreeTicketMicros = 0; // could be either in the past or future\n    }\n\n    /**\n     * @protected\n     * @param permitsPerSecond\n     * @param nowMicros\n     */\n    doSetRate(permitsPerSecond, nowMicros) {\n        this.resync(nowMicros);\n        let stableIntervalMicros = TimeUnit.SECONDS.toMicros(1) / permitsPerSecond;\n        this._stableIntervalMicros = stableIntervalMicros;\n        this.doSetRate2(permitsPerSecond, stableIntervalMicros);\n    }\n\n    /**\n     * @protected\n     * @param permitsPerSecond\n     * @param stableIntervalMicros\n     */\n    doSetRate2(permitsPerSecond, stableIntervalMicros) {\n        Errors.throwNotImplemented();\n    }\n\n    queryEarliestAvailable(nowMicros) {\n        return Preconditions.shouldBeNumber(this._nextFreeTicketMicros);\n    }\n\n    reserveEarliestAvailable(requiredPermits, nowMicros) {\n        this.resync(nowMicros);\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\n\n        let returnValue = nextFreeTicketMicros;\n        let storedPermitsToSpend = Math.min(requiredPermits, this._storedPermits);\n        let freshPermits = requiredPermits - storedPermitsToSpend;\n\n        let waitMicros = this.storedPermitsToWaitTime(this._storedPermits, storedPermitsToSpend) + (freshPermits * this._stableIntervalMicros);\n\n        this._nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\n        this._storedPermits -= storedPermitsToSpend;\n\n        return returnValue;\n    }\n\n    /**\n     * Translates a specified portion of our currently stored permits which we want to\n     * spend/acquire, into a throttling time. Conceptually, this evaluates the integral\n     * of the underlying function we use, for the range of\n     * [(storedPermits - permitsToTake), storedPermits].\n     *\n     * <p>This always holds: {@code 0 <= permitsToTake <= storedPermits}\n     */\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\n        Errors.throwNotImplemented();\n    }\n\n    /**\n     *\n     * @param {Number} nowMicros\n     * @return {Number}\n     */\n    resync(nowMicros) {\n        if (Utility.isNullOrUndefined(nowMicros)) {\n            nowMicros = this.stopwatch.elapsedMicros();\n        }\n\n        // if nextFreeTicket is in the past, resync to now\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\n\n        if (nowMicros > nextFreeTicketMicros) {\n            this._storedPermits = Math.min(this._maxPermits, this._storedPermits + (nowMicros - nextFreeTicketMicros) / this._stableIntervalMicros);\n\n            nextFreeTicketMicros = this._nextFreeTicketMicros = nowMicros;\n        }\n\n        return nextFreeTicketMicros;\n    }\n}\n\n/**\n * This implements a \"bursty\" RateLimiter, where storedPermits are translated to\n * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is\n * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this\n * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits.\n */\nclass SmoothBurstyRateLimiter extends SmoothRateLimiter {\n\n    /** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */\n    maxBurstSeconds;\n\n    /**\n     * @param {Object} options\n     * @param {Number} options.maxBurstSeconds\n     * @param {Stopwatch} [options.stopwatch]\n     */\n    constructor(options) {\n        let maxBurstSeconds = Utility.take(options, 'maxBurstSeconds', 'number', true);\n\n        // SleepingStopwatch stopwatch, double maxBurstSeconds\n        super(...arguments);\n\n        this.maxBurstSeconds = maxBurstSeconds;\n    }\n\n    /**\n     *\n     * @param {Number} permitsPerSecond\n     * @param {Number} stableIntervalMicros\n     */\n    doSetRate2(permitsPerSecond, stableIntervalMicros) {\n        let oldMaxPermits = Utility.defaultNumber(this._maxPermits);\n        let maxBurstSeconds = Utility.defaultNumber(this.maxBurstSeconds);\n\n        this._maxPermits = maxBurstSeconds * permitsPerSecond;\n\n        // if (oldMaxPermits == Double.POSITIVE_INFINITY) {\n        //     // if we don't special-case this, we would get storedPermits == NaN, below\n        //     this.storedPermits = maxPermits;\n        // } else {\n        this._storedPermits = (oldMaxPermits == 0.0)\n            ? 0.0 // initial state\n            : this._storedPermits * this._maxPermits / oldMaxPermits;\n        // }\n\n        Preconditions.shouldBeNumber(this._storedPermits, 'storedPermits');\n        Preconditions.shouldBeNumber(this._maxPermits, '_maxPermits');\n    }\n\n    /**\n     *\n     * @param {Number} storedPermits\n     * @param {Number} permitsToTake\n     * @return {number}\n     */\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\n        return 0;\n    }\n}\n\nclass SmoothWarmingUpRateLimiter extends SmoothRateLimiter {\n\n    warmupPeriodMicros;\n\n    /**\n     * The slope of the line from the stable interval (when permits == 0), to the cold interval\n     * (when permits == maxPermits)\n     */\n    slope;\n    halfPermits;\n\n    constructor(options) {\n        //    SleepingStopwatch stopwatch, long warmupPeriod, TimeUnit timeUnit\n        let timeUnit = Utility.take(options, 'timeUnit', TimeUnit, true);\n        let warmupPeriod = Utility.take(options, 'warmupPeriod', 'number', true);\n\n        super(...arguments);\n\n        this.warmupPeriodMicros = timeUnit.toMicros(warmupPeriod);\n    }\n\n    /**\n     * @private\n     * @param permitsPerSecond\n     * @param stableIntervalMicros\n     */\n    doSetRate2(permitsPerSecond, stableIntervalMicros) {\n        let oldMaxPermits = this._maxPermits;\n        this._maxPermits = this.warmupPeriodMicros / stableIntervalMicros;\n        this.halfPermits = this._maxPermits / 2.0;\n\n        // Stable interval is x, cold is 3x, so on average it's 2x. Double the time -> halve the rate\n        let coldIntervalMicros = stableIntervalMicros * 3.0;\n        this.slope = (coldIntervalMicros - stableIntervalMicros) / this.halfPermits;\n\n        // if (oldMaxPermits == Number.POSITIVE_INFINITY) {\n        //     // if we don't special-case this, we would get storedPermits == NaN, below\n        //     this._storedPermits = 0.0;\n        // } else {\n            this._storedPermits = (oldMaxPermits == 0.0)\n                ? this._maxPermits // initial state is cold\n                : this._storedPermits * this._maxPermits / oldMaxPermits;\n        // }\n    }\n\n    /**\n     * @private\n     * @param storedPermits\n     * @param permitsToTake\n     * @return {number}\n     */\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\n        let availablePermitsAboveHalf = storedPermits - this.halfPermits;\n        let micros = 0;\n        // measuring the integral on the right part of the function (the climbing line)\n        if (availablePermitsAboveHalf > 0.0) {\n            let permitsAboveHalfToTake = Math.min(availablePermitsAboveHalf, permitsToTake);\n            micros = (permitsAboveHalfToTake * (this.permitsToTime(availablePermitsAboveHalf)\n                + this.permitsToTime(availablePermitsAboveHalf - permitsAboveHalfToTake)) / 2.0);\n            permitsToTake -= permitsAboveHalfToTake;\n        }\n        // measuring the integral on the left part of the function (the horizontal line)\n        micros += (this._stableIntervalMicros * permitsToTake);\n        return micros;\n    }\n\n    /**\n     * @private\n     * @param permits\n     * @return {*}\n     */\n    permitsToTime(permits) {\n        return this._stableIntervalMicros + permits * this.slope;\n    }\n}\n\nexport {RateLimiter};\nexport {SmoothRateLimiter};\nexport {SmoothBurstyRateLimiter};\nexport {SmoothWarmingUpRateLimiter};\nexport default SmoothRateLimiter;\n"]}