{"version":3,"sources":["../../src/js/RateLimiter.js"],"names":[],"mappings":"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","file":"RateLimiter.js","sourcesContent":["import Preconditions from \"./Preconditions\";\nimport TimeUnit from \"./TimeUnit\";\nimport Utility from \"./Utility\";\nimport CoreObject from \"./CoreObject\";\nimport Stopwatch from \"./Stopwatch\";\n\nconst MICROSECONDS = TimeUnit.MICROSECONDS;\nconst SECONDS = TimeUnit.SECONDS;\n\nclass RateLimiter extends CoreObject {\n\n    constructor(options) {\n        super(options);\n\n        /**\n         * @type {Stopwatch}\n         * @private\n         */\n        this._stopwatch = new Stopwatch({ start: true });\n\n        /**\n         * @type {String}\n         * @private\n         */\n        this._failAction = Utility.take(options, 'failAction', {\n                type: 'string',\n                required: false,\n                defaultValue: 'wait'\n            });\n    }\n\n    //region property: {String} failAction\n    /**\n     * @returns {String}\n     */\n    get failAction() {\n        return this._failAction;\n    }\n    //endregion\n\n    //region property: {Stopwatch} stopwatch\n    /**\n     * @returns {Stopwatch}\n     */\n    get stopwatch() {\n        return this._stopwatch;\n    }\n    //endregion\n\n    //region property: {String} rate\n\n    /**\n     * Updates the stable rate of this {@code RateLimiter}, that is, the\n     * {@code permitsPerSecond} argument provided in the factory method that\n     * constructed the {@code RateLimiter}. Currently throttled threads will <b>not</b>\n     * be awakened as a result of this invocation, thus they do not observe the new rate;\n     * only subsequent requests will.\n     *\n     * <p>Note though that, since each request repays (by waiting, if necessary) the cost\n     * of the <i>previous</i> request, this means that the very next request\n     * after an invocation to {@code setRate} will not be affected by the new rate;\n     * it will pay the cost of the previous request, which is in terms of the previous rate.\n     *\n     * <p>The behavior of the {@code RateLimiter} is not modified in any other way,\n     * e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds,\n     * it still has a warmup period of 20 seconds after this method invocation.\n     *\n     * @param {Number} permitsPerSecond the new stable rate of this {@code RateLimiter}\n     * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero\n     */\n    set rate(permitsPerSecond) {\n        Preconditions.shouldBeTrue(permitsPerSecond > 0.0 && !Utility.isNaN(permitsPerSecond), \"rate must be positive\");\n\n        this._rate = permitsPerSecond;\n    }\n\n    /**\n     *\n     * @returns {Number}\n     */\n    get rate() {\n        return this._rate;\n    }\n    //endregion\n\n    /**\n     * Acquires a single permit from this {@code RateLimiter}, blocking until the\n     * request can be granted. Tells the amount of time slept, if any.\n     *\n     * <p>This method is equivalent to {@code acquire(1)}.\n     *\n     * @param {Number} [permits]\n     * @return {Number} time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited\n     * @since 16.0 (present in 13.0 with {@code void} return type})\n     */\n    acquire(permits) {\n        return new Promise((resolve, reject) => {\n            return self.tryAcquire(permits);\n        });\n    }\n\n    /**\n     * Reserves the given number of permits from this {@code RateLimiter} for future use, returning\n     * the number of microseconds until the reservation can be consumed.\n     *\n     * @param {Number} [permits]\n     * @return {Number} time in microseconds to wait until the resource can be acquired, never negative\n     */\n    reserve(permits) {\n        permits = this.checkPermits(permits);\n\n        return this.reserveAndGetWaitLength(permits, this.stopwatch.elapsedMicros());\n    }\n\n    /**\n     * Reserves next ticket and returns the wait time that the caller must wait for.\n     *\n     * @private\n     * @param {Number} permits\n     * @param {Number} nowMicros\n     * @return {Number} the required wait time, never negative\n     */\n    reserveAndGetWaitLength(permits, nowMicros) {\n        let momentAvailable = this.reserveEarliestAvailable(permits, nowMicros);\n\n        return max(momentAvailable - nowMicros, 0);\n    }\n\n    /**\n     * @private\n     * @param {Number} nowMicros\n     * @param {Number} timeoutMicros\n     * @returns {boolean}\n     */\n    canAcquire(nowMicros, timeoutMicros) {\n        return this.queryEarliestAvailable(nowMicros) - timeoutMicros <= nowMicros;\n    }\n\n    /**\n     * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained\n     * without exceeding the specified {@code timeout}, or returns {@code false}\n     * immediately (without waiting) if the permits would not have been granted\n     * before the timeout expired.\n     *\n     * @param {Number} [permits] the number of permits to acquire\n     * @param {Number} [timeout] the maximum time to wait for the permits. Negative values are treated as zero.\n     * @param {TimeUnit} [unit] the time unit of the timeout argument\n     * @return {boolean} if the permits were acquired\n     * @throws IllegalArgumentException if the requested number of permits is negative or zero\n     */\n    tryAcquire(permits, timeout, unit) {\n        permits = RateLimiter.checkPermits(permits);\n        timeout = Utility.defaultNumber(timeout, 0);\n        unit = Utility.defaultObject(unit, MICROSECONDS);\n\n        let timeoutMicros = Math.max(unit.toMicros(timeout), 0);\n\n        let microsToWait;\n        let nowMicros = this.stopwatch.elapsedMicros();\n\n        if (!this.canAcquire(nowMicros, timeoutMicros)) {\n            return false;\n        } else {\n            microsToWait = this.reserveAndGetWaitLength(permits, nowMicros);\n        }\n\n        this.stopwatch.sleepMicrosUninterruptibly(microsToWait);\n\n        return true;\n    }\n\n    //region abstract\n    /**\n     * Returns the earliest time that permits are available (with one caveat).\n     *\n     * @param {Number} nowMicros\n     * @return the time that permits are available, or, if permits are available immediately, an\n     *     arbitrary past or present time\n     */\n    queryEarliestAvailable(nowMicros) {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * Reserves the requested number of permits and returns the time that those permits can be used\n     * (with one caveat).\n     *\n     * @param {Number} permits\n     * @param {Number} nowMicros\n     * @return {Number} the time that the permits may be used, or, if the permits may be used immediately, an\n     *     arbitrary past or present time\n     */\n    reserveEarliestAvailable(permits, nowMicros) {\n        throw new Error('Not implemented');\n    }\n    //endregion\n\n    //region statics\n    /**\n     * @private\n     * @param {Number} [permits]\n     * @returns {Number}\n     */\n    static checkPermits(permits) {\n        if (Utility.isNullOrUndefined(permits)) {\n            return 1;\n        }\n\n        Utility.shouldBeTrue(permits > 0, `Requested permits (${permits}) must be positive`);\n\n        return permits;\n    }\n    //endregion\n}\n\nclass SmoothRateLimiter extends RateLimiter {\n\n    constructor(options) {\n        super(options);\n\n        /**\n         * The currently stored permits.\n         */\n        this._storedPermits = 0;\n\n        /**\n         * The maximum number of stored permits.\n         * @type {Number}\n         * @private\n         */\n        this._maxPermits = 0;\n\n        /**\n         * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits\n         * per second has a stable interval of 200ms.\n         */\n        this._stableIntervalMicros;\n\n\n        /**\n         * The time when the next request (no matter its size) will be granted. After granting a\n         * request, this is pushed further in the future. Large requests push this further than small\n         * requests.\n         * @type {Number}\n         * @private\n         */\n        this._nextFreeTicketMicros = 0; // could be either in the past or future\n\n    }\n\n    // doSetRate(permitsPerSecond, nowMicros) {\n    //     this.resync(nowMicros);\n    //     this._stableIntervalMicros = SECONDS.toMicros(1) / permitsPerSecond;\n    // }\n\n    queryEarliestAvailable(nowMicros) {\n        return this.nextFreeTicketMicros;\n    }\n\n    reserveEarliestAvailable(requiredPermits, nowMicros) {\n        this.resync(nowMicros);\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\n\n        let returnValue = nextFreeTicketMicros;\n        let storedPermitsToSpend = min(requiredPermits, this.storedPermits);\n        let freshPermits = requiredPermits - storedPermitsToSpend;\n\n        let waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) + (freshPermits * stableIntervalMicros);\n\n        this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\n        this.storedPermits -= storedPermitsToSpend;\n\n        return returnValue;\n    }\n\n    /**\n     * Translates a specified portion of our currently stored permits which we want to\n     * spend/acquire, into a throttling time. Conceptually, this evaluates the integral\n     * of the underlying function we use, for the range of\n     * [(storedPermits - permitsToTake), storedPermits].\n     *\n     * <p>This always holds: {@code 0 <= permitsToTake <= storedPermits}\n     */\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\n\n    }\n\n    /**\n     *\n     * @param {Number} nowMicros\n     * @return {Number}\n     */\n    resync(nowMicros) {\n        if (Utility.isNullOrUndefined(nowMicros)) {\n            nowMicros = this.stopwatch.elapsedMicros();\n        }\n\n        // if nextFreeTicket is in the past, resync to now\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\n\n        if (nowMicros > nextFreeTicketMicros) {\n            this.storedPermits = min(this._maxPermits, this._storedPermits + (nowMicros - nextFreeTicketMicros) / this.stableIntervalMicros);\n\n            nextFreeTicketMicros = this._nextFreeTicketMicros = nowMicros;\n        }\n\n        return nextFreeTicketMicros;\n    }\n\n}\n\nexport default RateLimiter;\n"]}