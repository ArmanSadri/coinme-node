{"version":3,"sources":["../../src/js/RateLimiter.js"],"names":[],"mappings":"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","file":"RateLimiter.js","sourcesContent":["import Preconditions from \"./Preconditions\";\r\nimport TimeUnit from \"./TimeUnit\";\r\nimport Utility from \"./Utility\";\r\nimport CoreObject from \"./CoreObject\";\r\nimport Stopwatch from \"./Stopwatch\";\r\n\r\nconst MICROSECONDS = TimeUnit.MICROSECONDS;\r\nconst SECONDS = TimeUnit.SECONDS;\r\n\r\nclass RateLimiter extends CoreObject {\r\n\r\n    constructor(options) {\r\n        super(options);\r\n\r\n        /**\r\n         * @type {Stopwatch}\r\n         * @private\r\n         */\r\n        this._stopwatch = new Stopwatch({ start: true });\r\n\r\n        /**\r\n         * @type {String}\r\n         * @private\r\n         */\r\n        this._failAction = Utility.take(options, 'failAction', {\r\n                type: 'string',\r\n                required: false,\r\n                defaultValue: 'wait'\r\n            });\r\n    }\r\n\r\n    //region property: {String} failAction\r\n    /**\r\n     * @returns {String}\r\n     */\r\n    get failAction() {\r\n        return this._failAction;\r\n    }\r\n    //endregion\r\n\r\n    //region property: {Stopwatch} stopwatch\r\n    /**\r\n     * @returns {Stopwatch}\r\n     */\r\n    get stopwatch() {\r\n        return this._stopwatch;\r\n    }\r\n    //endregion\r\n\r\n    //region property: {String} rate\r\n\r\n    /**\r\n     * Updates the stable rate of this {@code RateLimiter}, that is, the\r\n     * {@code permitsPerSecond} argument provided in the factory method that\r\n     * constructed the {@code RateLimiter}. Currently throttled threads will <b>not</b>\r\n     * be awakened as a result of this invocation, thus they do not observe the new rate;\r\n     * only subsequent requests will.\r\n     *\r\n     * <p>Note though that, since each request repays (by waiting, if necessary) the cost\r\n     * of the <i>previous</i> request, this means that the very next request\r\n     * after an invocation to {@code setRate} will not be affected by the new rate;\r\n     * it will pay the cost of the previous request, which is in terms of the previous rate.\r\n     *\r\n     * <p>The behavior of the {@code RateLimiter} is not modified in any other way,\r\n     * e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds,\r\n     * it still has a warmup period of 20 seconds after this method invocation.\r\n     *\r\n     * @param {Number} permitsPerSecond the new stable rate of this {@code RateLimiter}\r\n     * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero\r\n     */\r\n    set rate(permitsPerSecond) {\r\n        Preconditions.shouldBeTrue(permitsPerSecond > 0.0 && !Utility.isNaN(permitsPerSecond), \"rate must be positive\");\r\n\r\n        this._rate = permitsPerSecond;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    get rate() {\r\n        return this._rate;\r\n    }\r\n    //endregion\r\n\r\n    /**\r\n     * Acquires a single permit from this {@code RateLimiter}, blocking until the\r\n     * request can be granted. Tells the amount of time slept, if any.\r\n     *\r\n     * <p>This method is equivalent to {@code acquire(1)}.\r\n     *\r\n     * @param {Number} [permits]\r\n     * @return {Number} time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited\r\n     * @since 16.0 (present in 13.0 with {@code void} return type})\r\n     */\r\n    acquire(permits) {\r\n        return new Promise((resolve, reject) => {\r\n            return self.tryAcquire(permits);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reserves the given number of permits from this {@code RateLimiter} for future use, returning\r\n     * the number of microseconds until the reservation can be consumed.\r\n     *\r\n     * @param {Number} [permits]\r\n     * @return {Number} time in microseconds to wait until the resource can be acquired, never negative\r\n     */\r\n    reserve(permits) {\r\n        permits = this.checkPermits(permits);\r\n\r\n        return this.reserveAndGetWaitLength(permits, this.stopwatch.elapsedMicros());\r\n    }\r\n\r\n    /**\r\n     * Reserves next ticket and returns the wait time that the caller must wait for.\r\n     *\r\n     * @private\r\n     * @param {Number} permits\r\n     * @param {Number} nowMicros\r\n     * @return {Number} the required wait time, never negative\r\n     */\r\n    reserveAndGetWaitLength(permits, nowMicros) {\r\n        let momentAvailable = this.reserveEarliestAvailable(permits, nowMicros);\r\n\r\n        return max(momentAvailable - nowMicros, 0);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Number} nowMicros\r\n     * @param {Number} timeoutMicros\r\n     * @returns {boolean}\r\n     */\r\n    canAcquire(nowMicros, timeoutMicros) {\r\n        return this.queryEarliestAvailable(nowMicros) - timeoutMicros <= nowMicros;\r\n    }\r\n\r\n    /**\r\n     * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained\r\n     * without exceeding the specified {@code timeout}, or returns {@code false}\r\n     * immediately (without waiting) if the permits would not have been granted\r\n     * before the timeout expired.\r\n     *\r\n     * @param {Number} [permits] the number of permits to acquire\r\n     * @param {Number} [timeout] the maximum time to wait for the permits. Negative values are treated as zero.\r\n     * @param {TimeUnit} [unit] the time unit of the timeout argument\r\n     * @return {boolean} if the permits were acquired\r\n     * @throws IllegalArgumentException if the requested number of permits is negative or zero\r\n     */\r\n    tryAcquire(permits, timeout, unit) {\r\n        permits = RateLimiter.checkPermits(permits);\r\n        timeout = Utility.defaultNumber(timeout, 0);\r\n        unit = Utility.defaultObject(unit, MICROSECONDS);\r\n\r\n        let timeoutMicros = Math.max(unit.toMicros(timeout), 0);\r\n\r\n        let microsToWait;\r\n        let nowMicros = this.stopwatch.elapsedMicros();\r\n\r\n        if (!this.canAcquire(nowMicros, timeoutMicros)) {\r\n            return false;\r\n        } else {\r\n            microsToWait = this.reserveAndGetWaitLength(permits, nowMicros);\r\n        }\r\n\r\n        this.stopwatch.sleepMicrosUninterruptibly(microsToWait);\r\n\r\n        return true;\r\n    }\r\n\r\n    //region abstract\r\n    /**\r\n     * Returns the earliest time that permits are available (with one caveat).\r\n     *\r\n     * @param {Number} nowMicros\r\n     * @return the time that permits are available, or, if permits are available immediately, an\r\n     *     arbitrary past or present time\r\n     */\r\n    queryEarliestAvailable(nowMicros) {\r\n        throw new Error('Not implemented');\r\n    }\r\n\r\n    /**\r\n     * Reserves the requested number of permits and returns the time that those permits can be used\r\n     * (with one caveat).\r\n     *\r\n     * @param {Number} permits\r\n     * @param {Number} nowMicros\r\n     * @return {Number} the time that the permits may be used, or, if the permits may be used immediately, an\r\n     *     arbitrary past or present time\r\n     */\r\n    reserveEarliestAvailable(permits, nowMicros) {\r\n        throw new Error('Not implemented');\r\n    }\r\n    //endregion\r\n\r\n    //region statics\r\n    /**\r\n     * @private\r\n     * @param {Number} [permits]\r\n     * @returns {Number}\r\n     */\r\n    static checkPermits(permits) {\r\n        if (Utility.isNullOrUndefined(permits)) {\r\n            return 1;\r\n        }\r\n\r\n        Utility.shouldBeTrue(permits > 0, `Requested permits (${permits}) must be positive`);\r\n\r\n        return permits;\r\n    }\r\n    //endregion\r\n}\r\n\r\nclass SmoothRateLimiter extends RateLimiter {\r\n\r\n    constructor(options) {\r\n        super(options);\r\n\r\n        /**\r\n         * The currently stored permits.\r\n         */\r\n        this._storedPermits = 0;\r\n\r\n        /**\r\n         * The maximum number of stored permits.\r\n         * @type {Number}\r\n         * @private\r\n         */\r\n        this._maxPermits = 0;\r\n\r\n        /**\r\n         * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits\r\n         * per second has a stable interval of 200ms.\r\n         */\r\n        this._stableIntervalMicros;\r\n\r\n\r\n        /**\r\n         * The time when the next request (no matter its size) will be granted. After granting a\r\n         * request, this is pushed further in the future. Large requests push this further than small\r\n         * requests.\r\n         * @type {Number}\r\n         * @private\r\n         */\r\n        this._nextFreeTicketMicros = 0; // could be either in the past or future\r\n\r\n    }\r\n\r\n    // doSetRate(permitsPerSecond, nowMicros) {\r\n    //     this.resync(nowMicros);\r\n    //     this._stableIntervalMicros = SECONDS.toMicros(1) / permitsPerSecond;\r\n    // }\r\n\r\n    queryEarliestAvailable(nowMicros) {\r\n        return this.nextFreeTicketMicros;\r\n    }\r\n\r\n    reserveEarliestAvailable(requiredPermits, nowMicros) {\r\n        this.resync(nowMicros);\r\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\r\n\r\n        let returnValue = nextFreeTicketMicros;\r\n        let storedPermitsToSpend = min(requiredPermits, this.storedPermits);\r\n        let freshPermits = requiredPermits - storedPermitsToSpend;\r\n\r\n        let waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) + (freshPermits * stableIntervalMicros);\r\n\r\n        this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\r\n        this.storedPermits -= storedPermitsToSpend;\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Translates a specified portion of our currently stored permits which we want to\r\n     * spend/acquire, into a throttling time. Conceptually, this evaluates the integral\r\n     * of the underlying function we use, for the range of\r\n     * [(storedPermits - permitsToTake), storedPermits].\r\n     *\r\n     * <p>This always holds: {@code 0 <= permitsToTake <= storedPermits}\r\n     */\r\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Number} nowMicros\r\n     * @return {Number}\r\n     */\r\n    resync(nowMicros) {\r\n        if (Utility.isNullOrUndefined(nowMicros)) {\r\n            nowMicros = this.stopwatch.elapsedMicros();\r\n        }\r\n\r\n        // if nextFreeTicket is in the past, resync to now\r\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\r\n\r\n        if (nowMicros > nextFreeTicketMicros) {\r\n            this.storedPermits = min(this._maxPermits, this._storedPermits + (nowMicros - nextFreeTicketMicros) / this.stableIntervalMicros);\r\n\r\n            nextFreeTicketMicros = this._nextFreeTicketMicros = nowMicros;\r\n        }\r\n\r\n        return nextFreeTicketMicros;\r\n    }\r\n\r\n}\r\n\r\nexport default RateLimiter;\r\n"]}