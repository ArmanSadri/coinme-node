{"version":3,"sources":["../../src/js/RateLimiter.js"],"names":["RateLimiter","options","_stopwatch","start","permits","timeout","timeUnit","tryAcquire","checkPermits","reserveAndGetWaitLength","stopwatch","elapsedMicros","nowMicros","momentAvailable","reserveEarliestAvailable","waitLength","Math","max","timeoutMicros","queryEarliestAvailable","unit","shouldBeNumber","permitsPerSecond","defaultNumber","defaultObject","SECONDS","toMicros","microsToWait","goalMicros","canAcquire","Promise","reject","Error","shouldBeExisting","ticker","wait","MICROSECONDS","throwNotImplemented","shouldBeTrue","isNaN","_permitsPerSecond","shouldBePositiveNumber","doSetRate","isNotExisting","SmoothRateLimiter","_storedPermits","_maxPermits","_stableIntervalMicros","_nextFreeTicketMicros","resync","stableIntervalMicros","doSetRate2","requiredPermits","nextFreeTicketMicros","returnValue","storedPermitsToSpend","min","freshPermits","waitMicros","storedPermitsToWaitTime","storedPermits","permitsToTake","isNullOrUndefined","SmoothBurstyRateLimiter","maxBurstSeconds","take","arguments","oldMaxPermits","SmoothWarmingUpRateLimiter","warmupPeriod","warmupPeriodMicros","halfPermits","coldIntervalMicros","slope","availablePermitsAboveHalf","micros","permitsAboveHalfToTake","permitsToTime"],"mappings":"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","file":"RateLimiter.js","sourcesContent":["import Preconditions from \"./Preconditions\";\nimport TimeUnit from \"./TimeUnit\";\nimport Utility from \"./Utility\";\nimport CoreObject from \"./CoreObject\";\nimport Stopwatch from \"./Stopwatch\";\nimport Errors from \"./errors/Errors\";\nimport Logger from 'winston';\n\nclass RateLimiter extends CoreObject {\n\n    _permitsPerSecond;\n\n    constructor(options) {\n        super(options);\n\n        /**\n         * @type {Stopwatch}\n         * @private\n         */\n        this._stopwatch = new Stopwatch({ start: true });\n\n        // /**\n        //  * @type {String}\n        //  * @private\n        //  */\n        // this._failAction = Utility.take(options, 'failAction', {\n        //         type: 'string',\n        //         required: false,\n        //         defaultValue: 'wait'\n        //     });\n    }\n\n    //region property: {Stopwatch} stopwatch\n    /**\n     * @returns {Stopwatch}\n     */\n    get stopwatch() {\n        return this._stopwatch;\n    }\n\n    //endregion\n\n    //region property: {Ticker} ticker\n    /**\n     *\n     * @return {Ticker}\n     */\n    get ticker() {\n        return this.stopwatch.ticker;\n    }\n    //endregion\n\n    //region property: {Number} permitsPerSecond\n\n    /**\n     * Updates the stable rate of this {@code RateLimiter}, that is, the\n     * {@code permitsPerSecond} argument provided in the factory method that\n     * constructed the {@code RateLimiter}. Currently throttled threads will <b>not</b>\n     * be awakened as a result of this invocation, thus they do not observe the new rate;\n     * only subsequent requests will.\n     *\n     * <p>Note though that, since each request repays (by waiting, if necessary) the cost\n     * of the <i>previous</i> request, this means that the very next request\n     * after an invocation to {@code setRate} will not be affected by the new rate;\n     * it will pay the cost of the previous request, which is in terms of the previous rate.\n     *\n     * <p>The behavior of the {@code RateLimiter} is not modified in any other way,\n     * e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds,\n     * it still has a warmup period of 20 seconds after this method invocation.\n     *\n     * @param {Number} permitsPerSecond the new stable rate of this {@code RateLimiter}\n     * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero\n     */\n    set permitsPerSecond(permitsPerSecond) {\n        Preconditions.shouldBeExisting(permitsPerSecond);\n        Preconditions.shouldBeTrue(permitsPerSecond > 0.0 && !Utility.isNaN(permitsPerSecond), \"rate must be positive\");\n\n        this._permitsPerSecond = Preconditions.shouldBePositiveNumber(permitsPerSecond, 'Rate must be positive');\n\n        this.doSetRate(permitsPerSecond, this.stopwatch.elapsedMicros());\n    }\n\n    /**\n     *\n     * @returns {Number}\n     */\n    get permitsPerSecond() {\n        return this._permitsPerSecond;\n    }\n\n    //endregion\n\n    /**\n     * Acquires a single permit from this {@code RateLimiter}. Returns a Promise that will resolve or reject.\n     * The default maximum time to wait is 30 seconds.\n     *\n     * <p>This method is equivalent to {@code acquire(1)}.\n     *\n     * @param {Number} [permits] defaults to 1\n     * @param {Number} [timeout] defaults to 30\n     * @param {TimeUnit} [timeUnit] defaults to seconds\n     * @return {Promise} time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited\n     * @since 16.0 (present in 13.0 with {@code void} return type})\n     */\n    acquire(permits, timeout, timeUnit) {\n        return this.tryAcquire(permits, timeout, timeUnit);\n    }\n\n    /**\n     * Reserves the given number of permits from this {@code RateLimiter} for future use, returning\n     * the number of microseconds until the reservation can be consumed.\n     *\n     * @param {Number} [permits]\n     * @return {Number} time in microseconds to wait until the resource can be acquired, never negative\n     */\n    reserve(permits) {\n        permits = this.checkPermits(permits);\n\n        return this.reserveAndGetWaitLength(permits, this.stopwatch.elapsedMicros());\n    }\n\n    /**\n     * Reserves next ticket and returns the wait time that the caller must wait for.\n     *\n     * @private\n     * @param {Number} permits\n     * @param {Number} nowMicros\n     * @return {Number} the required wait time, never negative\n     */\n    reserveAndGetWaitLength(permits, nowMicros) {\n        let momentAvailable = this.reserveEarliestAvailable(permits, nowMicros);\n        let waitLength = Math.max(momentAvailable - nowMicros, 0);\n\n\n        return waitLength;\n    }\n\n    /**\n     * @private\n     * @param {Number} nowMicros\n     * @param {Number} timeoutMicros\n     * @returns {boolean}\n     */\n    canAcquire(nowMicros, timeoutMicros) {\n        return this.queryEarliestAvailable(nowMicros) - timeoutMicros <= nowMicros;\n    }\n\n    /**\n     * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained\n     * without exceeding the specified {@code timeout}, or returns {@code false}\n     * immediately (without waiting) if the permits would not have been granted\n     * before the timeout expired.\n     *\n     * @param {Number} [permits] the number of permits to acquire\n     * @param {Number} [timeout] the maximum time to wait for the permits. Negative values are treated as zero.\n     * @param {TimeUnit} [unit] the time unit of the timeout argument\n     * @return {Promise} if the permits were acquired\n     * @throws IllegalArgumentException if the requested number of permits is negative or zero\n     */\n    tryAcquire(permits, timeout, unit) {\n        Preconditions.shouldBeNumber(this.permitsPerSecond, 'Rate must be defined.');\n\n        permits = RateLimiter.checkPermits(permits);\n        timeout = Utility.defaultNumber(timeout, 30);\n        unit = Utility.defaultObject(unit, TimeUnit.SECONDS);\n\n        let timeoutMicros = Math.max(unit.toMicros(timeout), 0);\n\n        let microsToWait;\n        let nowMicros = this.stopwatch.elapsedMicros();\n        let goalMicros = this.queryEarliestAvailable(nowMicros);\n\n        if (!this.canAcquire(nowMicros, timeoutMicros)) {\n            return Promise.reject(new Error(`RateLimit exceeded: (rate:${this.permitsPerSecond}/sec) (timeoutMicros:${timeoutMicros}) (goalMicros: ${goalMicros}) (differenceMicros:${goalMicros - nowMicros})`));\n        } else {\n            microsToWait = this.reserveAndGetWaitLength(permits, nowMicros);\n        }\n\n        Preconditions.shouldBeExisting(this.ticker, 'ticker');\n        return this.ticker.wait(microsToWait, TimeUnit.MICROSECONDS);\n    }\n\n    //region abstract\n    /**\n     * Returns the earliest time that permits are available (with one caveat).\n     *\n     * @param {Number} nowMicros\n     * @return the time that permits are available, or, if permits are available immediately, an\n     *     arbitrary past or present time\n     */\n    queryEarliestAvailable(nowMicros) {\n        Errors.throwNotImplemented();\n    }\n\n    /**\n     * Reserves the requested number of permits and returns the time that those permits can be used\n     * (with one caveat).\n     *\n     * @param {Number} permits\n     * @param {Number} nowMicros\n     * @return {Number} the time that the permits may be used, or, if the permits may be used immediately, an\n     *     arbitrary past or present time\n     */\n    reserveEarliestAvailable(permits, nowMicros) {\n        Errors.throwNotImplemented();\n    }\n\n    //endregion\n\n    //region statics\n    /**\n     * @private\n     * @param {Number} [permits]\n     * @returns {Number}\n     */\n    static checkPermits(permits) {\n        if (Utility.isNotExisting(permits)) {\n            return 1;\n        }\n\n        Preconditions.shouldBeNumber(permits, `Requested permits (${permits}) must be positive`);\n        Preconditions.shouldBeTrue(permits > 0, `Requested permits (${permits}) must be positive`);\n\n        return permits;\n    }\n\n    //endregion\n}\n\nclass SmoothRateLimiter extends RateLimiter {\n\n    constructor(options) {\n        super(options);\n\n        /**\n         * The currently stored permits.\n         */\n        this._storedPermits = 0;\n\n        /**\n         * The maximum number of stored permits.\n         * @type {Number}\n         * @private\n         */\n        this._maxPermits = 0;\n\n        /**\n         * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits\n         * per second has a stable interval of 200ms.\n         */\n        this._stableIntervalMicros = 0;\n\n        /**\n         * The time when the next request (no matter its size) will be granted. After granting a\n         * request, this is pushed further in the future. Large requests push this further than small\n         * requests.\n         * @type {Number}\n         * @private\n         */\n        this._nextFreeTicketMicros = 0; // could be either in the past or future\n    }\n\n    /**\n     * @protected\n     * @param permitsPerSecond\n     * @param nowMicros\n     */\n    doSetRate(permitsPerSecond, nowMicros) {\n        this.resync(nowMicros);\n        let stableIntervalMicros = TimeUnit.SECONDS.toMicros(1) / permitsPerSecond;\n        this._stableIntervalMicros = stableIntervalMicros;\n        this.doSetRate2(permitsPerSecond, stableIntervalMicros);\n    }\n\n    /**\n     * @protected\n     * @param permitsPerSecond\n     * @param stableIntervalMicros\n     */\n    doSetRate2(permitsPerSecond, stableIntervalMicros) {\n        Errors.throwNotImplemented();\n    }\n\n    queryEarliestAvailable(nowMicros) {\n        return Preconditions.shouldBeNumber(this._nextFreeTicketMicros);\n    }\n\n    reserveEarliestAvailable(requiredPermits, nowMicros) {\n        this.resync(nowMicros);\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\n\n        let returnValue = nextFreeTicketMicros;\n        let storedPermitsToSpend = Math.min(requiredPermits, this._storedPermits);\n        let freshPermits = requiredPermits - storedPermitsToSpend;\n\n        let waitMicros = this.storedPermitsToWaitTime(this._storedPermits, storedPermitsToSpend) + (freshPermits * this._stableIntervalMicros);\n\n        this._nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;\n        this._storedPermits -= storedPermitsToSpend;\n\n        return returnValue;\n    }\n\n    /**\n     * Translates a specified portion of our currently stored permits which we want to\n     * spend/acquire, into a throttling time. Conceptually, this evaluates the integral\n     * of the underlying function we use, for the range of\n     * [(storedPermits - permitsToTake), storedPermits].\n     *\n     * <p>This always holds: {@code 0 <= permitsToTake <= storedPermits}\n     */\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\n        Errors.throwNotImplemented();\n    }\n\n    /**\n     *\n     * @param {Number} nowMicros\n     * @return {Number}\n     */\n    resync(nowMicros) {\n        if (Utility.isNullOrUndefined(nowMicros)) {\n            nowMicros = this.stopwatch.elapsedMicros();\n        }\n\n        // if nextFreeTicket is in the past, resync to now\n        let nextFreeTicketMicros = this._nextFreeTicketMicros;\n\n        if (nowMicros > nextFreeTicketMicros) {\n            this._storedPermits = Math.min(this._maxPermits, this._storedPermits + (nowMicros - nextFreeTicketMicros) / this._stableIntervalMicros);\n\n            nextFreeTicketMicros = this._nextFreeTicketMicros = nowMicros;\n        }\n\n        return nextFreeTicketMicros;\n    }\n}\n\n/**\n * This implements a \"bursty\" RateLimiter, where storedPermits are translated to\n * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is\n * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this\n * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits.\n */\nclass SmoothBurstyRateLimiter extends SmoothRateLimiter {\n\n    /** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */\n    maxBurstSeconds;\n\n    /**\n     * @param {Object} options\n     * @param {Number} options.maxBurstSeconds\n     * @param {Stopwatch} [options.stopwatch]\n     */\n    constructor(options) {\n        let maxBurstSeconds = Utility.take(options, 'maxBurstSeconds', 'number', true);\n\n        // SleepingStopwatch stopwatch, double maxBurstSeconds\n        super(...arguments);\n\n        this.maxBurstSeconds = maxBurstSeconds;\n    }\n\n    /**\n     *\n     * @param {Number} permitsPerSecond\n     * @param {Number} stableIntervalMicros\n     */\n    doSetRate2(permitsPerSecond, stableIntervalMicros) {\n        let oldMaxPermits = Utility.defaultNumber(this._maxPermits);\n        let maxBurstSeconds = Utility.defaultNumber(this.maxBurstSeconds);\n\n        this._maxPermits = maxBurstSeconds * permitsPerSecond;\n\n        // if (oldMaxPermits == Double.POSITIVE_INFINITY) {\n        //     // if we don't special-case this, we would get storedPermits == NaN, below\n        //     this.storedPermits = maxPermits;\n        // } else {\n        this._storedPermits = (oldMaxPermits == 0.0)\n            ? 0.0 // initial state\n            : this._storedPermits * this._maxPermits / oldMaxPermits;\n        // }\n\n        Preconditions.shouldBeNumber(this._storedPermits, 'storedPermits');\n        Preconditions.shouldBeNumber(this._maxPermits, '_maxPermits');\n    }\n\n    /**\n     *\n     * @param {Number} storedPermits\n     * @param {Number} permitsToTake\n     * @return {number}\n     */\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\n        return 0;\n    }\n}\n\nclass SmoothWarmingUpRateLimiter extends SmoothRateLimiter {\n\n    warmupPeriodMicros;\n\n    /**\n     * The slope of the line from the stable interval (when permits == 0), to the cold interval\n     * (when permits == maxPermits)\n     */\n    slope;\n    halfPermits;\n\n    constructor(options) {\n        //    SleepingStopwatch stopwatch, long warmupPeriod, TimeUnit timeUnit\n        let timeUnit = Utility.take(options, 'timeUnit', TimeUnit, true);\n        let warmupPeriod = Utility.take(options, 'warmupPeriod', 'number', true);\n\n        super(...arguments);\n\n        this.warmupPeriodMicros = timeUnit.toMicros(warmupPeriod);\n    }\n\n    /**\n     * @private\n     * @param permitsPerSecond\n     * @param stableIntervalMicros\n     */\n    doSetRate2(permitsPerSecond, stableIntervalMicros) {\n        let oldMaxPermits = this._maxPermits;\n        this._maxPermits = this.warmupPeriodMicros / stableIntervalMicros;\n        this.halfPermits = this._maxPermits / 2.0;\n\n        // Stable interval is x, cold is 3x, so on average it's 2x. Double the time -> halve the rate\n        let coldIntervalMicros = stableIntervalMicros * 3.0;\n        this.slope = (coldIntervalMicros - stableIntervalMicros) / this.halfPermits;\n\n        // if (oldMaxPermits == Number.POSITIVE_INFINITY) {\n        //     // if we don't special-case this, we would get storedPermits == NaN, below\n        //     this._storedPermits = 0.0;\n        // } else {\n            this._storedPermits = (oldMaxPermits == 0.0)\n                ? this._maxPermits // initial state is cold\n                : this._storedPermits * this._maxPermits / oldMaxPermits;\n        // }\n    }\n\n    /**\n     * @private\n     * @param storedPermits\n     * @param permitsToTake\n     * @return {number}\n     */\n    storedPermitsToWaitTime(storedPermits, permitsToTake) {\n        let availablePermitsAboveHalf = storedPermits - this.halfPermits;\n        let micros = 0;\n        // measuring the integral on the right part of the function (the climbing line)\n        if (availablePermitsAboveHalf > 0.0) {\n            let permitsAboveHalfToTake = Math.min(availablePermitsAboveHalf, permitsToTake);\n            micros = (permitsAboveHalfToTake * (this.permitsToTime(availablePermitsAboveHalf)\n                + this.permitsToTime(availablePermitsAboveHalf - permitsAboveHalfToTake)) / 2.0);\n            permitsToTake -= permitsAboveHalfToTake;\n        }\n        // measuring the integral on the left part of the function (the horizontal line)\n        micros += (this._stableIntervalMicros * permitsToTake);\n        return micros;\n    }\n\n    /**\n     * @private\n     * @param permits\n     * @return {*}\n     */\n    permitsToTime(permits) {\n        return this._stableIntervalMicros + permits * this.slope;\n    }\n}\n\nexport {RateLimiter};\nexport {SmoothRateLimiter};\nexport {SmoothBurstyRateLimiter};\nexport {SmoothWarmingUpRateLimiter};\nexport default SmoothRateLimiter;\n"]}