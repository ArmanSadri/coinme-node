{"version":3,"sources":["../../src/js/Address.js"],"names":[],"mappings":"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","file":"Address.js","sourcesContent":["import Utility from \"./Utility\";\nimport CoreObject from \"./CoreObject\";\nimport URI from \"urijs\";\nimport altcoin from \"altcoin-address\";\nimport Preconditions from \"~/Preconditions\";\n\nlet VALIDATORS = {\n\n    /**\n     * @param {URI|null|String} uri\n     */\n    'general': function (uri) {\n        if (!uri) {\n            return false;\n        }\n\n        if (Utility.isString(uri)) {\n            let index = uri.indexOf(\":/\");\n\n            if (-1 === index) {\n                return false;\n            }\n\n            let protocol = uri.substring(0, index);\n            let rest = uri.substring(index + 2);\n\n            uri = new URI(protocol + \"://\" + rest);\n        }\n\n        let scheme = uri.scheme();\n        let host = uri.host();\n\n        return !(Utility.isBlank(scheme) || Utility.isBlank(host));\n    },\n\n    /**\n     * @param {URI} uri\n     * @returns {*}\n     */\n    'bitcoin': function (uri) {\n        return altcoin.validate(Utility.optString(uri));\n    }\n};\n\n/**\n * A class for uniquely identifying something.\n */\nexport default class Address extends CoreObject {\n\n    /**\n     *\n     * @param {URI|String|Object} options\n     * @param {Function} [options.validator]\n     * @param {Boolean} [options.strict] Set to false to skip validation.\n     */\n    constructor(options) {\n        if (Utility.isString(options)) {\n            options = {value: options};\n        } else if (options instanceof URI) {\n            options = {value: options};\n        }\n\n        /**\n         * @type {String|URI}\n         */\n        let value = Utility.take(options, 'value');\n        let validator = Utility.take(options, 'validator');\n        let strict = Utility.take(options, 'strict');\n\n        Preconditions.shouldBeDefined(value, 'Cannot construct an empty Address.');\n\n        Preconditions.shouldBeTrue(\n            Preconditions.shouldBeFunction(\n                VALIDATORS['general'], 'general validator is required')\n            (value),\n            'general validator failed for: ' + value\n        );\n\n        super(options);\n\n        this._uri = URI(value);\n        this._validator = validator || VALIDATORS[Utility.toLowerCase(this.resource)];\n        this._strict = (false === strict);\n\n        if (this._strict) {\n            // Require Validation\n            Preconditions.shouldBeFunction(this.validator, 'validator not found for \\'' + this.toString() + '\\'');\n            Preconditions.shouldBeTrue(this.valid, 'not valid');\n        }\n    }\n\n    get strict() {\n        return this._strict;\n    }\n\n    get value() {\n        return this.uri.host();\n    }\n\n    get resource() {\n        return this.uri.scheme();\n    }\n\n    /**\n     * @returns {URI}\n     */\n    get uri() {\n        return this._uri;\n    }\n\n    /**\n     *\n     * @returns {Boolean}\n     */\n    get valid() {\n        if (Utility.isUndefined(this._valid) && this.validator) {\n            this._valid = this.validator(this.uri);\n        }\n\n        return this._valid;\n    }\n\n    /**\n     * @returns {Function}\n     */\n    get validator() {\n        return this._validator;\n    }\n\n    /**\n     *\n     * @returns {String}\n     */\n    toString() {\n        return this.valueOf();\n    }\n\n    /**\n     * @returns {String}\n     */\n    valueOf() {\n        return this._uri.toString();\n    }\n\n    /**\n     * @returns {String}\n     */\n    static toString() {\n        return 'Address';\n    }\n\n    /**\n     * @param {String} scheme\n     * @param {Function} validatorFn\n     */\n    static registerValidator(scheme, validatorFn) {\n        scheme = Preconditions.shouldNotBeBlank(Utility.toLowerCase(Preconditions.shouldBeString(scheme)));\n        validatorFn = Preconditions.shouldBeFunction(validatorFn);\n\n        VALIDATORS[Utility.toLowerCase(scheme)] = validatorFn;\n\n        return validatorFn;\n    }\n}"]}