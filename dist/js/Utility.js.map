{"version":3,"sources":["../../src/js/Utility.js"],"names":["TEMPORALS","EMAIL_PATTERN","Utility","target","propertyNameOrObject","propertyValueOrUndefined","shouldBeObject","isString","propertyName","propertyValue","shouldBeString","shouldNotBeBlank","shouldBeDefined","set","isObject","shouldBeUndefined","each","value","key","path","input","output","isNotExisting","undefined","trim","startsWith","substring","joinPaths","home","uri","baseUri","getPath","toString","Error","constructor","name","one","two","type1","typeOf","type2","string","isNullOrUndefined","optString","toLowerCase","string1","string2","isSameType","isStringEqual","optLowerCase","isExisting","object","type","isClass","toClass","fail","defaultValue","get","apply","arguments","instance","isInstance","boolean","isBoolean","keyAsStringObjectArray","optionalTypeDeclarationOrDefaults","requiredByDefault","executeValidator","ruleset","fn","scope","shouldBeFunction","shouldBeTrue","call","executeAdapter","executeRequired","required","isDefined","shouldBeExisting","executeType","isUndefined","shouldBeType","executeChecks","global_defaults","shouldNotBeInstance","assign","isFunction","validator","defaults","toRuleset","mode","result","indexOf","parentPath","lastIndexOf","itemKey","parent","forEach","rulesetOrObject","keyOrIndex","requiredType","isNotBlank","isNumber","take","knownTypes","typeOfType","objectType","isErrorClass","isErrorInstance","isTemporal","test","primitives","is","valueOrFn","isNaN","anything","shouldBeInstance","numberOrStringOrBig","getClass","isBlank","toUpperCase","isPrimitive","toJson","toJSON","u","n","nu","isNull","isFalsey","stringOrArrayOrNumber","str","Number","parseFloat","toFixed","TypeError","optionalParserOrFormat","date","optDateTime","toInstant","UTC","of","throwNotSure","optionalDateFormatStringOrDateFormatter","now","withZoneSameInstant","toTimeZoneOffset","isDate","from","atZone","parse","toDateTimeFormatter","zone","query","ofInstant","localTime","localDate","toLocalTime","atDate","stringOrFormatter","ISO_ZONED_DATE_TIME","ofPattern","length","dateTime","args","updates","Object","keys","i","l","prop","stringOrArray","isArray","getWithDefault","array","getProperties","clazz","optClassName"],"mappings":"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","file":"Utility.js","sourcesContent":["'use strict';\n\nimport Lodash from \"lodash\";\n/** @type {Preconditions} */\nimport Preconditions from \"~/Preconditions\";\n/** @type {Ember} **/\nimport Ember from \"~/Ember\";\nimport CoreObject from \"~/CoreObject\";\nimport {Errors} from \"./errors\";\nimport Big from \"big.js/big\";\nimport URI from \"urijs\";\nimport Promise from \"bluebird\";\nimport osenv from \"osenv\";\n\nimport {\n    Instant,\n    LocalDate,\n    ZonedDateTime,\n    LocalDateTime,\n    DateTimeFormatter,\n    ZoneOffset,\n    nativeJs,\n    convert,\n    TemporalQueries,\n    LocalTime\n} from \"js-joda\";\n\nlet TEMPORALS = {\n    'Instant': Instant,\n    'LocalTime': LocalTime,\n    'LocalDate': LocalDate,\n    'LocalDateTime': LocalDateTime,\n    'ZonedDateTime': ZonedDateTime\n};\n\nlet EMAIL_PATTERN = /(?:\\w)+(?:\\w|-|\\.|\\+)*@(?:\\w)+(?:\\w|\\.|-)*\\.(?:\\w|\\.|-)+$/;\n\n/**\n * @class\n * @singleton\n */\nclass Utility {\n\n    /**\n     *\n     * @param {URI|String|{baseUri:URI|String, uri:URI|String}} path\n     * @return {URI}\n     */\n    static getPath(path) {\n        const input = path;\n        let output;\n\n        if (Utility.isNotExisting(path)) {\n            output = undefined;\n        } else if (Utility.isString(path)) {\n            path = path.trim();\n\n            if (path.startsWith('~/')) {\n                path = path.substring(2);\n\n                output = URI.joinPaths(osenv.home(), path);\n            } else {\n                output = URI(path);\n            }\n        } else if (path instanceof URI) {\n            output = path;\n        } else if (path.uri || path.baseUri) {\n            let baseUri = Utility.getPath(path.baseUri) || '';\n            let uri = Utility.getPath(path.uri) || '';\n\n            if (uri.toString().startsWith('/')) {\n                // absolute uri\n                output = uri;\n            } else {\n                output = URI.joinPaths(baseUri, uri).toString();\n            }\n        }\n\n        if (output) {\n            return output;\n        }\n\n        throw new Error(`I don't know what to do here: ${input}`);\n    }\n\n    static isTemporal(value) {\n        // Direct Subclass:\n        //     ChronoLocalDate, ChronoLocalDateTime, ChronoZonedDateTime, DateTimeBuilder, DayOfWeek, Instant, LocalTime, Month, MonthDay, src/format/DateTimeParseContext.js~Parsed, Year, YearMonth\n        // Indirect Subclass:\n        //     LocalDate, LocalDateTime, ZonedDateTime\n\n        // console.log(value.toString());\n        // console.log(value.prototype);\n        // console.log(value.__proto__);\n        // console.log(value.constructor);\n        return !!TEMPORALS[value.constructor.name];\n    }\n\n    /**\n     *\n     * @param {*} one\n     * @param {*} two\n     * @return {boolean}\n     */\n    static isSameType(one, two) {\n        let type1 = Utility.typeOf(one);\n        let type2 = Utility.typeOf(two);\n\n        return type1 === type2;\n    }\n\n    /**\n     *\n     * @param {String|null|undefined} string\n     * @return {String|undefined}\n     */\n    static optLowerCase(string) {\n        if (Utility.isNullOrUndefined(string)) {\n            return undefined;\n        }\n\n        return (Utility.optString(string) || '').toLowerCase();\n    }\n\n    /**\n     *\n     * @param {String} string1\n     * @param {String} string2\n     * @return {Boolean}\n     */\n    static isStringEqualIgnoreCase(string1, string2) {\n        if (Utility.isNotExisting(string1) || Utility.isNotExisting(string2)) {\n            return Utility.isSameType(string1, string2);\n        }\n\n        return Utility.isStringEqual(\n            Utility.optLowerCase(string1),\n            Utility.optLowerCase(string2));\n    }\n\n    /**\n     * (null, null) -> true\n     *\n     * @param {String|*} string1\n     * @param {String|*} string2\n     * @return {boolean}\n     */\n    static isStringEqual(string1, string2) {\n        if (Utility.isNotExisting(string1) || Utility.isNotExisting(string2)) {\n            return Utility.isSameType(string1, string2);\n        }\n\n        string1 = Utility.optString(string1);\n        string2 = Utility.optString(string2);\n\n        if (!Utility.isSameType(string1, string2)) {\n            return false;\n        } else if (!Utility.isExisting(string1)) {\n            return false;\n        }\n\n        return string1 === string2;\n    }\n\n    /**\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isObject(object) {\n        let type = Utility.typeOf(object);\n\n        return 'object' === type || 'instance' === type;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {Class}\n     */\n    static toClass(object) {\n        if (Utility.isClass(object)) {\n            return object;\n        } else if (Utility.isObject(object)) {\n            return object.toClass();\n        }\n\n        Preconditions.fail('object|class', Utility.typeOf(object), 'Must be correct type');\n    }\n\n    static isNumber(object) {\n        return 'number' === Utility.typeOf(object);\n    }\n\n    static isClass(object) {\n        return 'class' === Utility.typeOf(object);\n    }\n\n    static isInstance(object) {\n        return 'instance' === Utility.typeOf(object);\n    }\n\n    static isError(object) {\n        return 'error' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} path\n     * @param {*} [defaultValue]\n     * @returns {*}\n     */\n    static result(object, path, defaultValue) {\n        return Lodash.get.apply(Lodash, arguments);\n    }\n\n    /**\n     * @param {CoreObject|Class<CoreObject>} instance - Must be an instance of CoreObject (or subclass)\n     */\n    static toClassOrFail(instance) {\n        if (Utility.isInstance(instance)) {\n\n        } else if (Utility.isClass(instance)) {\n\n        } else {\n            Preconditions.fail(CoreObject, instance, 'Was not an instance or class. Cannot continue');\n        }\n\n        return instance.toClass();\n    }\n\n    /**\n     *\n     * @param boolean\n     * @returns {*}\n     */\n    static ifBoolean(boolean) {\n        if (Utility.isBoolean(boolean)) {\n            return boolean;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Uses Lodash.get, but then removes the key from the parent object.\n     *\n     * It takes properties off of an object and optionally does validation.\n     *\n     * var value = Utility.take(object, key, type);\n     *\n     * var value = Utility.take(object, {\n     *                           key: String,\n     *                       });\n     *\n     * var {value1, value2} = Utility.take(object, [keyAsString1, keyAsString2]);\n     *\n     * var {value1} = Utility.take(object, [keyAsString1]);\n     *\n     * A ruleset is defined as:\n     *\n     *  {\n     *      // return true to pass. false to fail.\n     *      validator: function(value) { return boolean; } throws Error,\n     *      type: String,\n     *      adapter: function(value) { return new_value; },\n     *      required: true|false|undefined\n     *   }\n     *\n     * @param {Object} object\n     * @param {String|Object|Array} keyAsStringObjectArray\n     * @param {String|Function|Class|Object|{required:Boolean,type:String|Class,validator:Function,adapter:Function, [defaultValue]:*}} [optionalTypeDeclarationOrDefaults] - If you pass a function in, it must return true\n     * @param {Boolean} [requiredByDefault] Default value for required.\n     * @throws PreconditionsError\n     *\n     * @returns {*}\n     */\n    static take(object, keyAsStringObjectArray, optionalTypeDeclarationOrDefaults, requiredByDefault) {\n        if (!object) {\n            object = {};\n        }\n\n        Preconditions.shouldBeDefined(keyAsStringObjectArray, 'key must be defined');\n\n        //region utilities\n        /**\n         *\n         * @param {{[scope]: Object, [adapter]: function, [validator]: function, [adapter]: function}}  ruleset\n         * @param {String} key\n         * @param {*} value\n         * @returns {*}\n         */\n        function executeValidator(ruleset, key, value) {\n            let fn = Lodash.get(ruleset, 'validator');\n            let scope = Lodash.get(ruleset, 'scope') || this;\n\n            if (fn) {\n                Preconditions.shouldBeFunction(fn, 'validator must be type of function');\n                Preconditions.shouldBeTrue(false !== fn.call(scope, value), 'Failed validation: {key:\\'' + key + '\\' value:\\'' + value + '\\'');\n            }\n\n            return value;\n        }\n\n        /**\n         * If the ruleset requires, will throw.\n         *\n         * @throws PreconditionsError\n         * @param {{[scope]: Object, [adapter]: function, [validator]: function, [adapter]: function}}  ruleset\n         * @param {String} key\n         * @param {*} value\n         * @returns {*}\n         */\n        function executeAdapter(ruleset, key, value) {\n            let fn = Lodash.get(ruleset, 'adapter');\n            let scope = Lodash.get(ruleset, 'scope') || this;\n\n\n            if (fn) {\n                Preconditions.shouldBeFunction(fn, 'Validator must be a function');\n\n                value = fn.call(scope, value);\n            }\n\n            return value;\n        }\n\n        /**\n         * If the ruleset requires, will throw.\n         *\n         * @throws PreconditionsError\n         * @param {{[scope]: Object, [adapter]: function, [validator]: function, [adapter]: function, [defaultValue]:*}}  ruleset\n         * @param {String} key\n         * @param {*} value\n         * @returns {*}\n         */\n        function executeRequired(ruleset, key, value) {\n            let required = Lodash.get(ruleset, 'required');\n\n            if (Utility.isDefined(ruleset.defaultValue)) {\n                if (!value) {\n                    value = ruleset.defaultValue;\n                }\n            }\n\n            if (true === required) {\n                if (Utility.isNullOrUndefined(value)) {\n                    Preconditions.shouldBeExisting(value, `Utility.take(). 'key=${key}' is required`);\n                }\n            }\n\n\n            return value;\n        }\n\n        /**\n         * If the ruleset requires, will throw.\n         *\n         * @throws PreconditionsError\n         * @param {{[scope]: Object, [adapter]: function, [validator]: function, [adapter]: function}}  ruleset\n         * @param {String} key\n         * @param {*} value\n         * @returns {*}\n         */\n        function executeType(ruleset, key, value) {\n            if (!ruleset.required && Utility.isUndefined(value)) {\n                return;\n            }\n\n            let type = Lodash.get(ruleset, 'type');\n\n            if (type) {\n                Preconditions.shouldBeType(type, value, `${key} was wrong type.`);\n            }\n\n            return value;\n        }\n\n        /**\n         * Main entry point for checks.\n         *\n         * @param {{[adapter]: function, [validator]: function, [adapter]: function}}  ruleset\n         * @param {String} key\n         * @param {*} value\n         * @returns {*}\n         */\n        function executeChecks(ruleset, key, value) {\n            // console.log(`executeChecks with ruleset: ${JSON.stringify(ruleset)} and (key:${key}) (value:${value})`);\n\n            value = executeAdapter(ruleset, key, value);\n            value = executeRequired(ruleset, key, value);\n            value = executeType(ruleset, key, value);\n            value = executeValidator(ruleset, key, value);\n\n            return value;\n        }\n\n        //endregion\n\n        //region ruleset - defaults\n        let global_defaults = {};\n\n        Preconditions.shouldNotBeInstance(optionalTypeDeclarationOrDefaults, 'the 3rd parameter cannot be an instance of a CoreObject field.');\n\n        if (Utility.isObject(optionalTypeDeclarationOrDefaults)) {\n            if (Utility.isClass(optionalTypeDeclarationOrDefaults)) {\n                global_defaults = {\n                    type: optionalTypeDeclarationOrDefaults\n                };\n            } else {\n                global_defaults = Lodash.assign(global_defaults, optionalTypeDeclarationOrDefaults);\n            }\n\n            optionalTypeDeclarationOrDefaults = null;\n        } else if (Utility.isFunction(optionalTypeDeclarationOrDefaults)) {\n            global_defaults = {\n                validator: optionalTypeDeclarationOrDefaults\n            };\n\n            optionalTypeDeclarationOrDefaults = null;\n        } else if (Utility.isBoolean(optionalTypeDeclarationOrDefaults)) {\n            global_defaults = {\n                required: optionalTypeDeclarationOrDefaults\n            };\n\n            optionalTypeDeclarationOrDefaults = null;\n\n            Preconditions.shouldBeUndefined(requiredByDefault, 'You provided two booleans. That\\'s strange.');\n        } else if (Utility.isString(optionalTypeDeclarationOrDefaults)) {\n            global_defaults = {\n                type: optionalTypeDeclarationOrDefaults\n            };\n        }\n\n        if (Utility.isBoolean(requiredByDefault)) {\n            // global_defaults.required =\n            global_defaults = Utility.defaults(global_defaults, {\n                required: requiredByDefault\n            });\n        }\n\n        // if (Utility.isDefined(global_defaults.defaultValue)) {\n        //     throw new Error('has default value global');\n        // }\n\n        /**\n         *\n         * @param {Object} [defaults]\n         * @returns {{required:Boolean, validator:Function, type:String|Object, adapter:Function}}\n         */\n        function toRuleset(defaults) {\n            let ruleset = {};\n\n            ruleset = Lodash.defaults(ruleset, defaults || {}, global_defaults, {\n                required: false,\n                validator: null\n            });\n\n            return ruleset;\n        }\n\n        //endregion\n\n        let mode = Utility.typeOf(keyAsStringObjectArray);\n\n        //region String Mode\n        if ('string' === mode) {\n            /** @type {String} */\n            let key = keyAsStringObjectArray;\n            keyAsStringObjectArray = null;\n\n            /** @type {*} */\n            let value = Utility.result(object, key);\n\n            /**\n             * @type {{validator?:function, required?:boolean, type?: string|object}}\n             */\n            let ruleset = toRuleset();\n\n            // if (Utility.isClass(optionalTypeDeclarationOrDefaults)) {\n            //     ruleset = {\n            //         validator: Utility.typeMatcher(optionalTypeDeclarationOrDefaults),\n            //         required: false\n            //     };\n            // } else if (Utility.isFunction(optionalTypeDeclarationOrDefaults)) {\n            //     ruleset = {\n            //         validator: optionalTypeDeclarationOrDefaults,\n            //         required: false\n            //     };\n            // } else if (Utility.isNullOrUndefined(optionalTypeDeclarationOrDefaults)) {\n            //     ruleset = {\n            //         validator: Utility.yes,\n            //         required: false\n            //     };\n            // } else if (Utility.isObject(optionalTypeDeclarationOrDefaults) && !Utility.isInstance(optionalTypeDeclarationOrDefaults)) {\n            //     // TODO: apply global defaults.\n            //     ruleset = optionalTypeDeclarationOrDefaults;\n            // } else {\n            //     throw new TypeError('Not sure how to interpret the rules.')\n            // }\n\n            if (-1 != key.indexOf('.')) {\n                // It's an object path.\n                let parentPath = key.substring(0, key.lastIndexOf('.'));\n                let itemKey = key.substring(key.lastIndexOf('.') + 1);\n                let parent = Utility.result(object, parentPath);\n\n                delete parent[itemKey];\n            } else {\n                delete object[key];\n            }\n\n            return executeChecks(ruleset, key, value);\n        }\n        //endregion\n\n        //region Array/Object mode\n        if ('array' === mode || 'object' === mode) {\n            let result = {};\n\n            let defaults = toRuleset(Utility.result(keyAsStringObjectArray, 'defaults', {}));\n\n            Lodash.forEach(keyAsStringObjectArray,\n\n                /**\n                 *\n                 * @param {String|Object|Function} rulesetOrObject\n                 * @param {String} [rulesetOrObject.key]\n                 * @param {Number|String} keyOrIndex\n                 */\n                function (rulesetOrObject, keyOrIndex) {\n                    /**\n                     * @type {String}\n                     */\n                    let key;\n\n                    /**\n                     * @type {Object}\n                     */\n                    let ruleset;\n\n                    if ('array' === mode) {\n                        if (Utility.isString(rulesetOrObject)) {\n                            key = rulesetOrObject;\n                            ruleset = Lodash.defaults({}, defaults);\n\n                            // if (Utility.isObject(optionalTypeDeclarationOrDefaults)) {\n                            //     ruleset = Lodash.defaults(ruleset, optionalTypeDeclarationOrDefaults);\n                            // }\n                        } else if (Utility.isObject(rulesetOrObject)) {\n                            /**\n                             * @type {String}\n                             */\n                            key = Preconditions.shouldBeString(Utility.result(rulesetOrObject, 'key'), 'key not defined');\n                            ruleset = rulesetOrObject;\n                        } else if (Utility.isFunction(rulesetOrObject)) {\n                            ruleset = {\n                                validator: rulesetOrObject\n                            };\n                        } else {\n                            throw new Error('Dont know what to do: ' + rulesetOrObject);\n                        }\n                    } else if ('object' === mode) {\n                        key = keyOrIndex;\n\n                        if (Utility.isString(rulesetOrObject)) {\n                            ruleset = {\n                                type: rulesetOrObject\n                            };\n                        } else if (Utility.isObject(rulesetOrObject)) {\n                            ruleset = rulesetOrObject;\n                        } else if (Utility.isFunction(rulesetOrObject)) {\n                            ruleset = {\n                                validator: rulesetOrObject\n                            };\n                        } else {\n                            throw new Error('Dont know what to do: ' + rulesetOrObject);\n                        }\n\n                    } else {\n                        Preconditions.fail('array|object', mode, 'Unknown mode');\n                    }\n\n                    Preconditions.shouldNotBeBlank(key, 'Key must be defined by here in all situations.');\n                    Preconditions.shouldBeObject(ruleset, 'Must have a valid ruleset: ' + ruleset);\n\n                    // if (Utility.isObject(ruleset)) {\n                    //     // this is a ruleset that overrides our ruleset.\n                    //     ruleset = Lodash.defaults({key: key}, ruleset, defaults);\n                    // } else if (Utility.isFunction(ruleset)) {\n                    //     let fn = ruleset;\n                    //\n                    //     ruleset = {\n                    //         key: key,\n                    //         validator: fn\n                    //     };\n                    // } else {\n                    //     throw new Error('Cannot determine what to do with: ' + typeOfRuleset + ': ' + ruleset);\n                    // }\n\n                    ruleset = Lodash.defaults(ruleset, defaults);\n\n                    let requiredType = ruleset.type;\n\n                    // If we don't have a validator yet, check to see if we can get one.\n                    if (!ruleset.validator && Utility.isNotBlank(requiredType)) {\n                        if ('string' === requiredType) {\n                            ruleset.validator = Utility.isString;\n                        } else if ('number' === requiredType) {\n                            ruleset.validator = Utility.isNumber;\n                        } else if ('required' === requiredType) {\n                            ruleset.validator = Utility.isExisting;\n                        } else {\n                            throw new Error('I should add more types: ' + requiredType);\n                        }\n                    }\n\n                    if ('defaults' === key) {\n                        return;\n                    }\n\n                    result[key] = executeChecks(ruleset, key, Utility.take(object, key));\n                });\n\n            return result;\n        } else {\n            throw new Error('Not sure how to handle this case: ' + Utility.typeOf(keyAsStringObjectArray));\n        }\n        //endregion\n\n    }\n\n    /**\n     * Creates a test method. Uses Utility.typeOf()\n     *\n     * @param {String|Class} type\n     * @return {function}\n     */\n    static typeMatcher(type) {\n        // Ember.typeOf();                       // 'undefined'\n        // Ember.typeOf(null);                   // 'null'\n        // Ember.typeOf(undefined);              // 'undefined'\n        // Ember.typeOf('michael');              // 'string'\n        // Ember.typeOf(new String('michael'));  // 'string'\n        // Ember.typeOf(101);                    // 'number'\n        // Ember.typeOf(new Number(101));        // 'number'\n        // Ember.typeOf(true);                   // 'boolean'\n        // Ember.typeOf(new Boolean(true));      // 'boolean'\n        // Ember.typeOf(Ember.makeArray);        // 'function'\n        // Ember.typeOf([1, 2, 90]);             // 'array'\n        // Ember.typeOf(/abc/);                  // 'regexp'\n        // Ember.typeOf(new Date());             // 'date'\n        // Ember.typeOf(Ember.Object.extend());  // 'class'\n        // Ember.typeOf(Ember.Object.create());  // 'instance'\n        // Ember.typeOf(new Error('teamocil'));  // 'error'\n        // // 'normal' JavaScript object\n        // Ember.typeOf({ a: 'b' });             // 'object'\n\n        let knownTypes = {\n            'undefined': true,\n            'null': true,\n            'string': true,\n            'number': true,\n            'boolean': true,\n            'function': true,\n            'array': true,\n            'instance': true,\n            'error': true,\n            'object': true,\n            'class': true,\n            'regexp': true,\n            'date': true\n        };\n\n        /**\n         * Should be string.\n         */\n        {\n            let typeOfType = Utility.typeOf(type);\n\n            if (!('string' === typeOfType || 'class' === typeOfType)) {\n                Preconditions.fail('string', type, `The type passed in was not a string|class. It was ${typeOfType}`);\n            }\n        }\n\n        /**\n         * Should be known type.\n         */\n        {\n            // This will cause an infinite loop.\n            // Preconditions.shouldNotBeBlank(type, 'type missing');\n            // type = Utility.toLowerCase(type);\n            if (Utility.isString(type)) {\n                type = type.toLowerCase();\n\n                Preconditions.shouldBeTrue(knownTypes[type], 'unknown type: ' + type);\n\n                return (function (/** @type {*} */ object) {\n                    let objectType = Utility.typeOf(object);\n\n                    if ('object' === type || 'instance' === type) {\n                        return ('object' === objectType) || ('instance' === objectType);\n                    }\n\n                    return type === objectType;\n                });\n            } else if (Utility.isClass(type)) {\n                /**\n                 * @type {Class<CoreObject>}\n                 */\n                return function (/** @type {*} */object) {\n                    return (type.isInstance(object));\n                };\n            }\n        }\n\n\n    }\n\n    /**\n     * Returns a consistent type for the passed item.\n     *\n     * Use this instead of the built-in `typeof` to get the type of an item.\n     * It will return the same result across all browsers and includes a bit\n     * more detail. Here is what will be returned:\n     *\n     * | Return Value  | Meaning                                              |\n     * |---------------|------------------------------------------------------|\n     * | 'string'      | String primitive or String object.                   |\n     * | 'number'      | Number primitive or Number object.                   |\n     * | 'boolean'     | Boolean primitive or Boolean object.                 |\n     * | 'null'        | Null value                                           |\n     * | 'undefined'   | Undefined value                                      |\n     * | 'function'    | A function                                           |\n     * | 'array'       | An instance of Array                                 |\n     * | 'regexp'      | An instance of RegExp                                |\n     * | 'date'        | An instance of Date                                  |\n     * | 'class'       | An Ember class (created using Ember.Object.extend()) |\n     * | 'instance'    | An Ember object instance                             |\n     * | 'error'       | An instance of the Error object                      |\n     * | 'object'      | A JavaScript object not inheriting from Ember.Object |\n     *\n     * Examples:\n     *\n     ```javascript\n     Ember.typeOf();                       // 'undefined'\n     Ember.typeOf(null);                   // 'null'\n     Ember.typeOf(undefined);              // 'undefined'\n     Ember.typeOf('michael');              // 'string'\n     Ember.typeOf(new String('michael'));  // 'string'\n     Ember.typeOf(101);                    // 'number'\n     Ember.typeOf(new Number(101));        // 'number'\n     Ember.typeOf(true);                   // 'boolean'\n     Ember.typeOf(new Boolean(true));      // 'boolean'\n     Ember.typeOf(Ember.makeArray);        // 'function'\n     Ember.typeOf([1, 2, 90]);             // 'array'\n     Ember.typeOf(/abc/);                  // 'regexp'\n     Ember.typeOf(new Date());             // 'date'\n     Ember.typeOf(Ember.Object.extend());  // 'class'\n     Ember.typeOf(Ember.Object.create());  // 'instance'\n     Ember.typeOf(new Error('teamocil'));  // 'error'\n\n     // 'normal' JavaScript object\n     Ember.typeOf({ a: 'b' });             // 'object'\n     ```\n     *\n     * @method typeOf\n     * @for Ember\n     * @param {Object} object the item to check\n     * @return {String} the type\n     * @public\n     */\n    static typeOf(object) {\n        let type = Ember.typeOf(object);\n\n        if ('function' === type) {\n            // Let's isClass a bit further.\n\n            if (CoreObject.isClass(object) || Errors.isErrorClass(object)) {\n                return 'class';\n            } else if (Errors.isErrorInstance(object)) {\n                return 'error';\n            }\n        } else if ('object' === type) {\n            if (CoreObject.isInstance(object)) {\n                return 'instance';\n            } else if (Utility.isTemporal(object)) {\n                return 'temporal';\n            }\n        }\n\n        return type;\n    }\n\n    /**\n     * @param {Date|*} value\n     * @return {Boolean}\n     */\n    static isDate(value) {\n        return 'date' === Utility.typeOf(value);\n    }\n\n    /**\n     *\n     * @param {String} string\n     * @returns {boolean}\n     */\n    static isEmail(string) {\n        Preconditions.shouldBeString(string, 'Should be string');\n\n        var type = Utility.typeOf(string);\n\n        if (type !== 'string' || !string) {\n            return false;\n        }\n\n        return EMAIL_PATTERN.test(string);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isArray(object) {\n        return 'array' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isBoolean(object) {\n        return 'boolean' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @return {boolean}\n     */\n    static isUndefined(object) {\n        return 'undefined' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isDefined(object) {\n        return !this.isUndefined(object);\n    }\n\n    /**\n     * Shorthand: Utility.typeOf() === string\n     *\n     * This is for functional programming.\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isString(object) {\n        return 'string' === Utility.typeOf(object);\n    }\n\n    /**\n     * Determines if the argument is a Number, String, null, undefined\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isPrimitive(object) {\n        if (Utility.isNullOrUndefined(object)) {\n            return true;\n        }\n\n        let type = Utility.typeOf(object);\n        let primitives = ['number', 'string'];\n\n        return -1 !== primitives.indexOf(type);\n    }\n\n    /**\n     * Determine if something is a promise\n     *\n     * @param {*} object\n     * @return boolean\n     */\n    static isPromise(object) {\n        return Promise.is(object);\n    }\n\n    /**\n     *\n     * @param valueOrFn\n     */\n    static isTruthy(valueOrFn) {\n        let value;\n\n        if (Utility.isFunction(valueOrFn)) {\n            value = valueOrFn();\n        } else {\n            value = valueOrFn;\n        }\n\n        return !!value;\n    }\n\n    /**\n     *\n     * @param fn\n     * @returns {boolean}\n     */\n    static isFunction(fn) {\n        return 'function' === Utility.typeOf(fn);\n    }\n\n    /**\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isNotFunction(object) {\n        return 'function' !== Utility.typeOf(object);\n    }\n\n    /**\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isNaN(object) {\n        return Lodash.isNaN(object);\n    }\n\n    /**\n     *\n     * @param {*} anything\n     * @returns {boolean}\n     */\n    static isNull(anything) {\n        return 'null' === Utility.typeOf(anything);\n    }\n\n    /**\n     *\n     * @param {CoreObject|Class} object\n     * @returns {Class|*|Class.<CoreObject>}\n     */\n    static getClass(object) {\n        if (Utility.isClass(object)) {\n            return object;\n        }\n\n        Preconditions.shouldBeInstance(object);\n\n        return object.toClass();\n    }\n\n    /**\n     * @param {String|Number|Big|null|NaN|undefined} numberOrStringOrBig\n     * @returns {Big}\n     */\n    static toBigNumber(numberOrStringOrBig) {\n        if (Utility.isNullOrUndefined(numberOrStringOrBig)) {\n            numberOrStringOrBig = 0;\n        }\n\n        if (numberOrStringOrBig instanceof Big) {\n            return numberOrStringOrBig;\n        } else if (Utility.isString(numberOrStringOrBig) || Utility.isNumber(numberOrStringOrBig)) {\n            return new Big(numberOrStringOrBig);\n        }\n\n        Preconditions.fail('Number|String|Big', numberOrStringOrBig, 'Unsupported type');\n    }\n\n    /**\n     *\n     * @param {Class|CoreObject|null|undefined} object\n     * @returns {Class|undefined}\n     */\n    static optClass(object) {\n        if (Utility.isInstance(object)) {\n            return Utility.getClass(object);\n        } else if (Utility.isClass(object)) {\n            return object;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Null-safe way to lowercase\n     * @param {String} string\n     * @returns {String}\n     */\n    static toLowerCase(string) {\n        if (Utility.isBlank(string)) {\n            return string;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return string.toLowerCase();\n    }\n\n    /**\n     * Null-safe way to uppercase.\n     *\n     * @param {String} string\n     * @returns {String}\n     */\n    static toUpperCase(string) {\n        if (Utility.isBlank(string)) {\n            return string;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return string.toUpperCase();\n    }\n\n    /**\n     *\n     * @param object\n     */\n    static optString(object) {\n        if (!Utility.isExisting(object)) {\n            return undefined;\n        } else {\n            if (Utility.isFunction(object.toString)) {\n                return object.toString();\n            } else {\n                return '' + object;\n            }\n        }\n    }\n\n    /**\n     * optJson(undefined) -> undefined\n     * optJson(null) -> undefined\n     * optJson(NaN) -> undefined\n     * optJson(primitive) -> primitive\n     * optJson(object) -> object.toJSON\n     * optJson(object) -> object.toJson\n     * optJson(object) -> object\n     *\n     * @param object\n     * @return {*}\n     */\n    static optJson(object) {\n        if (!Utility.isExisting(object)) {\n            return undefined;\n        } else if (Utility.isPrimitive(object)) {\n            return object;\n        } else if (Utility.isFunction(object.toJson)) {\n            return object.toJson();\n        } else if (Utility.isFunction(object.toJSON)) {\n            return object.toJSON();\n        } else {\n            return object;\n        }\n    }\n\n    /**\n     * Determines if the input is NotNull, NotNaN, and NotUndefined.\n     *\n     * @param {*} anything\n     * @return {boolean}\n     */\n    static isExisting(anything) {\n        let u = Utility.isUndefined(anything);\n        let n = Utility.isNaN(anything);\n        let nu = Utility.isNull(anything);\n\n        return !(u || n || nu);\n    }\n\n    /**\n     * The opposite of existing.\n     *\n     * @param {*} anything\n     * @returns {boolean}\n     */\n    static isNotExisting(anything) {\n        return !Utility.isExisting(anything);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isFalsey(object) {\n        return !object;\n    }\n\n    /**\n     *\n     * @param object\n     */\n    static isNotFalsey(object) {\n        return !Utility.isFalsey(object);\n    }\n\n    /**\n     * Shorthand for value\n     *\n     * @param value\n     * @returns {boolean}\n     */\n    static isNullOrUndefined(value) {\n        return Utility.isNull(value) || Utility.isUndefined(value);\n    }\n\n    /**\n     * A value is blank if it is empty or a whitespace string.\n     *\n     * ```javascript\n     * Ember.isBlank();                // true\n     * Ember.isBlank(null);            // true\n     * Ember.isBlank(undefined);       // true\n     * Ember.isBlank('');              // true\n     * Ember.isBlank([]);              // true\n     * Ember.isBlank('\\n\\t');          // true\n     * Ember.isBlank('  ');            // true\n     * Ember.isBlank({});              // false\n     * Ember.isBlank('\\n\\t Hello');    // false\n     * Ember.isBlank('Hello world');   // false\n     * Ember.isBlank([1,2,3]);         // false\n     * ```\n     * @param {String|Array|Number} stringOrArrayOrNumber\n     * @param {String|Array|Number} [stringOrArrayOrNumber.length]\n     * @return {boolean}\n     */\n    static isBlank(stringOrArrayOrNumber) {\n        if (!stringOrArrayOrNumber) {\n            return true;\n        }\n\n        if (Utility.isNotExisting(stringOrArrayOrNumber)) {\n            return true;\n        }\n\n        let type = Utility.typeOf(stringOrArrayOrNumber);\n        if ('number' === type) {\n            return (0 == stringOrArrayOrNumber);\n        }\n\n        if (!('array' === type || 'string' === type || 'number' === type)) {\n            Preconditions.fail('type|array', type, `isBlank does not support ${type}`);\n        }\n\n        return Ember.isBlank(stringOrArrayOrNumber);\n    }\n\n    /**\n     *\n     * @param {String} string\n     * @return {boolean}\n     */\n    static isNotBlank(string) {\n        return !Utility.isBlank(string);\n    }\n\n    /**\n     * @returns {Number}\n     */\n    static defaultNumber() {\n        let result = 0;\n\n        Lodash.each(arguments, function (object) {\n            if (Utility.isNumber(object)) {\n                result = object;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {String|Number} value\n     * @return {boolean}\n     */\n    static isNumeric(value) {\n        if (typeof value === 'number') return true;\n        var str = (value || '').toString();\n        if (!str) return false;\n        return !isNaN(str);\n    }\n\n    /**\n     *\n     * @param {*} value\n     * @returns {Number}\n     */\n    static toNumberOrFail(value) {\n        if (Utility.isNullOrUndefined(value)) {\n            return 0;\n        } else if (Utility.isNumber(value)) {\n            return value;\n        } else if (Utility.isString(value)) {\n            return Number.parseFloat(value);\n        } else if (value instanceof Big) {\n            // is this a risk?\n            return Number.parseFloat(value.toFixed());\n        }\n\n        throw new TypeError(\"unknown type: \" + Utility.typeOf(value));\n    }\n\n    /**\n     * @param {Number|String|Big|BigJsLibrary.BigJS|Instant|null|undefined|ZonedDateTime} numberOrStringOrBig\n     * @param {String|DateTimeFormatter} [optionalParserOrFormat]\n     *\n     * @return {Instant|undefined}\n     */\n    static optInstant(numberOrStringOrBig, optionalParserOrFormat) {\n        /**\n         * @type {ZonedDateTime}\n         */\n        let date = Utility.optDateTime(numberOrStringOrBig, optionalParserOrFormat);\n\n        if (!date) {\n            return undefined;\n        }\n\n        return date.toInstant();\n    }\n\n    /**\n     * @param {Number|String|Big|BigJsLibrary.BigJS|Instant|null|undefined} numberOrStringOrBig\n     * @param {String|DateTimeFormatter} [optionalParserOrFormat]\n     *\n     * @return {Date|undefined}\n     */\n    static optDate(numberOrStringOrBig, optionalParserOrFormat) {\n        let date = Utility.optDateTime(numberOrStringOrBig, optionalParserOrFormat);\n\n        if (!date) {\n            return undefined;\n        }\n\n        return convert(date);\n    }\n\n    /**\n     *\n     * @param {String|ZoneOffset|undefined} value\n     * @return {ZoneOffset}\n     */\n    static toTimeZoneOffset(value) {\n        if (Utility.isNotExisting(value)) {\n            return ZoneOffset.UTC;\n        } else if (Utility.isString(value)) {\n            return ZoneOffset.of(value);\n        } else if (value instanceof ZoneOffset) {\n            return value;\n        }\n\n        Errors.throwNotSure(value);\n    }\n\n    /**\n     * @param {Number|String|Big|BigJsLibrary.BigJS|Instant|null|undefined} numberOrStringOrBig\n     * @param {String|DateTimeFormatter|ZoneOffset} [optionalDateFormatStringOrDateFormatter]\n     *\n     * @return {ZonedDateTime|undefined}\n     */\n    static optDateTime(numberOrStringOrBig, optionalDateFormatStringOrDateFormatter) {\n        if (!numberOrStringOrBig) {\n            return Utility\n                .now()\n                .withZoneSameInstant(Utility.toTimeZoneOffset(optionalDateFormatStringOrDateFormatter));\n        }\n\n        if (Utility.isDate(numberOrStringOrBig)) {\n            return LocalDateTime\n                .from(nativeJs(numberOrStringOrBig))\n                .atZone(Utility.toTimeZoneOffset(optionalDateFormatStringOrDateFormatter));\n        }\n\n        if (Utility.isString(numberOrStringOrBig)) {\n            return ZonedDateTime\n                .parse(numberOrStringOrBig, Utility.toDateTimeFormatter(optionalDateFormatStringOrDateFormatter));\n        }\n\n        if (Utility.isTemporal(numberOrStringOrBig)) {\n            /** @type {ZoneOffset} */\n            let zone = numberOrStringOrBig.query(TemporalQueries.zone());\n\n            if (!zone) {\n                zone = Utility.toTimeZoneOffset(optionalDateFormatStringOrDateFormatter);\n            }\n\n            if (numberOrStringOrBig instanceof ZonedDateTime) {\n                return numberOrStringOrBig;\n            } else if (numberOrStringOrBig instanceof Instant) {\n                return ZonedDateTime.ofInstant(numberOrStringOrBig, zone);\n            }\n\n            /** @type {LocalTime} */\n            let localTime = numberOrStringOrBig.query(TemporalQueries.localTime());\n            /** @type {LocalDate} */\n            let localDate = numberOrStringOrBig.query(TemporalQueries.localDate());\n\n            if (!localTime) {\n                localTime = LocalTime.now(zone).toLocalTime();\n            }\n\n            if (!localDate) {\n                localDate = LocalDate.now(zone);\n            }\n\n            return localTime\n                .atDate(localDate)\n                .atZone(zone);\n        }\n    }\n\n\n    /**\n     *\n     * This is copied from https://js-joda.github.io/js-joda/esdoc/class/src/format/DateTimeFormatter.js~DateTimeFormatter.html\n     *\n     *  |Symbol  |Meaning                     |Presentation      |Examples\n     *  |--------|----------------------------|------------------|----------------------------------------------------\n     *  | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n     *  | y      | year                       | year             | 2004; 04\n     *  | D      | day-of-year                | number           | 189\n     *  | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n     *  | d      | day-of-month               | number           | 10\n     *  |        |                            |                  |\n     *  | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n     *  | Y      | week-based-year            | year             | 1996; 96\n     *  | w      | week-of-year               | number           | 27\n     *  | W      | week-of-month              | number           | 27\n     *  | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n     *  | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n     *  | F      | week-of-month              | number           | 3\n     *  |        |                            |                  |\n     *  | a      | am-pm-of-day               | text             | PM\n     *  | h      | clock-hour-of-am-pm (1-12) | number           | 12\n     *  | K      | hour-of-am-pm (0-11)       | number           | 0\n     *  | k      | clock-hour-of-am-pm (1-24) | number           | 0\n     *  |        |                            |                  |\n     *  | H      | hour-of-day (0-23)         | number           | 0\n     *  | m      | minute-of-hour             | number           | 30\n     *  | s      | second-of-minute           | number           | 55\n     *  | S      | fraction-of-second         | fraction         | 978\n     *  | A      | milli-of-day               | number           | 1234\n     *  | n      | nano-of-second             | number           | 987654321\n     *  | N      | nano-of-day                | number           | 1234000000\n     *  |        |                            |                  |\n     *  | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n     *  | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n     *  | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n     *  |        |                            |                  |\n     *  | p      | pad next                   | pad modifier     | 1\n     *  |        |                            |                  |\n     *  | '      | escape for text            | delimiter        |\n     *  | ''     | single quote               | literal          | '\n     *  | [      | optional section start     |                  |\n     *  | ]      | optional section end       |                  |\n     *  | {}     | reserved for future use    |                  |\n     *\n     * @param {String|DateTimeFormatter|null} [stringOrFormatter]\n     * @throws {TypeError} if not sure what to do.\n     * @return {DateTimeFormatter}\n     */\n    static toDateTimeFormatter(stringOrFormatter) {\n        if (Utility.isNotExisting(stringOrFormatter)) {\n            return DateTimeFormatter.ISO_ZONED_DATE_TIME;\n        } else if (Utility.isString(stringOrFormatter)) {\n            Preconditions.shouldNotBeBlank(stringOrFormatter);\n\n            return DateTimeFormatter.ofPattern(stringOrFormatter);\n        }\n\n        Errors.throwNotSure(stringOrFormatter);\n    }\n\n    /**\n     * Proxies to Utility.now() if you pass no arguments.\n     *\n     * This is copied from https://js-joda.github.io/js-joda/esdoc/class/src/format/DateTimeFormatter.js~DateTimeFormatter.html\n     *\n     *  |Symbol  |Meaning                     |Presentation      |Examples\n     *  |--------|----------------------------|------------------|----------------------------------------------------\n     *  | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n     *  | y      | year                       | year             | 2004; 04\n     *  | D      | day-of-year                | number           | 189\n     *  | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n     *  | d      | day-of-month               | number           | 10\n     *  |        |                            |                  |\n     *  | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n     *  | Y      | week-based-year            | year             | 1996; 96\n     *  | w      | week-of-year               | number           | 27\n     *  | W      | week-of-month              | number           | 27\n     *  | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n     *  | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n     *  | F      | week-of-month              | number           | 3\n     *  |        |                            |                  |\n     *  | a      | am-pm-of-day               | text             | PM\n     *  | h      | clock-hour-of-am-pm (1-12) | number           | 12\n     *  | K      | hour-of-am-pm (0-11)       | number           | 0\n     *  | k      | clock-hour-of-am-pm (1-24) | number           | 0\n     *  |        |                            |                  |\n     *  | H      | hour-of-day (0-23)         | number           | 0\n     *  | m      | minute-of-hour             | number           | 30\n     *  | s      | second-of-minute           | number           | 55\n     *  | S      | fraction-of-second         | fraction         | 978\n     *  | A      | milli-of-day               | number           | 1234\n     *  | n      | nano-of-second             | number           | 987654321\n     *  | N      | nano-of-day                | number           | 1234000000\n     *  |        |                            |                  |\n     *  | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n     *  | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n     *  | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n     *  |        |                            |                  |\n     *  | p      | pad next                   | pad modifier     | 1\n     *  |        |                            |                  |\n     *  | '      | escape for text            | delimiter        |\n     *  | ''     | single quote               | literal          | '\n     *  | [      | optional section start     |                  |\n     *  | ]      | optional section end       |                  |\n     *  | {}     | reserved for future use    |                  |\n     *\n     * @param {Temporal|LocalDateTime|ZonedDateTime|Number|String|Big|BigJsLibrary.BigJS|Instant|null|undefined} [value]\n     * @param {String|DateTimeFormatter} [optionalDateFormatStringOrDateFormatter]\n     * @return {ZonedDateTime}\n     */\n    static toDateTime(value, optionalDateFormatStringOrDateFormatter) {\n        if (Utility.isBlank(arguments.length)) {\n            return Utility.now();\n        }\n\n        let dateTime = Utility.optDateTime(value, optionalDateFormatStringOrDateFormatter);\n\n        if (dateTime) {\n            return dateTime;\n        }\n\n        Errors.throwNotSure(value);\n    }\n\n    /**\n     *\n     * @return {ZonedDateTime}\n     */\n    static now() {\n        return ZonedDateTime.now();\n    }\n\n    /**\n     * @param args\n     * @return value\n     */\n    static defaultValue(...args) {\n        let result = null;\n\n        Lodash.each(arguments, function (object) {\n            if (Utility.isDefined(object)) {\n                result = object;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * @returns {*|Object}\n     */\n    static defaultObject() {\n        let result = null;\n\n        Lodash.each(arguments, function (object) {\n            if (Utility.isObject(object)) {\n                result = object;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {Object} target\n     * @param {String|{}} propertyNameOrObject\n     * @param {*} [propertyValueOrUndefined]\n     * @returns {Object}\n     */\n    set(target, propertyNameOrObject, propertyValueOrUndefined) {\n        Preconditions.shouldBeObject(target);\n\n        if (Utility.isString(propertyNameOrObject)) {\n            let propertyName = propertyNameOrObject;\n            let propertyValue = propertyValueOrUndefined;\n\n            Preconditions.shouldBeString(propertyName);\n            Preconditions.shouldNotBeBlank(propertyName);\n            Preconditions.shouldBeDefined(propertyValue);\n\n            return Ember.set(target, propertyName, propertyValue);\n        } else if (Utility.isObject(propertyNameOrObject)) {\n            Preconditions.shouldBeUndefined(propertyValueOrUndefined);\n\n            Lodash.each(propertyNameOrObject, function (value, key) {\n                Utility.set(target, key, value);\n            });\n        }\n    }\n\n    /**\n     * Applies all of the defaults onto the first object.\n     *\n     * @param {Object} object\n     * @param {Object} defaults\n     * @returns {Object} The original object.\n     */\n    static defaults(object, defaults) {\n        Preconditions.shouldBeObject(object, 'target object must be object.');\n        Preconditions.shouldBeObject(defaults, 'defaults object must be object.');\n\n        let updates = Object.keys(defaults);\n\n        for (let i = 0, l = updates.length; i < l; i++) {\n            let prop = updates[i];\n            let value = Ember.get(defaults, prop);\n\n            Ember.set(object, prop, value);\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {String|Array} stringOrArray\n     * @param {String|Object} [defaults]\n     */\n    static get(object, stringOrArray, defaults) {\n        defaults = defaults || {};\n\n        let mode = Utility.isString(stringOrArray) ? 'single' : (Utility.isArray(stringOrArray) ? 'multiple' : 'error');\n\n        Preconditions.shouldBeTrue(mode != 'error', `I do not know what to do with ${stringOrArray}`);\n        Preconditions.shouldBeObject(object, 'target object must be object.');\n\n        if ('single' === mode) {\n            //noinspection UnnecessaryLocalVariableJS\n            let path = stringOrArray;\n\n            return Ember.getWithDefault(object, path, defaults);\n        } else if ('multiple' === mode) {\n            //noinspection UnnecessaryLocalVariableJS\n            let array = stringOrArray;\n            let result = Ember.getProperties(array);\n\n            if (Utility.isDefined(defaults)) {\n                return Utility.defaults(result, defaults);\n            } else {\n                return result;\n            }\n        }\n\n        throw new Error(`Not sure what to do here`);\n    }\n\n    /**\n     *\n     * @param {Class} clazz\n     * @return {String|undefined}\n     */\n    static optClassName(clazz) {\n        if (!clazz) {\n            return undefined;\n        }\n\n        if (Utility.isClass(clazz)) {\n            return clazz.toString() || clazz.constructor.name;\n        } else if (Utility.isInstance(clazz)) {\n            return Utility.optClassName(clazz.toClass());\n        }\n\n        Errors.throwNotSure(clazz);\n    }\n}\n\nexport default Utility;"]}