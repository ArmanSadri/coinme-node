{"version":3,"sources":["../../src/js/Utility.js"],"names":[],"mappings":"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","file":"Utility.js","sourcesContent":["'use strict';\n\nimport Lodash from \"lodash\";\nimport Preconditions from \"~/Preconditions\";\nimport Ember from \"~/ember\";\nimport CoreObject from '~/CoreObject';\n\n/**\n * @class\n * @singleton\n */\nclass Utility {\n\n    /**\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isObject(object) {\n        let type = Utility.typeOf(object);\n\n        return 'object' === type || 'instance' === type;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {Class}\n     */\n    static toClass(object) {\n        if (Utility.isClass(object)) {\n            return object;\n        } else if (Utility.isObject(object)) {\n            return object.toClass();\n        }\n\n        Preconditions.fail('object|class', Utility.typeOf(object), 'Must be correct type');\n    }\n\n    static isNumber(object) {\n        return 'number' === Utility.typeOf(object);\n    }\n\n    static isClass(object) {\n        return Utility.typeOf(object) === 'class';\n    }\n\n    static isInstance(object) {\n        return Utility.typeOf(object) === 'instance';\n    }\n    \n    static take(object, key) {\n        if (!object) {\n            return undefined;\n        }\n\n        let value = Lodash.get(object, key);\n\n        if (-1 != key.indexOf('.')) {\n            // It's an object path.\n            let parentPath = key.substring(0, key.lastIndexOf('.'));\n            let itemKey = key.substring(key.lastIndexOf('.') + 1);\n            let parent = Lodash.get(object, parentPath);\n\n            delete parent[itemKey];\n        } else {\n            delete object[key];\n        }\n\n        return value;\n    }\n\n    /**\n     * Creates a test method. Uses Utility.typeOf()\n     *\n     * @param {String} type\n     * @return {function}\n     */\n    static typeMatcher(type) {\n        // Ember.typeOf();                       // 'undefined'\n        // Ember.typeOf(null);                   // 'null'\n        // Ember.typeOf(undefined);              // 'undefined'\n        // Ember.typeOf('michael');              // 'string'\n        // Ember.typeOf(new String('michael'));  // 'string'\n        // Ember.typeOf(101);                    // 'number'\n        // Ember.typeOf(new Number(101));        // 'number'\n        // Ember.typeOf(true);                   // 'boolean'\n        // Ember.typeOf(new Boolean(true));      // 'boolean'\n        // Ember.typeOf(Ember.makeArray);        // 'function'\n        // Ember.typeOf([1, 2, 90]);             // 'array'\n        // Ember.typeOf(/abc/);                  // 'regexp'\n        // Ember.typeOf(new Date());             // 'date'\n        // Ember.typeOf(Ember.Object.extend());  // 'class'\n        // Ember.typeOf(Ember.Object.create());  // 'instance'\n        // Ember.typeOf(new Error('teamocil'));  // 'error'\n        // // 'normal' JavaScript object\n        // Ember.typeOf({ a: 'b' });             // 'object'\n\n        let knownTypes = {\n            'undefined': true,\n            'null': true,\n            'string': true,\n            'number': true,\n            'boolean': true,\n            'function': true,\n            'array': true,\n            'instance': true,\n            'error': true,\n            'object': true,\n            'class': true,\n            'regexp': true,\n            'date': true\n        };\n\n        /**\n         * Should be string.\n         */\n        {\n            let typeOfType = Utility.typeOf(type);\n\n            if ('string' !== typeOfType) {\n                Preconditions.fail('string', type, `The type passed in was not a string. It was ${typeOfType}`);\n            }\n        }\n\n        /**\n         * Should be known type.\n         */\n        {\n            // This will cause an infinite loop.\n            // Preconditions.shouldNotBeBlank(type, 'type missing');\n            // type = Utility.toLowerCase(type);\n            type = type.toLowerCase();\n\n            Preconditions.shouldBeTrue(knownTypes[type], 'unknown type: ' + type);\n        }\n\n        /**\n         * @param {*} object\n         */\n        return (function(object) {\n            let existingType = Utility.typeOf(object);\n\n            if ('object' === type || 'instance' === type) {\n                return ('object' === existingType) || ('instance' === existingType);\n            }\n\n            return type === existingType;\n        });\n    }\n\n    /**\n     * Returns a consistent type for the passed item.\n     *\n     * Use this instead of the built-in `typeof` to get the type of an item.\n     * It will return the same result across all browsers and includes a bit\n     * more detail. Here is what will be returned:\n     *\n     * | Return Value  | Meaning                                              |\n     * |---------------|------------------------------------------------------|\n     * | 'string'      | String primitive or String object.                   |\n     * | 'number'      | Number primitive or Number object.                   |\n     * | 'boolean'     | Boolean primitive or Boolean object.                 |\n     * | 'null'        | Null value                                           |\n     * | 'undefined'   | Undefined value                                      |\n     * | 'function'    | A function                                           |\n     * | 'array'       | An instance of Array                                 |\n     * | 'regexp'      | An instance of RegExp                                |\n     * | 'date'        | An instance of Date                                  |\n     * | 'class'       | An Ember class (created using Ember.Object.extend()) |\n     * | 'instance'    | An Ember object instance                             |\n     * | 'error'       | An instance of the Error object                      |\n     * | 'object'      | A JavaScript object not inheriting from Ember.Object |\n     *\n     * Examples:\n     *\n      ```javascript\n     Ember.typeOf();                       // 'undefined'\n     Ember.typeOf(null);                   // 'null'\n     Ember.typeOf(undefined);              // 'undefined'\n     Ember.typeOf('michael');              // 'string'\n     Ember.typeOf(new String('michael'));  // 'string'\n     Ember.typeOf(101);                    // 'number'\n     Ember.typeOf(new Number(101));        // 'number'\n     Ember.typeOf(true);                   // 'boolean'\n     Ember.typeOf(new Boolean(true));      // 'boolean'\n     Ember.typeOf(Ember.makeArray);        // 'function'\n     Ember.typeOf([1, 2, 90]);             // 'array'\n     Ember.typeOf(/abc/);                  // 'regexp'\n     Ember.typeOf(new Date());             // 'date'\n     Ember.typeOf(Ember.Object.extend());  // 'class'\n     Ember.typeOf(Ember.Object.create());  // 'instance'\n     Ember.typeOf(new Error('teamocil'));  // 'error'\n\n     // 'normal' JavaScript object\n     Ember.typeOf({ a: 'b' });             // 'object'\n     ```\n     *\n     * @method typeOf\n     * @for Ember\n     * @param {Object} object the item to check\n     * @return {String} the type\n     * @public\n     */\n    static typeOf(object) {\n        let type = Ember.typeOf(object);\n\n        if ('function' === type) {\n            // Let's isClass a bit further.\n\n            if (CoreObject.isClass(object)) {\n                return 'class';\n            }\n        } else if ('object' === type) {\n            if (CoreObject.isInstance(object)) {\n                return 'instance';\n            }\n        }\n\n        return type;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isBoolean(object) {\n        return 'boolean' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @return {boolean}\n     */\n    static isUndefined(object) {\n        return 'undefined' === Utility.typeOf(object);\n    }\n\n    /**\n     * Shorthand: Utility.typeOf() === string\n     *\n     * This is for functional programming.\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isString(object) {\n        return 'string' === Utility.typeOf(object);\n    }\n\n    static isFunction(fn) {\n        return 'function' === Utility.typeOf(fn);\n    }\n\n    static isNaN(object) {\n        return Lodash.isNaN(object);\n    }\n\n    /**\n     *\n     * @param {*} anything\n     * @returns {boolean}\n     */\n    static isNull(anything) {\n        return 'null' === Utility.typeOf(anything);\n    }\n\n    /**\n     * Null-safe way to lowercase\n     * @param {String} string\n     * @returns {String}\n     */\n    static toLowerCase(string) {\n        if (Utility.isBlank(string)) {\n            return string;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return string.toLowerCase();\n    }\n\n    /**\n     * Null-safe way to uppercase.\n     *\n     * @param {String} string\n     * @returns {String}\n     */\n    static toUpperCase(string) {\n        if (Utility.isBlank(string)) {\n            return string;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return string.toUpperCase();\n    }\n\n    /**\n     * Determines if the input is NotNull, NotNaN, and NotUndefined.\n     *\n     * @param {*} anything\n     * @return {boolean}\n     */\n    static isExisting(anything) {\n        let u = Utility.isUndefined(anything);\n        let n = Utility.isNaN(anything);\n        let nu = Utility.isNull(anything);\n\n        return !(u || n || nu);\n    }\n\n    /**\n     * The opposite of existing.\n     *\n     * @param {*} anything\n     * @returns {boolean}\n     */\n    static isNotExisting(anything) {\n        return !Utility.isExisting(anything);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isFalsey(object) {\n        return !object;\n    }\n\n    /**\n     *\n     * @param object\n     */\n    static isNotFalsey(object) {\n        return !Utility.isFalsey(object);\n    }\n\n    /**\n     * Shorthand for value\n     *\n     * @param value\n     * @returns {boolean}\n     */\n    static isNullOrUndefined(value) {\n        return Utility.isNull(value) || Utility.isUndefined(value);\n    }\n\n    /**\n     *\n     * @param {String} string\n     * @return {boolean}\n     */\n    static isBlank(string) {\n        if (Utility.isNullOrUndefined(string)) {\n            return true;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return Ember.isBlank(string);\n    }\n\n    /**\n     *\n     * @param {String} string\n     * @return {boolean}\n     */\n    static isNotBlank(string) {\n        return !Utility.isBlank(string);\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {Object} defaults\n     * @returns {Object} The original object.\n     */\n    static defaults(object, defaults) {\n        Preconditions.shouldBeObject(object);\n        Preconditions.shouldBeObject(defaults);\n\n        let updates = Object.keys(defaults);\n\n        for (let i = 0, l = updates.length; i < l; i++) {\n            let prop = updates[i];\n            let value = Ember.get(defaults, prop);\n\n            Ember.set(object, prop, value);\n        }\n\n        return object;\n    }\n}\n\nexport default Utility;"]}