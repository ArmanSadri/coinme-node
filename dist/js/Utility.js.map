{"version":3,"sources":["../../src/js/Utility.js"],"names":[],"mappings":"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","file":"Utility.js","sourcesContent":["'use strict';\n\nimport Lodash from \"lodash\";\nimport Preconditions from \"~/Preconditions\";\nimport Ember from \"~/ember\";\nimport CoreObject from \"~/CoreObject\";\nimport {Errors, AbstractError} from \"./errors\";\n\n/**\n * @class\n * @singleton\n */\nclass Utility {\n\n    /**\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isObject(object) {\n        let type = Utility.typeOf(object);\n\n        return 'object' === type || 'instance' === type;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {Class}\n     */\n    static toClass(object) {\n        if (Utility.isClass(object)) {\n            return object;\n        } else if (Utility.isObject(object)) {\n            return object.toClass();\n        }\n\n        Preconditions.fail('object|class', Utility.typeOf(object), 'Must be correct type');\n    }\n\n    static isNumber(object) {\n        return 'number' === Utility.typeOf(object);\n    }\n\n    static isClass(object) {\n        return 'class' === Utility.typeOf(object);\n    }\n\n    static isInstance(object) {\n        return 'instance' === Utility.typeOf(object);\n    }\n\n    static isError(object) {\n        return 'error' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} path\n     * @param {*} [defaultValue]\n     * @returns {*}\n     */\n    static result(object, path, defaultValue) {\n        return Lodash.get.apply(Lodash, arguments);\n    }\n\n    static emptyFn() {\n\n    }\n\n    static yes() {\n        return true;\n    }\n\n    static no() {\n        return false;\n    }\n\n    static ok() {\n        return this;\n    }\n\n    static identityFn() {\n        return this;\n    }\n\n    static passthroughFn(arg) {\n        return arg;\n    }\n\n    /**\n     * Uses Lodash.get, but then removes the key from the parent object.\n     *\n     * @param {Object} object\n     * @param {String|Object|Array} keyAsStringObjectArray\n     * @param {Function|Class} [optionalTypeDeclaration]\n     *\n     * @returns {*}\n     */\n    static take(object, keyAsStringObjectArray, optionalTypeDeclaration) {\n        if (!object) {\n            return undefined;\n        }\n\n        Preconditions.shouldBeDefined(keyAsStringObjectArray, 'key must be defined');\n\n        /**\n         *\n         * @param {Function|undefined} [validatorFn]\n         * @param {*} value\n         * @returns {*}\n         */\n        function executeValidator(validatorFn, value) {\n            if (validatorFn) {\n                Preconditions.shouldNotBeFalsey(validatorFn(value), 'Failed validation: ' + value);\n            }\n\n            return value;\n        }\n\n        if (Utility.isString(keyAsStringObjectArray)) {\n            /** @type {String} */\n            let key = keyAsStringObjectArray;\n            let value = Utility.result(object, key);\n            let validatorFn = Utility.yes;\n\n            if (Utility.isClass(optionalTypeDeclaration)) {\n                validatorFn = Utility.typeMatcher(optionalTypeDeclaration)\n            } else if (Utility.isFunction(optionalTypeDeclaration)) {\n                validatorFn = optionalTypeDeclaration;\n            } else if (Utility.isNullOrUndefined(keyAsStringObjectArray)) {\n                validatorFn = Utility.yes;\n            }\n\n            if (-1 != key.indexOf('.')) {\n                // It's an object path.\n                let parentPath = key.substring(0, key.lastIndexOf('.'));\n                let itemKey = key.substring(key.lastIndexOf('.') + 1);\n                let parent = Utility.result(object, parentPath);\n\n                delete parent[itemKey];\n            } else {\n                delete object[keyAsStringObjectArray];\n            }\n\n            return executeValidator(validatorFn, value);\n        } else if (Utility.isArray(keyAsStringObjectArray) || Utility.isObject(keyAsStringObjectArray)) {\n            let result = {};\n            let array_mode = Utility.isArray(keyAsStringObjectArray);\n\n            let defaults = Lodash.defaults(Utility.result(keyAsStringObjectArray, 'defaults') || {}, {\n                required: false,\n                validator: null\n            });\n\n            Lodash.forEach(keyAsStringObjectArray, function(/** @type {String|Object|Function} */rulesetOrObject, /** @type {String} */keyOrIndex) {\n                let key = keyOrIndex;\n                let ruleset = rulesetOrObject;\n\n                if (array_mode) {\n                    if (Utility.isString(rulesetOrObject)) {\n                        key = rulesetOrObject;\n                        ruleset = Lodash.assign({}, defaults);\n                    } else if (Utility.isObject(rulesetOrObject)) {\n                        key = Utility.result(rulesetOrObject, 'key');\n                        ruleset = rulesetOrObject;\n                    }\n                } else {\n                    key = keyOrIndex;\n                    ruleset = rulesetOrObject;\n                }\n\n                /** @type {String} */\n                let type = Utility.typeOf(ruleset);\n\n                if ('string' === type) {\n                    // The ruleset is a data type\n                    /** @type {String} */\n                    let requiredType = ruleset;\n\n                    ruleset = {\n                        key: key,\n                        type: requiredType,\n                        validator: null\n                    };\n                } else if ('object' === type) {\n                    // this is a ruleset that overrides our ruleset.\n                    ruleset = Lodash.defaults({ key: key }, ruleset);\n                } else if ('function' === type) {\n                    let fn = ruleset;\n                    \n                    ruleset = {\n                        key: key,\n                        validator: fn\n                    };\n                } else {\n                    throw new Error('Cannot determine what to do with: ' + type + ': ' + ruleset);\n                }\n\n                ruleset = Lodash.defaults(ruleset, defaults);\n\n                // If we don't have a validator yet, check to see if we can get one.\n                if (!ruleset.validator && Utility.isNotBlank(ruleset.type)) {\n                    if ('string' === ruleset.type) {\n                        ruleset.validator = Utility.isString;\n                    } else if ('number' === requiredType) {\n                        ruleset.validator = Utility.isNumber;\n                    } else if ('required' === requiredType) {\n                        ruleset.validator = Utility.isExisting;\n                    } else {\n                        throw new Error('I should add more types');\n                    }\n                }\n\n                if ('defaults' === key) {\n                    return;\n                }\n                \n                let entry = executeValidator(ruleset.validator, Utility.take(object, key));\n\n                if (ruleset.required && Utility.isUndefined(entry)) {\n                    throw new Error('Required key not present: ' + ruleset.key);\n                }\n\n                result[key] = entry;\n            });\n\n            return result;\n        } else {\n            throw new Error('Not sure how to handle this case: ' + Utility.typeOf(keyAsStringObjectArray));\n        }\n    }\n\n    /**\n     * Creates a test method. Uses Utility.typeOf()\n     *\n     * @param {String|Class} type\n     * @return {function}\n     */\n    static typeMatcher(type) {\n        // Ember.typeOf();                       // 'undefined'\n        // Ember.typeOf(null);                   // 'null'\n        // Ember.typeOf(undefined);              // 'undefined'\n        // Ember.typeOf('michael');              // 'string'\n        // Ember.typeOf(new String('michael'));  // 'string'\n        // Ember.typeOf(101);                    // 'number'\n        // Ember.typeOf(new Number(101));        // 'number'\n        // Ember.typeOf(true);                   // 'boolean'\n        // Ember.typeOf(new Boolean(true));      // 'boolean'\n        // Ember.typeOf(Ember.makeArray);        // 'function'\n        // Ember.typeOf([1, 2, 90]);             // 'array'\n        // Ember.typeOf(/abc/);                  // 'regexp'\n        // Ember.typeOf(new Date());             // 'date'\n        // Ember.typeOf(Ember.Object.extend());  // 'class'\n        // Ember.typeOf(Ember.Object.create());  // 'instance'\n        // Ember.typeOf(new Error('teamocil'));  // 'error'\n        // // 'normal' JavaScript object\n        // Ember.typeOf({ a: 'b' });             // 'object'\n\n        let knownTypes = {\n            'undefined': true,\n            'null': true,\n            'string': true,\n            'number': true,\n            'boolean': true,\n            'function': true,\n            'array': true,\n            'instance': true,\n            'error': true,\n            'object': true,\n            'class': true,\n            'regexp': true,\n            'date': true\n        };\n\n        /**\n         * Should be string.\n         */\n        {\n            let typeOfType = Utility.typeOf(type);\n\n            if (!('string' === typeOfType || 'class' === typeOfType)) {\n                Preconditions.fail('string', type, `The type passed in was not a string|class. It was ${typeOfType}`);\n            }\n        }\n\n        /**\n         * Should be known type.\n         */\n        {\n            // This will cause an infinite loop.\n            // Preconditions.shouldNotBeBlank(type, 'type missing');\n            // type = Utility.toLowerCase(type);\n            if (Utility.isString(type)) {\n                type = type.toLowerCase();\n\n                Preconditions.shouldBeTrue(knownTypes[type], 'unknown type: ' + type);\n\n                return (function(/** @type {*} */ object) {\n                    let objectType = Utility.typeOf(object);\n\n                    if ('object' === type || 'instance' === type) {\n                        return ('object' === objectType) || ('instance' === objectType);\n                    }\n\n                    return type === objectType;\n                });\n            } else if (Utility.isClass(type)) {\n                /**\n                 * @type {Class<CoreObject>}\n                 */\n                return function(/** @type {*} */object) {\n                    return (type.isInstance(object));\n                };\n            }\n        }\n\n\n    }\n\n    /**\n     * Returns a consistent type for the passed item.\n     *\n     * Use this instead of the built-in `typeof` to get the type of an item.\n     * It will return the same result across all browsers and includes a bit\n     * more detail. Here is what will be returned:\n     *\n     * | Return Value  | Meaning                                              |\n     * |---------------|------------------------------------------------------|\n     * | 'string'      | String primitive or String object.                   |\n     * | 'number'      | Number primitive or Number object.                   |\n     * | 'boolean'     | Boolean primitive or Boolean object.                 |\n     * | 'null'        | Null value                                           |\n     * | 'undefined'   | Undefined value                                      |\n     * | 'function'    | A function                                           |\n     * | 'array'       | An instance of Array                                 |\n     * | 'regexp'      | An instance of RegExp                                |\n     * | 'date'        | An instance of Date                                  |\n     * | 'class'       | An Ember class (created using Ember.Object.extend()) |\n     * | 'instance'    | An Ember object instance                             |\n     * | 'error'       | An instance of the Error object                      |\n     * | 'object'      | A JavaScript object not inheriting from Ember.Object |\n     *\n     * Examples:\n     *\n     ```javascript\n     Ember.typeOf();                       // 'undefined'\n     Ember.typeOf(null);                   // 'null'\n     Ember.typeOf(undefined);              // 'undefined'\n     Ember.typeOf('michael');              // 'string'\n     Ember.typeOf(new String('michael'));  // 'string'\n     Ember.typeOf(101);                    // 'number'\n     Ember.typeOf(new Number(101));        // 'number'\n     Ember.typeOf(true);                   // 'boolean'\n     Ember.typeOf(new Boolean(true));      // 'boolean'\n     Ember.typeOf(Ember.makeArray);        // 'function'\n     Ember.typeOf([1, 2, 90]);             // 'array'\n     Ember.typeOf(/abc/);                  // 'regexp'\n     Ember.typeOf(new Date());             // 'date'\n     Ember.typeOf(Ember.Object.extend());  // 'class'\n     Ember.typeOf(Ember.Object.create());  // 'instance'\n     Ember.typeOf(new Error('teamocil'));  // 'error'\n\n     // 'normal' JavaScript object\n     Ember.typeOf({ a: 'b' });             // 'object'\n     ```\n     *\n     * @method typeOf\n     * @for Ember\n     * @param {Object} object the item to check\n     * @return {String} the type\n     * @public\n     */\n    static typeOf(object) {\n        let type = Ember.typeOf(object);\n\n        if ('function' === type) {\n            // Let's isClass a bit further.\n\n            if (CoreObject.isClass(object) || Errors.isErrorClass(object)) {\n                return 'class';\n            } else if (Errors.isErrorInstance(object)) {\n                return 'error';\n            }\n\n        } else if ('object' === type) {\n            if (CoreObject.isInstance(object)) {\n                return 'instance';\n            }\n        }\n\n        return type;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isArray(object) {\n        return 'array' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isBoolean(object) {\n        return 'boolean' === Utility.typeOf(object);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @return {boolean}\n     */\n    static isUndefined(object) {\n        return 'undefined' === Utility.typeOf(object);\n    }\n\n    /**\n     * Shorthand: Utility.typeOf() === string\n     *\n     * This is for functional programming.\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isString(object) {\n        return 'string' === Utility.typeOf(object);\n    }\n\n    static isFunction(fn) {\n        return 'function' === Utility.typeOf(fn);\n    }\n\n    static isNaN(object) {\n        return Lodash.isNaN(object);\n    }\n\n    /**\n     *\n     * @param {*} anything\n     * @returns {boolean}\n     */\n    static isNull(anything) {\n        return 'null' === Utility.typeOf(anything);\n    }\n\n    /**\n     * Null-safe way to lowercase\n     * @param {String} string\n     * @returns {String}\n     */\n    static toLowerCase(string) {\n        if (Utility.isBlank(string)) {\n            return string;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return string.toLowerCase();\n    }\n\n    /**\n     * Null-safe way to uppercase.\n     *\n     * @param {String} string\n     * @returns {String}\n     */\n    static toUpperCase(string) {\n        if (Utility.isBlank(string)) {\n            return string;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return string.toUpperCase();\n    }\n\n    /**\n     * Determines if the input is NotNull, NotNaN, and NotUndefined.\n     *\n     * @param {*} anything\n     * @return {boolean}\n     */\n    static isExisting(anything) {\n        let u = Utility.isUndefined(anything);\n        let n = Utility.isNaN(anything);\n        let nu = Utility.isNull(anything);\n\n        return !(u || n || nu);\n    }\n\n    /**\n     * The opposite of existing.\n     *\n     * @param {*} anything\n     * @returns {boolean}\n     */\n    static isNotExisting(anything) {\n        return !Utility.isExisting(anything);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @returns {boolean}\n     */\n    static isFalsey(object) {\n        return !object;\n    }\n\n    /**\n     *\n     * @param object\n     */\n    static isNotFalsey(object) {\n        return !Utility.isFalsey(object);\n    }\n\n    /**\n     * Shorthand for value\n     *\n     * @param value\n     * @returns {boolean}\n     */\n    static isNullOrUndefined(value) {\n        return Utility.isNull(value) || Utility.isUndefined(value);\n    }\n\n    /**\n     *\n     * @param {String} string\n     * @return {boolean}\n     */\n    static isBlank(string) {\n        if (Utility.isNullOrUndefined(string)) {\n            return true;\n        }\n\n        Preconditions.shouldBeString(string);\n\n        return Ember.isBlank(string);\n    }\n\n    /**\n     *\n     * @param {String} string\n     * @return {boolean}\n     */\n    static isNotBlank(string) {\n        return !Utility.isBlank(string);\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {Object} defaults\n     * @returns {Object} The original object.\n     */\n    static defaults(object, defaults) {\n        Preconditions.shouldBeObject(object);\n        Preconditions.shouldBeObject(defaults);\n\n        let updates = Object.keys(defaults);\n\n        for (let i = 0, l = updates.length; i < l; i++) {\n            let prop = updates[i];\n            let value = Ember.get(defaults, prop);\n\n            Ember.set(object, prop, value);\n        }\n\n        return object;\n    }\n}\n\nexport default Utility;"]}