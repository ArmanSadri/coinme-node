{"version":3,"sources":["../../src/js/Stopwatch.js"],"names":[],"mappings":"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","file":"Stopwatch.js","sourcesContent":["'use strict';\n\nimport Utility from \"./Utility\";\nimport TimeUnit from \"./TimeUnit\";\nimport CoreObject from './CoreObject';\n\nconst MICROSECONDS = TimeUnit.MICROSECONDS;\nconst NANOSECONDS = TimeUnit.NANOSECONDS;\n\n/**\n *\n * @type {Ticker}\n */\nvar SYSTEM_TICKER = null;\n\nclass Ticker {\n\n    /**\n     * Constructor for use by subclasses.\n     */\n    constructor(options) {\n\n    }\n\n    /**\n     * Returns the number of nanoseconds elapsed since this ticker's fixed\n     * point of reference.\n     */\n    read() {\n        let time = process.hrtime();\n        let timeInSeconds = time[0];\n        let timeInNanos = time[1];\n\n        return TimeUnit.SECONDS.toNanos(timeInSeconds) + timeInNanos;\n    }\n\n    /**\n     * A ticker that reads the current time using {@link System#nanoTime}.\n     *\n     * @return {Ticker}\n     */\n    static systemTicker() {\n        return SYSTEM_TICKER;\n    }\n}\n\nSYSTEM_TICKER = new Ticker();\n\nclass Stopwatch extends CoreObject {\n\n    /**\n     *\n     * @param {Object} options\n     * @param {Ticker} [options.ticker]\n     * @param {boolean} [options.start]\n     */\n    constructor(options) {\n        super();\n\n        this._ticker = Utility.take(options, 'ticker') || SYSTEM_TICKER;\n        this._isRunning = Utility.take(options, 'start');\n        this._elapsedNanos;\n        this._startTick;\n\n        if (this.isRunning) {\n            this.start();\n        }\n    }\n\n    /**\n     *\n     * @returns {Number}\n     */\n    get startTick() {\n        return this._startTick;\n    }\n\n    /**\n     * @returns {Ticker}\n     */\n    get ticker() {\n        return this._ticker;\n    }\n\n    /**\n     * Returns {@code true} if {@link #start()} has been called on this stopwatch,\n     * and {@link #stop()} has not been called since the last call to {@code\n     * start()}.\n     */\n    get isRunning() {\n        return this._isRunning;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * @return {Stopwatch}\n     */\n    start() {\n        Utility.shouldBeFalsey(this.isRunning, \"This stopwatch is already running.\");\n\n        this._isRunning = true;\n        this._startTick = this.ticker.read();\n\n        return this;\n    }\n\n    /**\n     * Stops the stopwatch. Future reads will return the fixed duration that had\n     * elapsed up to this point.\n     *\n     * @return {Stopwatch} instance\n     * @throws IllegalStateException if the stopwatch is already stopped.\n     */\n    stop() {\n        Utility.shouldBeTrue(this.isRunning, \"This stopwatch is already stopped.\");\n\n        this._isRunning = false;\n        this._elapsedNanos += this.ticker.read() - this._startTick;\n\n        return this;\n    }\n\n    /**\n     * Sets the elapsed time for this stopwatch to zero,\n     * and places it in a stopped state.\n     *\n     * @return {Stopwatch} instance\n     */\n    reset() {\n        this._elapsedNanos = 0;\n        this._isRunning = false;\n\n        return this;\n    }\n\n    /**\n     * @returns {Number}\n     */\n    elapsedNanos() {\n        return this.isRunning ? this.ticker.read() - this._startTick + this.elapsedNanos : this.elapsedNanos;\n    }\n\n    /**\n     * @returns {Number}\n     */\n    elapsedMicros() {\n        return this.elapsed(MICROSECONDS);\n    }\n\n    /**\n     * Returns the current elapsed time shown on this stopwatch, expressed\n     * in the desired time unit, with any fraction rounded down.\n     *\n     * <p>Note that the overhead of measurement can be more than a microsecond, so\n     * it is generally not useful to specify {@link TimeUnit#NANOSECONDS}\n     * precision here.\n     *\n     * @param {TimeUnit} [timeUnit]\n     * @return {Number}\n     */\n    elapsed(timeUnit) {\n        if (!timeUnit) {\n            timeUnit = NANOSECONDS;\n        }\n\n        return timeUnit.convert(this.elapsedNanos(), TimeUnit.NANOSECONDS);\n    }\n\n    /**\n     * Returns a string representation of the current elapsed time.\n     */\n    toString() {\n        let nanos = this.elapsedNanos();\n        let unit = this.chooseUnit(nanos);\n\n        let value = nanos / TimeUnit.NANOSECONDS.convert(1, unit);\n\n        // Too bad this functionality is not exposed as a regular method call\n        return `${value} ${unit.shortName}`;\n    }\n\n    /**\n     * @private\n     * @param {Number} nanos\n     * @return {TimeUnit}\n     */\n    static chooseUnit(nanos) {\n        if (TimeUnit.DAYS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.DAYS;\n        }\n\n        if (TimeUnit.HOURS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.HOURS;\n        }\n\n        if (TimeUnit.MINUTES.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MINUTES;\n        }\n\n        if (TimeUnit.SECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.SECONDS;\n        }\n\n        if (TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MILLISECONDS;\n        }\n\n        if (TimeUnit.MICROSECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MICROSECONDS;\n        }\n\n        return TimeUnit.NANOSECONDS;\n    }\n}\n\nexport {Ticker};\nexport {Stopwatch};\nexport default Stopwatch;"]}