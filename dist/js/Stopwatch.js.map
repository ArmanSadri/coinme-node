{"version":3,"sources":["../../src/js/Stopwatch.js"],"names":[],"mappings":"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","file":"Stopwatch.js","sourcesContent":["'use strict';\n\nimport Utility from \"./Utility\";\nimport TimeUnit from \"./TimeUnit\";\nimport CoreObject from './CoreObject';\nimport Logger from \"winston\";\nimport Preconditions from \"./Preconditions\";\n\nconst MILLISECONDS = TimeUnit.MILLISECONDS;\nconst MICROSECONDS = TimeUnit.MICROSECONDS;\nconst NANOSECONDS = TimeUnit.NANOSECONDS;\n\n/**\n *\n * @type {Ticker}\n */\nvar SYSTEM_TICKER = null;\n\nclass Ticker {\n\n    /**\n     * Constructor for use by subclasses.\n     */\n    constructor(options) {\n\n    }\n\n    /**\n     * Returns the number of nanoseconds elapsed since this ticker's fixed\n     * point of reference.\n     *\n     * @return {Number} nanoseconds\n     */\n    read() {\n        let time = process.hrtime();\n        let timeInSeconds = time[0];\n        let timeInNanos = time[1];\n\n        return TimeUnit.SECONDS.toNanos(timeInSeconds) + timeInNanos;\n    }\n\n    /**\n     * A ticker that reads the current time using {@link System#nanoTime}.\n     *\n     * @return {Ticker}\n     */\n    static systemTicker() {\n        return SYSTEM_TICKER;\n    }\n}\n\nSYSTEM_TICKER = new Ticker();\n\nclass Stopwatch extends CoreObject {\n\n    /**\n     *\n     * @param {Object} [options]\n     * @param {Ticker} [options.ticker]\n     * @param {boolean} [options.start]\n     */\n    constructor(options) {\n        super(...arguments);\n\n        // options = options || {};\n\n        this._ticker = Utility.take(options, 'ticker') || SYSTEM_TICKER;\n\n        let shouldStart = Utility.take(options, 'start', {\n            defaultValue: true\n        });\n\n        /**\n         * @type {Number} nanoseconds\n         * @private\n         */\n        this._startTick = this.ticker.read();\n\n        if (shouldStart) {\n            this.start();\n        }\n    }\n\n    /**\n     *\n     * @returns {Number}\n     */\n    get startTick() {\n        return this._startTick;\n    }\n\n    /**\n     * @returns {Ticker}\n     */\n    get ticker() {\n        return this._ticker;\n    }\n\n    /**\n     * Returns {@code true} if {@link #start()} has been called on this stopwatch,\n     * and {@link #stop()} has not been called since the last call to {@code\n     * start()}.\n     */\n    get running() {\n        return this._running;\n    }\n\n    get finalized() {\n        return this._finalized;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * @return {Stopwatch}\n     */\n    start() {\n        Preconditions.shouldBeFalsey(this.running, \"This stopwatch is already running.\");\n        Preconditions.shouldBeFalsey(this.finalized, \"This stopwatch cannot be started, stopped, or reset.\");\n\n        this.reset();\n\n        this._running = true;\n        this._startTick = this.ticker.read();\n\n        return this;\n    }\n\n    /**\n     * Stops the stopwatch. Future reads will return the fixed duration that had\n     * elapsed up to this point.\n     *\n     * @param {Object} [options]\n     * @param {Boolean} [options.finalize]\n     * @return {Stopwatch} instance\n     * @throws IllegalStateException if the stopwatch is already stopped.\n     */\n    stop(options) {\n        Preconditions.shouldBeFalsey(this.finalized, \"This stopwatch cannot be started, stopped, or reset.\");\n        Preconditions.shouldBeTrue(this.running, \"This stopwatch is already stopped.\");\n\n        this._running = false;\n        this._elapsedNanos += this.ticker.read() - this._startTick;\n        this._finalized = Utility.take(options, 'finalized', {\n            type: 'boolean',\n            defaultValue: false,\n            required: false\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets the elapsed time for this stopwatch to zero,\n     * and places it in a stopped state.\n     *\n     * @return {Stopwatch} instance\n     */\n    reset() {\n        Preconditions.shouldBeFalsey(this.finalized, \"This stopwatch cannot be started, stopped, or reset.\");\n\n        if (this.running) {\n            this.stop();\n        }\n\n        this._elapsedNanos = 0;\n        this._startTick = null;\n        this._running = false;\n\n        return this;\n    }\n\n    /**\n     * @returns {Number}\n     */\n    elapsedNanos() {\n        return this.running ? this.ticker.read() - this._startTick + this._elapsedNanos : this._elapsedNanos;\n    }\n\n    elapsedMillis() {\n        return this.elapsed(MILLISECONDS);\n    }\n\n    /**\n     * @returns {Number}\n     */\n    elapsedMicros() {\n        return this.elapsed(MICROSECONDS);\n    }\n\n    /**\n     * Returns the current elapsed time shown on this stopwatch, expressed\n     * in the desired time unit, with any fraction rounded down.\n     *\n     * <p>Note that the overhead of measurement can be more than a microsecond, so\n     * it is generally not useful to specify {@link TimeUnit#NANOSECONDS}\n     * precision here.\n     *\n     * @param {TimeUnit} [timeUnit]\n     * @return {Number}\n     */\n    elapsed(timeUnit) {\n        if (!timeUnit) {\n            timeUnit = MILLISECONDS;\n        }\n\n        return timeUnit.convert(this.elapsedNanos(), timeUnit);\n    }\n\n    /**\n     * Returns a string representation of the current elapsed time.\n     */\n    toString() {\n        let nanos = this.elapsedNanos();\n        let unit = this.chooseUnit(nanos);\n\n        let value = nanos / TimeUnit.NANOSECONDS.convert(1, unit);\n\n        // Too bad this functionality is not exposed as a regular method call\n        return `${value} ${unit.shortName}`;\n    }\n\n    /**\n     * @private\n     * @param {Number} nanos\n     * @return {TimeUnit}\n     */\n    static chooseUnit(nanos) {\n        if (TimeUnit.DAYS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.DAYS;\n        }\n\n        if (TimeUnit.HOURS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.HOURS;\n        }\n\n        if (TimeUnit.MINUTES.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MINUTES;\n        }\n\n        if (TimeUnit.SECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.SECONDS;\n        }\n\n        if (TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MILLISECONDS;\n        }\n\n        if (TimeUnit.MICROSECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MICROSECONDS;\n        }\n\n        return TimeUnit.NANOSECONDS;\n    }\n\n}\n\nexport {Ticker};\nexport {Stopwatch};\nexport default Stopwatch;"]}