{"version":3,"sources":["../../src/js/Stopwatch.js"],"names":["MILLISECONDS","MICROSECONDS","NANOSECONDS","SYSTEM_TICKER","systemTicker","Stopwatch","options","shouldStart","take","defaultValue","ticker","arguments","_ticker","_startTick","read","start","shouldBeFalsey","running","finalized","reset","_running","shouldBeTrue","_elapsedNanos","_finalized","type","required","stop","elapsed","timeUnit","convert","elapsedNanos","nanos","unit","chooseUnit","value","shortName","DAYS","HOURS","MINUTES","SECONDS","Ticker"],"mappings":"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","file":"Stopwatch.js","sourcesContent":["'use strict';\n\nimport Utility from \"./Utility\";\nimport TimeUnit from \"./TimeUnit\";\nimport CoreObject from './CoreObject';\nimport Logger from \"winston\";\nimport Preconditions from \"./Preconditions\";\nimport Ticker from './Ticker';\nimport NanoTimer from 'nanotimer';\n\nconst MILLISECONDS = TimeUnit.MILLISECONDS;\nconst MICROSECONDS = TimeUnit.MICROSECONDS;\nconst NANOSECONDS = TimeUnit.NANOSECONDS;\n\n/**\n *\n * @type {Ticker}\n */\nlet SYSTEM_TICKER = Ticker.systemTicker();\n\nclass Stopwatch extends CoreObject {\n\n    /**\n     *\n     * @param {Object} [options]\n     * @param {Ticker} [options.ticker]\n     * @param {boolean} [options.start]\n     */\n    constructor(options) {\n        let shouldStart = Utility.take(options, 'start', {\n            defaultValue: true\n        });\n\n        let ticker = Utility.take(options, 'ticker') || SYSTEM_TICKER;\n\n        super(...arguments);\n\n        // options = options || {};\n\n        this._ticker = ticker;\n\n        /**\n         * @type {Number} nanoseconds\n         * @private\n         */\n        this._startTick = this.ticker.read();\n\n        if (shouldStart) {\n            this.start();\n        }\n    }\n\n    /**\n     *\n     * @returns {Number}\n     */\n    get startTick() {\n        return this._startTick;\n    }\n\n    /**\n     * @returns {Ticker}\n     */\n    get ticker() {\n        return this._ticker;\n    }\n\n    /**\n     * Returns {@code true} if {@link #start()} has been called on this stopwatch,\n     * and {@link #stop()} has not been called since the last call to {@code\n     * start()}.\n     */\n    get running() {\n        return this._running;\n    }\n\n    get finalized() {\n        return this._finalized;\n    }\n\n    /**\n     * Starts the stopwatch.\n     *\n     * @return {Stopwatch}\n     */\n    start() {\n        Preconditions.shouldBeFalsey(this.running, \"This stopwatch is already running.\");\n        Preconditions.shouldBeFalsey(this.finalized, \"This stopwatch cannot be started, stopped, or reset.\");\n\n        this.reset();\n\n        this._running = true;\n        this._startTick = this.ticker.read();\n\n        return this;\n    }\n\n    /**\n     * Stops the stopwatch. Future reads will return the fixed duration that had\n     * elapsed up to this point.\n     *\n     * @param {Object} [options]\n     * @param {Boolean} [options.finalize]\n     * @return {Stopwatch} instance\n     * @throws IllegalStateException if the stopwatch is already stopped.\n     */\n    stop(options) {\n        Preconditions.shouldBeFalsey(this.finalized, \"This stopwatch cannot be started, stopped, or reset.\");\n        Preconditions.shouldBeTrue(this.running, \"This stopwatch is already stopped.\");\n\n        this._running = false;\n        this._elapsedNanos += this.ticker.read() - this._startTick;\n        this._finalized = Utility.take(options, 'finalized', {\n            type: 'boolean',\n            defaultValue: false,\n            required: false\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets the elapsed time for this stopwatch to zero,\n     * and places it in a stopped state.\n     *\n     * @return {Stopwatch} instance\n     */\n    reset() {\n        Preconditions.shouldBeFalsey(this.finalized, \"This stopwatch cannot be started, stopped, or reset.\");\n\n        if (this.running) {\n            this.stop();\n        }\n\n        this._elapsedNanos = 0;\n        this._startTick = null;\n        this._running = false;\n\n        return this;\n    }\n\n    /**\n     * @returns {Number}\n     */\n    elapsedNanos() {\n        return this.running ? this.ticker.read() - this._startTick + this._elapsedNanos : this._elapsedNanos;\n    }\n\n    elapsedMillis() {\n        return this.elapsed(MILLISECONDS);\n    }\n\n    /**\n     * @returns {Number}\n     */\n    elapsedMicros() {\n        return this.elapsed(MICROSECONDS);\n    }\n\n    /**\n     * Returns the current elapsed time shown on this stopwatch, expressed\n     * in the desired time unit, with any fraction rounded down.\n     *\n     * <p>Note that the overhead of measurement can be more than a microsecond, so\n     * it is generally not useful to specify {@link TimeUnit#NANOSECONDS}\n     * precision here.\n     *\n     * @param {TimeUnit} [timeUnit]\n     * @return {Number}\n     */\n    elapsed(timeUnit) {\n        if (!timeUnit) {\n            timeUnit = MILLISECONDS;\n        }\n\n        return timeUnit.convert(this.elapsedNanos(), timeUnit);\n    }\n\n    /**\n     * Returns a string representation of the current elapsed time.\n     */\n    toString() {\n        let nanos = this.elapsedNanos();\n        let unit = this.chooseUnit(nanos);\n\n        let value = nanos / TimeUnit.NANOSECONDS.convert(1, unit);\n\n        // Too bad this functionality is not exposed as a regular method call\n        return `${value} ${unit.shortName}`;\n    }\n\n    /**\n     * @private\n     * @param {Number} nanos\n     * @return {TimeUnit}\n     */\n    static chooseUnit(nanos) {\n        if (TimeUnit.DAYS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.DAYS;\n        }\n\n        if (TimeUnit.HOURS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.HOURS;\n        }\n\n        if (TimeUnit.MINUTES.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MINUTES;\n        }\n\n        if (TimeUnit.SECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.SECONDS;\n        }\n\n        if (TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MILLISECONDS;\n        }\n\n        if (TimeUnit.MICROSECONDS.convert(nanos, TimeUnit.NANOSECONDS) > 0) {\n            return TimeUnit.MICROSECONDS;\n        }\n\n        return TimeUnit.NANOSECONDS;\n    }\n\n}\n\nexport {Ticker};\nexport {Stopwatch};\nexport default Stopwatch;"]}