{"version":3,"sources":["../../../src/js/data/DelegatedConverter.js"],"names":[],"mappings":"AAAA;;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;IAQM,iB;;;;;;;;;;;;;;;;;iCAMO,e,EAAiB;AACtB,mBAAO,qBAAW,iBAAX,CAA6B,eAA7B,CAAP;AACH;;;;;;;;;8BAMK,Q,EAAU;AACZ,iBAAK,aAAL,CAAmB,QAAnB;;AAEA,mBAAO,SAAS,OAAT,EAAP;AACH;;;;;;;;;;;;;;;;;;;;;IAgBC,kB;;;;;;;;;;AAQF,gCAAY,OAAZ,EAAqB;AAAA;;AACjB,YAAI,UAAU,kBAAQ,IAAR,CAAa,OAAb,EAAsB,SAAtB,EAAiC;AAC3C,mCAD2C;AAE3C,0BAAc,IAAI,iBAAJ;AAF6B,SAAjC,CAAd;;AAKA,YAAI,cAAc,kBAAQ,IAAR,CAAa,OAAb,EAAsB,aAAtB,EAAqC,IAArC,CAAlB;;;;;;;AANiB,4GAQR,SARQ;;AAcjB,eAAK,YAAL,GAAoB,eAAe,EAAnC;;;;;AAKA,eAAK,QAAL,GAAgB,OAAhB;AAnBiB;AAoBpB;;;;;;;;;;;;;;;;;;;;iCAkBQ,Q,EAAU,K,EAAO;AACtB,gBAAI,UAAU,KAAK,OAAnB;;AAEA,gBAAI,CAAC,QAAQ,QAAR,CAAiB,QAAjB,CAAD,IAA+B,CAAC,QAAQ,QAAR,CAAiB,KAAjB,CAApC,EAA6D;AACzD,uBAAO,KAAP;AACH;;AAED,gBAAI,KAAK,KAAK,aAAL,CAAmB,QAAnB,EAA6B,KAA7B,CAAT;;AAEA,mBAAO,kBAAQ,UAAR,CAAmB,EAAnB,CAAP;AACH;;;;;;;;;;;;;;;;gCAaO,K,EAAO,W,EAAa;AACxB,gBAAI,KAAK,KAAK,aAAL,CAAmB,KAAnB,EAA0B,WAA1B,CAAT;;AAEA,mBAAO,GAAG,IAAH,CAAQ,IAAR,EAAc,KAAd,EAAqB,WAArB,CAAP;AACH;;;;;;;;;;;;;sCAUa,K,EAAO,M,EAAQ;;;;AAIzB,gBAAI,iBAAiB,KAAK,iBAAL,CAAuB,KAAvB,EAA8B,MAA9B,CAArB;;AAEA,mBAAO,wBAAc,gBAAd,CACH,KAAK,YAAL,CAAkB,cAAlB,CADG,+BAEwB,cAFxB,CAAP;AAGH;;;;;;;;;;;sCAQa,K,EAAO,M,EAAQ;AACzB,gBAAI,iBAAiB,KAAK,iBAAL,CAAuB,KAAvB,EAA8B,MAA9B,CAArB;;AAEA,mBAAO,KAAK,YAAL,CAAkB,cAAlB,CAAP;AACH;;;;;;;;;;;;0CASiB,K,EAAO,M,EAAQ;AAC7B,oCAAc,eAAd,CAA8B,KAA9B,EAAqC,aAArC;AACA,oCAAc,eAAd,CAA8B,MAA9B,EAAsC,cAAtC;;AAEA,gBAAI,UAAU,KAAK,OAAnB;;AAEA,oBAAQ,wBAAc,aAAd,CAA4B,QAAQ,KAAR,CAAc,KAAd,CAA5B,EAAkD,4BAAlD,CAAR;AACA,qBAAS,wBAAc,aAAd,CAA4B,QAAQ,KAAR,CAAc,MAAd,CAA5B,EAAmD,6BAAnD,CAAT;;AAEA,mBAAO,wBAAc,gBAAd,CAA+B,KAAK,iBAAL,CAAuB,KAAvB,EAA8B,MAA9B,CAA/B,CAAP;AACH;;;;;;;;;;0CAOiB,K,EAAO,M,EAAQ;AAC7B,gBAAI,CAAC,KAAL,EAAY;AACR,wBAAQ,EAAR;AACH;;AAED,gBAAI,CAAC,MAAL,EAAa;AACT,yBAAS,EAAT;AACH;;AAED,mBAAU,MAAM,QAAN,EAAV,UAA+B,OAAO,QAAP,EAA/B;AACH;;;4BAzGa;AACV,mBAAO,KAAK,QAAZ;AACH;;;;;;QA0GG,iB,GAAA,iB;QACA,kB,GAAA,kB;kBAEO,kB","file":"DelegatedConverter.js","sourcesContent":["'use strict';\n\nimport CoreObject from \"../CoreObject\";\nimport Preconditions from \"../Preconditions\";\nimport Utility from \"../Utility\";\nimport Adapter from \"./Adapter\";\nimport Converter from \"./Converter\";\n\n//region class CoreObjectAdapter\n/**\n * Internal class used by DelegatedConverter\n *\n * @private\n */\nclass CoreObjectAdapter extends Adapter {\n\n    /**\n     *\n     * @param {CoreObject|Class<CoreObject>} instanceOrClass\n     */\n    supports(instanceOrClass) {\n        return CoreObject.isInstanceOrClass(instanceOrClass);\n    }\n\n    /**\n     * @param {CoreObject|*} instance\n     * @returns {*}\n     */\n    adapt(instance) {\n        this.shouldSupport(instance);\n\n        return instance.toClass();\n    }\n}\n//endregion\n\n/**\n * Supports different conversion directions.\n *\n * This is not tied to money. It supports simple converting.\n *\n * {<br>\n *   'Bitcoin->Satoshi' : function(value) { return value * satoshi_factor; },<br>\n *   'Satoshi->Bitcoin': function(value) { return value / satoshi_factor; }<br>\n * }<br>\n *\n * @class\n */\nclass DelegatedConverter extends Converter {\n\n    //region constructor\n    /**\n     * @param {Object} options\n     * @param {Object} options.conversions\n     * @param {Adapter} [options.adapter]\n     */\n    constructor(options) {\n        let adapter = Utility.take(options, 'adapter', {\n            type: Adapter,\n            defaultValue: new CoreObjectAdapter()\n        });\n\n        let conversions = Utility.take(options, 'conversions', true);\n\n        super(...arguments);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._conversions = conversions || {};\n\n        /**\n         * @type {Adapter}\n         */\n        this._adapter = adapter;\n    }\n    //endregion\n\n    //region properties\n    /**\n     * @return {Adapter}\n     */\n    get adapter() {\n        return this._adapter;\n    }\n\n    //endregion\n\n    /**\n     * @param instance\n     * @param clazz\n     * @return {boolean}\n     */\n    supports(instance, clazz) {\n        let adapter = this.adapter;\n\n        if (!adapter.supports(instance) || !adapter.supports(clazz)) {\n            return false;\n        }\n\n        let fn = this.getConversion(instance, clazz);\n\n        return Utility.isFunction(fn);\n    }\n\n    /**\n     * Executes the conversion.\n     *\n     * @param {CoreObject|*} input\n     * @param {Class<CoreObject>|Class|*} outputClass\n     * @returns {*}\n     *\n     * @throws {PreconditionsError} if the converter fails to convert into a valid number\n     * @throws {PreconditionsError} if the destinationCurrency is not a valid currency\n     * @throws {PreconditionsError} if converter cannot support the conversion\n     */\n    convert(input, outputClass) {\n        let fn = this.getConversion(input, outputClass);\n\n        return fn.call(this, input, outputClass);\n    }\n\n    /**\n     * Detects the conversion function, given the inputs.\n     *\n     * @param {Class<CoreObject>|Class|*} input\n     * @param {Class<CoreObject>|Class|*} output\n     *\n     * @returns {Function|undefined}\n     */\n    getConversion(input, output) {\n        /**\n         * @type {String}\n         */\n        let conversionName = this.getConversionName(input, output);\n\n        return Preconditions.shouldBeFunction(\n            this._conversions[conversionName],\n            `Converter not found for ${conversionName}`);\n    }\n\n    /**\n     *\n     * @param {*} input\n     * @param {*} output\n     * @returns {Function}\n     */\n    optConversion(input, output) {\n        let conversionName = this.optConversionName(input, output);\n\n        return this._conversions[conversionName];\n    }\n\n    /**\n     *\n     * @param {Class<CoreObject>|Class|*} input\n     * @param {Class<CoreObject>|Class|*} output\n     * @private\n     * @return {string}\n     */\n    getConversionName(input, output) {\n        Preconditions.shouldBeDefined(input, 'param:input');\n        Preconditions.shouldBeDefined(output, 'param:output');\n\n        let adapter = this.adapter;\n\n        input = Preconditions.shouldBeClass(adapter.adapt(input), 'inputClass must be a class');\n        output = Preconditions.shouldBeClass(adapter.adapt(output), 'outputClass must be a class');\n\n        return Preconditions.shouldNotBeBlank(this.optConversionName(input, output));\n    }\n\n    /**\n     * @param {*} input\n     * @param {*} output\n     * @return {string}\n     */\n    optConversionName(input, output) {\n        if (!input) {\n            input = '';\n        }\n\n        if (!output) {\n            output = '';\n        }\n\n        return `${input.toString()}->${output.toString()}`;\n    }\n}\n\nexport {CoreObjectAdapter};\nexport {DelegatedConverter};\n\nexport default DelegatedConverter;"]}