{"version":3,"sources":["../../../src/js/data/DelegatedConverter.js"],"names":["CoreObjectAdapter","instanceOrClass","isInstanceOrClass","instance","shouldSupport","toClass","DelegatedConverter","options","adapter","take","type","defaultValue","conversions","arguments","_conversions","_adapter","clazz","supports","fn","getConversion","isFunction","input","outputClass","call","output","conversionName","getConversionName","shouldBeFunction","optConversionName","shouldBeDefined","shouldBeClass","adapt","shouldNotBeBlank","toString"],"mappings":"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","file":"DelegatedConverter.js","sourcesContent":["'use strict';\n\nimport CoreObject from \"../CoreObject\";\nimport Preconditions from \"../Preconditions\";\nimport Utility from \"../Utility\";\nimport Adapter from \"./Adapter\";\nimport Converter from \"./Converter\";\n\n//region class CoreObjectAdapter\n/**\n * Internal class used by DelegatedConverter\n *\n * @private\n */\nclass CoreObjectAdapter extends Adapter {\n\n    /**\n     *\n     * @param {CoreObject|Class<CoreObject>} instanceOrClass\n     */\n    supports(instanceOrClass) {\n        return CoreObject.isInstanceOrClass(instanceOrClass);\n    }\n\n    /**\n     * @param {CoreObject|*} instance\n     * @returns {*}\n     */\n    adapt(instance) {\n        this.shouldSupport(instance);\n\n        return instance.toClass();\n    }\n}\n//endregion\n\n/**\n * Supports different conversion directions.\n *\n * This is not tied to money. It supports simple converting.\n *\n * {<br>\n *   'Bitcoin->Satoshi' : function(value) { return value * satoshi_factor; },<br>\n *   'Satoshi->Bitcoin': function(value) { return value / satoshi_factor; }<br>\n * }<br>\n *\n * @class\n */\nclass DelegatedConverter extends Converter {\n\n    //region constructor\n    /**\n     * @param {Object} options\n     * @param {Object} options.conversions\n     * @param {Adapter} [options.adapter]\n     */\n    constructor(options) {\n        let adapter = Utility.take(options, 'adapter', {\n            type: Adapter,\n            defaultValue: new CoreObjectAdapter()\n        });\n\n        let conversions = Utility.take(options, 'conversions', true);\n\n        super(...arguments);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._conversions = conversions || {};\n\n        /**\n         * @type {Adapter}\n         */\n        this._adapter = adapter;\n    }\n    //endregion\n\n    //region properties\n    /**\n     * @return {Adapter}\n     */\n    get adapter() {\n        return this._adapter;\n    }\n\n    //endregion\n\n    /**\n     * @param instance\n     * @param clazz\n     * @return {boolean}\n     */\n    supports(instance, clazz) {\n        let adapter = this.adapter;\n\n        if (!adapter.supports(instance) || !adapter.supports(clazz)) {\n            return false;\n        }\n\n        let fn = this.getConversion(instance, clazz);\n\n        return Utility.isFunction(fn);\n    }\n\n    /**\n     * Executes the conversion.\n     *\n     * @param {CoreObject|*} input\n     * @param {Class<CoreObject>|Class|*} outputClass\n     * @returns {*}\n     *\n     * @throws {PreconditionsError} if the converter fails to convert into a valid number\n     * @throws {PreconditionsError} if the destinationCurrency is not a valid currency\n     * @throws {PreconditionsError} if converter cannot support the conversion\n     */\n    convert(input, outputClass) {\n        let fn = this.getConversion(input, outputClass);\n\n        return fn.call(this, input, outputClass);\n    }\n\n    /**\n     * Detects the conversion function, given the inputs.\n     *\n     * @param {Class<CoreObject>|Class|*} input\n     * @param {Class<CoreObject>|Class|*} output\n     *\n     * @returns {Function|undefined}\n     */\n    getConversion(input, output) {\n        /**\n         * @type {String}\n         */\n        let conversionName = this.getConversionName(input, output);\n\n        return Preconditions.shouldBeFunction(\n            this._conversions[conversionName],\n            `Converter not found for ${conversionName}`);\n    }\n\n    /**\n     *\n     * @param {*} input\n     * @param {*} output\n     * @returns {Function}\n     */\n    optConversion(input, output) {\n        let conversionName = this.optConversionName(input, output);\n\n        return this._conversions[conversionName];\n    }\n\n    /**\n     *\n     * @param {Class<CoreObject>|Class|*} input\n     * @param {Class<CoreObject>|Class|*} output\n     * @private\n     * @return {string}\n     */\n    getConversionName(input, output) {\n        Preconditions.shouldBeDefined(input, 'param:input');\n        Preconditions.shouldBeDefined(output, 'param:output');\n\n        let adapter = this.adapter;\n\n        input = Preconditions.shouldBeClass(adapter.adapt(input), 'inputClass must be a class');\n        output = Preconditions.shouldBeClass(adapter.adapt(output), 'outputClass must be a class');\n\n        return Preconditions.shouldNotBeBlank(this.optConversionName(input, output));\n    }\n\n    /**\n     * @param {*} input\n     * @param {*} output\n     * @return {string}\n     */\n    optConversionName(input, output) {\n        if (!input) {\n            input = '';\n        }\n\n        if (!output) {\n            output = '';\n        }\n\n        return `${input.toString()}->${output.toString()}`;\n    }\n}\n\nexport {CoreObjectAdapter};\nexport {DelegatedConverter};\n\nexport default DelegatedConverter;"]}