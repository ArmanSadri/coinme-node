{"version":3,"sources":["../../src/js/Preconditions.js"],"names":[],"mappings":"AAAA;;;;;;;;;AAEA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,SAAS,kBAAT,CAA4B,aAA5B,EAA2C,WAA3C,EAAwD,OAAxD,EAAiE,aAAjE,EAAgF;AAC5E,QAAI,QAAQ,MAAM,IAAN,CAAW,IAAX,EAAiB,OAAjB,CAAR,CADwE;;AAG5E,SAAK,IAAL,GAAY,oBAAZ,CAH4E;AAI5E,SAAK,KAAL,GAAa,MAAM,KAAN,CAJ+D;AAK5E,SAAK,KAAL,GAAa,aAAb,CAL4E;;AAO5E,SAAK,aAAL,GAAqB,aAArB,CAP4E;AAQ5E,SAAK,WAAL,GAAmB,WAAnB,CAR4E;AAS5E,SAAK,OAAL,4BAAsC,KAAK,aAAL,WAAwB,kBAAQ,MAAR,CAAe,KAAK,aAAL,sBAAmC,KAAK,WAAL,WAAsB,kBAAQ,MAAR,CAAe,KAAK,WAAL,sBAAiC,KAAK,OAAL,MAAtL,CAT4E;CAAhF;;AAYA,mBAAmB,SAAnB,GAA+B,OAAO,MAAP,CAAc,MAAM,SAAN,CAA7C;AACA,mBAAmB,SAAnB,CAA6B,WAA7B,GAA2C,kBAA3C;;QAES;;;;;;;IAMY;;;;;;;;;;;;;;;6BAQL,eAAe,aAAa,SAAS;AAC7C,kBAAM,IAAI,kBAAJ,CAAuB,aAAvB,EAAsC,WAAtC,EAAmD,WAAW,uBAAX,CAAzD,CAD6C;;;;;;;;;;;;0CAUxB,QAAQ,SAAS;AACtC,mBAAO,cAAc,QAAd,CAAuB,kBAAQ,WAAR,EAAqB,MAA5C,EAAoD,WAApD,EAAiE,WAAW,mBAAX,CAAxE,CADsC;;;;;;;;;;;;0CAUjB,QAAQ,SAAS;AACtC,mBAAO,cAAc,QAAd,CAAuB,kBAAQ,WAAR,EAAqB,MAA5C,EAAoD,OAApD,EAA6D,oBAA7D,CAAP,CADsC;;;;;;;;;;;;uCAUpB,QAAQ,SAAS;AACnC,mBAAO,cAAc,QAAd,CAAuB,kBAAQ,QAAR,EAAkB,MAAzC,EAAiD,OAAjD,EAA0D,gBAA1D,CAAP,CADmC;;;;;;;;;;;;;wCAWhB,QAAQ,SAAS;AACpC,gBAAI,kBAAQ,WAAR,CAAoB,MAApB,CAAJ,EAAiC;AAC7B,8BAAc,IAAd,CAAmB,SAAnB,EAA8B,WAA9B,EAA2C,WAAW,kBAAX,CAA3C,CAD6B;aAAjC;;AAIA,mBAAO,MAAP,CALoC;;;;;;;;;;;;yCAchB,QAAQ,SAAS;AACrC,mBAAO,cAAc,QAAd,CAAuB,kBAAQ,UAAR,EAAoB,OAA3C,EAAoD,MAApD,EAA4D,WAAW,aAAX,CAAnE,CADqC;;;;;;;;;;;;yCAUjB,QAAQ,SAAS;AACrC,0BAAc,cAAd,CAA6B,MAA7B,EADqC;;AAGrC,mBAAO,cAAc,QAAd,CAAuB,kBAAQ,UAAR,EAAoB,WAA3C,EAAwD,MAAxD,EAAgE,WAAW,oBAAX,CAAvE,CAHqC;;;;;;;;;;;;yCAYjB,IAAI,SAAS;AACjC,mBAAO,cAAc,YAAd,CAA2B,UAA3B,EAAuC,EAAvC,EAA2C,OAA3C,CAAP,CADiC;;;;;;;;;;;;uCAUf,QAAQ,SAAS;AACnC,0BAAc,YAAd,CAA2B,QAA3B,EAAqC,MAArC,EAA6C,OAA7C,EADmC;AAEnC,0BAAc,cAAd,CAA6B,MAA7B,EAAqC,OAArC,EAFmC;;AAInC,mBAAO,MAAP,CAJmC;;;;;;;;;;;;;;iCAevB,QAAQ,eAAe,aAAa,SAAS;AACzD,gBAAI,CAAC,kBAAQ,UAAR,CAAmB,MAAnB,CAAD,EAA6B;AAC7B,8BAAc,IAAd,CAAmB,UAAnB,EAA+B,MAA/B,wCAA2E,kBAAQ,MAAR,CAAe,MAAf,OAA3E,EAD6B;aAAjC;;AAIA,gBAAI,CAAC,OAAO,IAAP,CAAY,IAAZ,EAAkB,WAAlB,CAAD,EAAiC;AACjC,8BAAc,IAAd,CAAmB,aAAnB,EAAkC,WAAlC,EAA+C,WAAW,iBAAX,CAA/C,CADiC;aAArC;;AAIA,mBAAO,WAAP,CATyD;;;;;;;;;;;;uCAkBvC,QAAQ,SAAS;AACnC,gBAAI,CAAC,gBAAO,QAAP,CAAgB,MAAhB,CAAD,EAA0B;AAC1B,8BAAc,IAAd,CAAmB,QAAnB,EAA6B,MAA7B,EAAqC,WAAW,iBAAX,CAArC,CAD0B;aAA9B;;AAIA,mBAAO,MAAP,CALmC;;;;;;;;;;;;uCAcjB,QAAQ,SAAS;AACnC,0BAAc,gBAAd,CAA+B,MAA/B,EAAuC,OAAvC,EADmC;;AAGnC,gBAAI,KAAK,kBAAQ,WAAR,CAAoB,QAApB,CAAL;;;;AAH+B,mBAO5B,cAAc,QAAd,CAAuB,EAAvB,EAA2B,QAA3B,EAAqC,MAArC,EAA6C,OAA7C,CAAP,CAPmC;;;;;;;;;;;;uCAgBjB,QAAQ,SAAS;AACnC,0BAAc,gBAAd,CAA+B,MAA/B,EADmC;;AAGnC,gBAAI,KAAK,kBAAQ,WAAR,CAAoB,QAApB,CAAL,CAH+B;;AAKnC,mBAAO,cAAc,QAAd,CAAuB,EAAvB,EAA2B,QAA3B,EAAqC,MAArC,EAA6C,OAA7C,CAAP,CALmC;;;;;;;;;;;;;qCAenB,UAAU,OAAO,SAAS;AAC1C,mBAAO,cAAc,QAAd,CAAuB,kBAAQ,WAAR,CAAoB,QAApB,CAAvB,EAAsD,QAAtD,EAAgE,KAAhE,EAAuE,OAAvE,CAAP,CAD0C;;;;;;;;;;;;qCAU1B,SAAS,SAAS;AAClC,0BAAc,eAAd,CAA8B,OAA9B,EAAuC,OAAvC,EADkC;;AAGlC,gBAAI,SAAS,OAAT,EAAkB;AAClB,uBAAO,OAAP,CADkB;aAAtB;;AAIA,0BAAc,IAAd,CAAmB,OAAnB,EAA4B,IAA5B,EAAkC,WAAW,cAAX,CAAlC,CAPkC;;;;;;;;;;;;kDAgBL,QAAQ,SAAS;AAC9C,0BAAc,eAAd,CAA8B,MAA9B,EAAsC,OAAtC,EAD8C;AAE9C,0BAAc,cAAd,CAA6B,MAA7B,EAAqC,OAArC,EAF8C;;AAI9C,gBAAI,SAAS,CAAT,EAAY;AACZ,8BAAc,IAAd,CAAmB,UAAnB,EAA+B,MAA/B,EAAuC,WAAW,qCAAqC,MAArC,CAAlD,CADY;aAAhB;;AAIA,mBAAO,MAAP,CAR8C;;;;;;;;;;;wCAgB3B,SAAS,SAAS;AACrC,0BAAc,eAAd,CAA8B,OAA9B,EADqC;;AAGrC,gBAAI,CAAC,kBAAQ,SAAR,CAAkB,OAAlB,CAAD,EAA6B;AAC7B,8BAAc,IAAd,CAAmB,SAAnB,EAA8B,OAA9B,EAAuC,WAAW,iBAAX,CAAvC,CAD6B;aAAjC;;AAIA,mBAAO,OAAP,CAPqC;;;;;;;;;;;;4CAgBd,SAAS,SAAS,SAAS;AAClD,0BAAc,cAAd,CAA6B,OAA7B,EAAsC,OAAtC,EADkD;AAElD,0BAAc,cAAd,CAA6B,OAA7B,EAAsC,OAAtC,EAFkD;;AAIlD,gBAAI,WAAW,OAAX,EAAoB;AACpB,8BAAc,IAAd,CAAmB,iBAAiB,OAAjB,EAA0B,OAA7C,EAAsD,OAAtD,EADoB;aAAxB;;AAIA,mBAAO,OAAP,CARkD;;;;;;;;;;;;+CAiBxB,QAAQ,SAAS;AAC3C,0BAAc,cAAd,CAA6B,MAA7B,EAAqC,OAArC,EAD2C;;AAG3C,gBAAI,UAAU,CAAV,EAAa;AACb,8BAAc,IAAd,CAAmB,UAAnB,EAA+B,MAA/B,EAAuC,WAAW,qCAAqC,MAArC,CAAlD,CADa;aAAjB;;AAIA,mBAAO,MAAP,CAP2C;;;;WAxP9B","file":"Preconditions.js","sourcesContent":["'use strict';\n\nimport Utility from \"~/Utility\";\nimport Lodash from \"lodash/index\";\n\n// class PreconditionsError extends AbstractError {\n//\n//     /**\n//      *\n//      * @param {*} actualValue\n//      * @param {*} expectedValue\n//      * @param {String} [message]\n//      * @param {Error} [optionalCause]\n//      * @constructor\n//      */\n//     constructor(expectedValue, actualValue, message, optionalCause) {\n//         super(message);\n//\n//         console.log('capture stack A');\n//\n//         this.name = 'PreconditionsError';\n//         // this.stack = error.stack;\n//         this.cause = optionalCause;\n//\n//         this.expectedValue = expectedValue || '';\n//         this.actualValue = actualValue || '';\n//         this.message = `failure (expected: ${this.expectedValue}) (actual: ${this.actualValue}) (message: ${this.message})`;\n//     }\n// }\n\n/**\n *\n * @param {*} expectedValue\n * @param {*} actualValue\n * @param {String} [message]\n * @param {Error} [optionalCause]\n * @constructor\n */\nfunction PreconditionsError(expectedValue, actualValue, message, optionalCause) {\n    var error = Error.call(this, message);\n\n    this.name = 'PreconditionsError';\n    this.stack = error.stack;\n    this.cause = optionalCause;\n\n    this.expectedValue = expectedValue;\n    this.actualValue = actualValue;\n    this.message = `failure (expected: '${this.expectedValue}' [${Utility.typeOf(this.expectedValue)}]) (actual: '${this.actualValue}' [${Utility.typeOf(this.actualValue)}]) (message: ${this.message})`;\n}\n\nPreconditionsError.prototype = Object.create(Error.prototype);\nPreconditionsError.prototype.constructor = PreconditionsError;\n\nexport { PreconditionsError }\n\n/**\n * @singleton\n * @class Preconditions\n */\nexport default class Preconditions {\n\n    /**\n     *\n     * @param {*} expectedValue\n     * @param {*} actualValue\n     * @param {String} [message]\n     */\n    static fail(expectedValue, actualValue, message) {\n        throw new PreconditionsError(expectedValue, actualValue, message || 'Preconditions failure');\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * return {*} object\n     */\n    static shouldBeUndefined(object, message) {\n        return Preconditions.shouldBe(Utility.isUndefined, object, 'undefined', message || 'must be undefined');\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldNotBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isNotFalsey, object, message, 'must not be falsey')\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isFalsey, object, message, 'must be falsey')\n    }\n\n    /**\n     * This method checks for UNDEFINED, NAN, and NULL\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeDefined(object, message) {\n        if (Utility.isUndefined(object)) {\n            Preconditions.fail('defined', 'undefined', message || 'must be defined.');\n        }\n\n        return object;\n    }\n\n    /**\n     * Make sure an object is not: undefined, null, NaN\n     *\n     * @param {*} object\n     * @param {String} [message]\n     */\n    static shouldBeExisting(object, message) {\n        return Preconditions.shouldBe(Utility.isExisting, 'exist', object, message || 'must exist.');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldNotBeBlank(string, message) {\n        Preconditions.shouldBeString(string);\n\n        return Preconditions.shouldBe(Utility.isNotBlank, 'not blank', string, message || 'must not be blank.');\n    }\n\n    /**\n     *\n     * @param {*} fn\n     * @param {String} [message]\n     * @return {function}\n     */\n    static shouldBeFunction(fn, message) {\n        return Preconditions.shouldBeType('function', fn, message);\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeNumber(number, message) {\n        Preconditions.shouldBeType('number', number, message);\n        Preconditions.shouldBeFinite(number, message);\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {function} testFn\n     * @param {*} [expectedValue]\n     * @param {*} actualValue\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBe(testFn, expectedValue, actualValue, message) {\n        if (!Utility.isFunction(testFn)) {\n            Preconditions.fail('function', testFn, `testFn must be function, but was ${Utility.typeOf(testFn)}.`);\n        }\n\n        if (!testFn.call(this, actualValue)) {\n            Preconditions.fail(expectedValue, actualValue, message || 'must pass test.');\n        }\n\n        return actualValue;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeFinite(number, message) {\n        if (!Lodash.isFinite(number)) {\n            Preconditions.fail('finite', number, message || 'must be finite.');\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {String} [message]\n     * @return {Object}\n     */\n    static shouldBeObject(object, message) {\n        Preconditions.shouldBeExisting(object, message);\n\n        let fn = Utility.typeMatcher('object');\n\n        // throw new Error(Utility.typeOf(fn));\n\n        return Preconditions.shouldBe(fn, 'object', object, message);\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldBeString(string, message) {\n        Preconditions.shouldBeExisting(string);\n\n        let fn = Utility.typeMatcher('string');\n\n        return Preconditions.shouldBe(fn, 'object', string, message);\n    }\n\n    /**\n     *\n     * @param {String} typeName\n     * @param {*} value\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeType(typeName, value, message) {\n        return Preconditions.shouldBe(Utility.typeMatcher(typeName), typeName, value, message);\n    }\n\n    /**\n     *\n     * @param {*} boolean\n     * @param {String} [message]\n     * @return {boolean}\n     */\n    static shouldBeTrue(boolean, message) {\n        Preconditions.shouldBeBoolean(boolean, message);\n\n        if (true === boolean) {\n            return boolean;\n        }\n\n        Preconditions.fail(boolean, true, message || 'was not true');\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @returns {Number}\n     */\n    static shouldNotBeNegativeNumber(number, message) {\n        Preconditions.shouldBeDefined(number, message);\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number < 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {boolean} boolean\n     * @param {String} [message]\n     */\n    static shouldBeBoolean(boolean, message) {\n        Preconditions.shouldBeDefined(boolean);\n\n        if (!Utility.isBoolean(boolean)) {\n            Preconditions.fail('boolean', boolean, message || 'was not boolean');\n        }\n\n        return boolean;\n    }\n\n    /**\n     *\n     * @param {*} number1\n     * @param {*} number2\n     * @param {String} [message]\n     */\n    static shouldBeGreaterThan(number1, number2, message) {\n        Preconditions.shouldBeNumber(number1, message);\n        Preconditions.shouldBeNumber(number2, message);\n\n        if (number1 <= number2) {\n            Preconditions.fail('larger than ' + number2, number1, message);\n        }\n\n        return number1;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBePositiveNumber(number, message) {\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number <= 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n}"]}