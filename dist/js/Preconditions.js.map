{"version":3,"sources":["../../src/js/Preconditions.js"],"names":["Preconditions","expectedValue","actualValue","message","object","shouldBe","isUndefined","undefined","isNotFalsey","isFalsey","fail","isExisting","string","shouldBeString","isNotBlank","fn","shouldBeType","number","shouldBeFinite","testFn","isFunction","typeOf","call","scope","Error","e","shouldBePreconditionsError","actualClass","requiredClassOrMessage","shouldBeDefined","requiredClass","isString","shouldBeUndefined","isClass","value","clazz","isInstance","classOrString","toClass","shouldBeClass","isFinite","shouldBeExisting","typeMatcher","regexp","shouldBeRegExp","match","isErrorClass","typeName","boolean","shouldBeBoolean","target","constructor","throwMustBeAbstract","shouldBeNumber","isBoolean","array","isArray","number1","number2"],"mappings":"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","file":"Preconditions.js","sourcesContent":["'use strict';\n\nimport Utility from \"./Utility\";\nimport Lodash from \"lodash/index\";\nimport CoreObject from \"./CoreObject\";\nimport AbstractError from \"./errors/AbstractError\";\nimport {Errors, PreconditionsError} from \"./errors\";\nimport {ZonedDateTime} from 'js-joda';\n\n// class PreconditionsError extends AbstractError {\n//\n//     /**\n//      *\n//      * @param {*} actualValue\n//      * @param {*} expectedValue\n//      * @param {String} [message]\n//      * @param {Error} [optionalCause]\n//      * @constructor\n//      */\n//     constructor(expectedValue, actualValue, message, optionalCause) {\n//         super(message);\n//\n //\n//         this.name = 'PreconditionsError';\n//         // this.stack = error.stack;\n//         this.cause = optionalCause;\n//\n//         this.expectedValue = expectedValue || '';\n//         this.actualValue = actualValue || '';\n//         this.message = `failure (expected: ${this.expectedValue}) (actual: ${this.actualValue}) (message: ${this.message})`;\n//     }\n// }\n\n// /**\n//  *\n//  * @param {*} expectedValue\n//  * @param {*} actualValue\n//  * @param {String} [message]\n//  * @param {Error} [optionalCause]\n//  * @constructor\n//  */\n// function PreconditionsError(expectedValue, actualValue, message, optionalCause) {\n//     var error = Error.call(this, message);\n//\n//     this.name = 'PreconditionsError';\n//     this.stack = error.stack;\n//     this.cause = optionalCause;\n//\n//     this.expectedValue = expectedValue;\n//     this.actualValue = actualValue;\n//     this.message = `failure (expected: '${this.expectedValue}' [${Utility.typeOf(this.expectedValue)}]) (actual: '${this.actualValue}' [${Utility.typeOf(this.actualValue)}]) (message: ${this.message})`;\n// }\n//\n// PreconditionsError.prototype = Object.create(Error.prototype);\n// PreconditionsError.prototype.constructor = PreconditionsError;\n//\n// export { PreconditionsError }\n\n/**\n * @singleton\n * @class Preconditions\n */\nexport default class Preconditions {\n\n    /**\n     *\n     * @param {*} expectedValue\n     * @param {*} actualValue\n     * @param {String} [message]\n     */\n    static fail(expectedValue, actualValue, message) {\n        throw new PreconditionsError({\n            expectedValue: expectedValue,\n            actualValue: actualValue,\n            message: message || 'Preconditions failure'\n        });\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * return {*} object\n     */\n    static shouldBeUndefined(object, message) {\n        return Preconditions.shouldBe(Utility.isUndefined, undefined, object, message || 'must be undefined');\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldNotBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isNotFalsey, true, object, message || 'must not be falsey')\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isFalsey, false, object, message || 'must be falsey')\n    }\n\n    /**\n     * This method checks for UNDEFINED, NAN, and NULL\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeDefined(object, message) {\n        if (Utility.isUndefined(object)) {\n            Preconditions.fail('defined', undefined, message || 'must be defined.');\n        }\n\n        return object;\n    }\n\n    /**\n     * Make sure an object is not: undefined, null, NaN\n     *\n     * @param {*} object\n     * @param {String} [message]\n     */\n    static shouldBeExisting(object, message) {\n        return Preconditions.shouldBe(Utility.isExisting, 'exist', object, message || 'must exist.');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldNotBeBlank(string, message) {\n        Preconditions.shouldBeString(string, message || 'not blank');\n\n        return Preconditions.shouldBe(Utility.isNotBlank, 'not blank', string, message || 'must not be blank.');\n    }\n\n    /**\n     *\n     * @param {*} fn\n     * @param {String} [message]\n     * @return {function}\n     */\n    static shouldBeFunction(fn, message) {\n        return Preconditions.shouldBeType('function', fn, message);\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeNumber(number, message) {\n        Preconditions.shouldBeType('number', number, message);\n        Preconditions.shouldBeFinite(number, message);\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {function} testFn\n     * @param {*} [expectedValue]\n     * @param {*} actualValue\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBe(testFn, expectedValue, actualValue, message) {\n        if (!Utility.isFunction(testFn)) {\n            Preconditions.fail('function', testFn, `testFn must be function, but was ${Utility.typeOf(testFn)}.`);\n        }\n\n        if (!testFn.call(this, actualValue)) {\n            Preconditions.fail(expectedValue, actualValue, message || 'must pass test.');\n        }\n\n        return actualValue;\n    }\n\n    /**\n     * Execute a function. The function should fail with a preconditions error.\n     *\n     * @param {function} fn\n     * @param {*} [scope]\n     */\n    static shouldFailWithPreconditionsError(fn, scope) {\n        try {\n            fn.call(scope || this);\n\n            throw new Error('Did not crash');\n        } catch (e) {\n            Preconditions.shouldBePreconditionsError(e);\n        }\n    }\n\n    /**\n     *\n     *\n     * @param {Class|Object} actualClass\n     * @param {Class|String} [requiredClassOrMessage]\n     * @param {String} [message]\n     */\n    static shouldBeClass(actualClass, requiredClassOrMessage, message) {\n        Preconditions.shouldBeDefined(actualClass, message || 'object must be defined');\n\n        let requiredClass;\n        \n        if (Utility.isString(requiredClassOrMessage)) {\n            Preconditions.shouldBeUndefined(message);\n            message = requiredClassOrMessage;\n            requiredClassOrMessage = null;\n        } else {\n            requiredClass = requiredClassOrMessage;\n        }\n\n        if (!requiredClass) {\n            requiredClass = CoreObject;\n        }\n\n        if (!CoreObject.isClass(requiredClass)) {\n            Preconditions.fail(CoreObject, requiredClass, message || 'Class not a CoreObject class');\n        }\n\n        if (!requiredClass.isClass(actualClass)) {\n            Preconditions.fail(requiredClass, actualClass, message || `Class was of the wrong type.`);\n        }\n\n        return actualClass;\n    }\n\n    /**\n     *\n     * @param value\n     * @param message\n     * @return {*}\n     */\n    static shouldBeDateTime(value, message) {\n        Preconditions.shouldBeType('temporal', value, message);\n        Preconditions.shouldBe(() => { return value instanceof ZonedDateTime; }, ZonedDateTime, value, message || 'Must be ZonedDateTime');\n\n        return value;\n    }\n\n    /**\n     *\n     * @param {Temporal|ZonedDateTime|Instant} value\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeTemporal(value, message) {\n        Preconditions.shouldBeType('temporal', value, message || 'must be temporal');\n\n        return value;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {Class} [clazz]\n     * @param {String} [message]\n     * @returns {Object}\n     */\n    static shouldBeInstance(object, clazz, message) {\n        Preconditions.shouldBeDefined(object, message || 'object must be defined');\n\n        if (!Utility.isInstance(object)) {\n            Preconditions.fail(CoreObject, clazz, message || 'object not an instance');\n        }\n\n        if (clazz) {\n            if (!Utility.isClass(clazz)) {\n                Preconditions.fail(CoreObject, clazz, message || 'clazz not a class');\n            }\n\n            if (!clazz.isInstance(object)) {\n                Preconditions.fail(object, clazz, message || 'Class not an instance of ' + clazz);\n            }\n        }\n\n        return object;\n    }\n\n    /**\n     * Less strict version of \"shouldBeInstance\"\n     *\n     * @param {*} object\n     * @param {*} clazz\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeInstanceOf(object, clazz, message) {\n        Preconditions.shouldBeDefined(object, message);\n        Preconditions.shouldBeDefined(clazz, message);\n\n        if (object instanceof clazz) {\n            return object;\n        }\n\n        Preconditions.fail(true, false, message);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {Class<CoreObject>|String} [classOrString]\n     * @param {String} [message]\n     * @returns {Object}\n     */\n    static shouldNotBeInstance(object, classOrString, message) {\n        if (!object) {\n            return object;\n        }\n\n        let clazz;\n\n        if (Utility.isString(classOrString)) {\n            Preconditions.shouldBeUndefined(message);\n            message = classOrString;\n        }\n\n        if (!clazz) {\n            clazz = CoreObject.toClass();\n        }\n\n        clazz = Preconditions.shouldBeClass(clazz);\n\n        if (clazz.isInstance(object)) {\n            Preconditions.fail(object, clazz, message || 'Class is an instance of ' + clazz);\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeFinite(number, message) {\n        if (!Lodash.isFinite(number)) {\n            Preconditions.fail('finite', number, message || 'must be finite.');\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {String} [message]\n     * @return {Object}\n     */\n    static shouldBeObject(object, message) {\n        Preconditions.shouldBeExisting(object, message);\n\n        let fn = Utility.typeMatcher('object');\n\n        return Preconditions.shouldBe(fn, 'object', object, message || 'shouldBeObject');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldBeString(string, message) {\n        Preconditions.shouldBeExisting(string);\n\n        let fn = Utility.typeMatcher('string');\n\n        return Preconditions.shouldBe(fn, 'object', string, message);\n    }\n\n    /**\n     *\n     * @param {String} string\n     * @param {RegExp} regexp\n     * @param {String} [message]\n     */\n    static shouldMatchRegexp(string, regexp, message) {\n        Preconditions.shouldBeString(string, message);\n        Preconditions.shouldBeRegExp(regexp, message);\n\n        if (!string.match(regexp)) {\n            Preconditions.fail(true, false, message);\n        }\n\n        return string;\n    }\n\n    /**\n     *\n     * @param {RegExp} regexp\n     * @param {String} [message]\n     * @return {RegExp}\n     */\n    static shouldBeRegExp(regexp, message) {\n        return Preconditions.shouldBeType('regexp', regexp, message);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {AbstractError} [clazz]\n     * @param {String} [message]\n     * @returns Error\n     */\n    static shouldBeError(object, clazz, message) {\n        Preconditions.shouldBeType('error', object, message || 'Should be error type');\n\n        if (clazz) {\n            if (!Errors.isErrorClass(clazz)) {\n                Preconditions.fail(Error, clazz, message || 'must be error class');\n            }\n\n            if (!clazz.isInstance(object)) {\n                Preconditions.fail(clazz, object, message || 'must be error instance.');\n            }\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {String} typeName\n     * @param {*} value\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeType(typeName, value, message) {\n        return Preconditions.shouldBe(Utility.typeMatcher(typeName), typeName, value, message);\n    }\n\n    /**\n     *\n     * @param {*} boolean\n     * @param {String} [message]\n     * @return {boolean}\n     */\n    static shouldBeTrue(boolean, message) {\n        Preconditions.shouldBeBoolean(boolean, message || 'should be true');\n\n        if (true === boolean) {\n            return boolean;\n        }\n\n        Preconditions.fail(boolean, true, message || 'was not true');\n    }\n\n    /**\n     * @param {*} target (pass this in exactly \"new.target\")\n     * @param {Class} clazz\n     * @return {*}\n     */\n    static shouldBeAbstract(target, clazz) {\n        if (target.constructor === clazz) {\n            Errors.throwMustBeAbstract(clazz);\n        }\n\n        return target;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @returns {Number}\n     */\n    static shouldNotBeNegativeNumber(number, message) {\n        Preconditions.shouldBeDefined(number, message);\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number < 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {boolean} boolean\n     * @param {String} [message]\n     */\n    static shouldBeBoolean(boolean, message) {\n        Preconditions.shouldBeDefined(boolean, message || 'should be boolean');\n\n        if (!Utility.isBoolean(boolean)) {\n            Preconditions.fail('boolean', boolean, message || 'was not boolean');\n        }\n\n        return boolean;\n    }\n\n    /**\n     *\n     * @param {Array} array\n     * @param {String} [message]\n     */\n    static shouldBeArray(array, message) {\n        Preconditions.shouldBeDefined(array);\n\n        if (!Utility.isArray(array)) {\n            Preconditions.fail('array', array, message || 'was not array');\n        }\n\n        return array;\n    }\n\n    /**\n     *\n     * @param {*} number1\n     * @param {*} number2\n     * @param {String} [message]\n     */\n    static shouldBeGreaterThan(number1, number2, message) {\n        Preconditions.shouldBeNumber(number1, message);\n        Preconditions.shouldBeNumber(number2, message);\n\n        if (number1 <= number2) {\n            Preconditions.fail('larger than ' + number2, number1, message);\n        }\n\n        return number1;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBePositiveNumber(number, message) {\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number <= 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n\n    /**\n     * @param {*|PreconditionsError} e\n     * @param {String} [message]\n     *\n     * @return {PreconditionsError}\n     */\n    static shouldBePreconditionsError(e, message) {\n        if (!PreconditionsError.isInstance(e)) {\n            Preconditions.fail(PreconditionsError, e, message || 'Should be a preconditions error. Was: ' + e);\n        }\n\n        return e;\n    }\n}"]}