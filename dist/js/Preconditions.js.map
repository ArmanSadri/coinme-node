{"version":3,"sources":["../../src/js/Preconditions.js"],"names":[],"mappings":"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","file":"Preconditions.js","sourcesContent":["'use strict';\n\nimport Utility from \"./Utility\";\nimport Lodash from \"lodash/index\";\nimport CoreObject from \"./CoreObject\";\nimport AbstractError from \"./errors/AbstractError\";\nimport {Errors, PreconditionsError} from \"./errors\";\nimport {ZonedDateTime} from 'js-joda';\n\n// class PreconditionsError extends AbstractError {\n//\n//     /**\n//      *\n//      * @param {*} actualValue\n//      * @param {*} expectedValue\n//      * @param {String} [message]\n//      * @param {Error} [optionalCause]\n//      * @constructor\n//      */\n//     constructor(expectedValue, actualValue, message, optionalCause) {\n//         super(message);\n//\n//         console.log('capture stack A');\n//\n//         this.name = 'PreconditionsError';\n//         // this.stack = error.stack;\n//         this.cause = optionalCause;\n//\n//         this.expectedValue = expectedValue || '';\n//         this.actualValue = actualValue || '';\n//         this.message = `failure (expected: ${this.expectedValue}) (actual: ${this.actualValue}) (message: ${this.message})`;\n//     }\n// }\n\n// /**\n//  *\n//  * @param {*} expectedValue\n//  * @param {*} actualValue\n//  * @param {String} [message]\n//  * @param {Error} [optionalCause]\n//  * @constructor\n//  */\n// function PreconditionsError(expectedValue, actualValue, message, optionalCause) {\n//     var error = Error.call(this, message);\n//\n//     this.name = 'PreconditionsError';\n//     this.stack = error.stack;\n//     this.cause = optionalCause;\n//\n//     this.expectedValue = expectedValue;\n//     this.actualValue = actualValue;\n//     this.message = `failure (expected: '${this.expectedValue}' [${Utility.typeOf(this.expectedValue)}]) (actual: '${this.actualValue}' [${Utility.typeOf(this.actualValue)}]) (message: ${this.message})`;\n// }\n//\n// PreconditionsError.prototype = Object.create(Error.prototype);\n// PreconditionsError.prototype.constructor = PreconditionsError;\n//\n// export { PreconditionsError }\n\n/**\n * @singleton\n * @class Preconditions\n */\nexport default class Preconditions {\n\n    /**\n     *\n     * @param {*} expectedValue\n     * @param {*} actualValue\n     * @param {String} [message]\n     */\n    static fail(expectedValue, actualValue, message) {\n        throw new PreconditionsError({\n            expectedValue: expectedValue,\n            actualValue: actualValue,\n            message: message || 'Preconditions failure'\n        });\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * return {*} object\n     */\n    static shouldBeUndefined(object, message) {\n        return Preconditions.shouldBe(Utility.isUndefined, undefined, object, message || 'must be undefined');\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldNotBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isNotFalsey, true, object, message || 'must not be falsey')\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isFalsey, false, object, message || 'must be falsey')\n    }\n\n    /**\n     * This method checks for UNDEFINED, NAN, and NULL\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeDefined(object, message) {\n        if (Utility.isUndefined(object)) {\n            Preconditions.fail('defined', undefined, message || 'must be defined.');\n        }\n\n        return object;\n    }\n\n    /**\n     * Make sure an object is not: undefined, null, NaN\n     *\n     * @param {*} object\n     * @param {String} [message]\n     */\n    static shouldBeExisting(object, message) {\n        return Preconditions.shouldBe(Utility.isExisting, 'exist', object, message || 'must exist.');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldNotBeBlank(string, message) {\n        Preconditions.shouldBeString(string, message || 'not blank');\n\n        return Preconditions.shouldBe(Utility.isNotBlank, 'not blank', string, message || 'must not be blank.');\n    }\n\n    /**\n     *\n     * @param {*} fn\n     * @param {String} [message]\n     * @return {function}\n     */\n    static shouldBeFunction(fn, message) {\n        return Preconditions.shouldBeType('function', fn, message);\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeNumber(number, message) {\n        Preconditions.shouldBeType('number', number, message);\n        Preconditions.shouldBeFinite(number, message);\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {function} testFn\n     * @param {*} [expectedValue]\n     * @param {*} actualValue\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBe(testFn, expectedValue, actualValue, message) {\n        if (!Utility.isFunction(testFn)) {\n            Preconditions.fail('function', testFn, `testFn must be function, but was ${Utility.typeOf(testFn)}.`);\n        }\n\n        if (!testFn.call(this, actualValue)) {\n            Preconditions.fail(expectedValue, actualValue, message || 'must pass test.');\n        }\n\n        return actualValue;\n    }\n\n    /**\n     * Execute a function. The function should fail with a preconditions error.\n     *\n     * @param {function} fn\n     * @param {*} [scope]\n     */\n    static shouldFailWithPreconditionsError(fn, scope) {\n        try {\n            fn.call(scope || this);\n\n            throw new Error('Did not crash');\n        } catch (e) {\n            Preconditions.shouldBePreconditionsError(e);\n        }\n    }\n\n    /**\n     *\n     *\n     * @param {Class|Object} actualClass\n     * @param {Class|String} [requiredClassOrMessage]\n     * @param {String} [message]\n     */\n    static shouldBeClass(actualClass, requiredClassOrMessage, message) {\n        Preconditions.shouldBeDefined(actualClass, message || 'object must be defined');\n\n        let requiredClass;\n        \n        if (Utility.isString(requiredClassOrMessage)) {\n            Preconditions.shouldBeUndefined(message);\n            message = requiredClassOrMessage;\n            requiredClassOrMessage = null;\n        } else {\n            requiredClass = requiredClassOrMessage;\n        }\n\n        if (!requiredClass) {\n            requiredClass = CoreObject;\n        }\n\n        if (!CoreObject.isClass(requiredClass)) {\n            Preconditions.fail(CoreObject, requiredClass, message || 'Class not a CoreObject class');\n        }\n\n        if (!requiredClass.isClass(actualClass)) {\n            Preconditions.fail(requiredClass, actualClass, message || `Class was of the wrong type.`);\n        }\n\n        return actualClass;\n    }\n\n    /**\n     *\n     * @param value\n     * @param message\n     * @return {*}\n     */\n    static shouldBeDateTime(value, message) {\n        Preconditions.shouldBeType('temporal', value, message);\n        Preconditions.shouldBe(() => { return value instanceof ZonedDateTime; }, ZonedDateTime, value, message || 'Must be ZonedDateTime');\n\n        return value;\n    }\n\n    /**\n     *\n     * @param {Temporal|ZonedDateTime|Instant} value\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeTemporal(value, message) {\n        Preconditions.shouldBeType('temporal', value, message || 'must be temporal');\n\n        return value;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {Class} [clazz]\n     * @param {String} [message]\n     * @returns {Object}\n     */\n    static shouldBeInstance(object, clazz, message) {\n        Preconditions.shouldBeDefined(object, message || 'object must be defined');\n\n        if (!Utility.isInstance(object)) {\n            Preconditions.fail(CoreObject, clazz, message || 'object not an instance');\n        }\n\n        if (clazz) {\n            if (!Utility.isClass(clazz)) {\n                Preconditions.fail(CoreObject, clazz, message || 'clazz not a class');\n            }\n\n            if (!clazz.isInstance(object)) {\n                Preconditions.fail(object, clazz, message || 'Class not an instance of ' + clazz);\n            }\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {Class<CoreObject>|String} [classOrString]\n     * @param {String} [message]\n     * @returns {Object}\n     */\n    static shouldNotBeInstance(object, classOrString, message) {\n        if (!object) {\n            return object;\n        }\n\n        let clazz;\n\n        if (Utility.isString(classOrString)) {\n            Preconditions.shouldBeUndefined(message);\n            message = classOrString;\n        }\n\n        if (!clazz) {\n            clazz = CoreObject.toClass();\n        }\n\n        clazz = Preconditions.shouldBeClass(clazz);\n\n        if (clazz.isInstance(object)) {\n            Preconditions.fail(object, clazz, message || 'Class is an instance of ' + clazz);\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeFinite(number, message) {\n        if (!Lodash.isFinite(number)) {\n            Preconditions.fail('finite', number, message || 'must be finite.');\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {String} [message]\n     * @return {Object}\n     */\n    static shouldBeObject(object, message) {\n        Preconditions.shouldBeExisting(object, message);\n\n        let fn = Utility.typeMatcher('object');\n\n        return Preconditions.shouldBe(fn, 'object', object, message || 'shouldBeObject');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldBeString(string, message) {\n        Preconditions.shouldBeExisting(string);\n\n        let fn = Utility.typeMatcher('string');\n\n        return Preconditions.shouldBe(fn, 'object', string, message);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {AbstractError} [clazz]\n     * @param {String} [message]\n     * @returns Error\n     */\n    static shouldBeError(object, clazz, message) {\n        Preconditions.shouldBeType('error', object, message || 'Should be error type');\n\n        if (clazz) {\n            if (!Errors.isErrorClass(clazz)) {\n                Preconditions.fail(Error, clazz, message || 'must be error class');\n            }\n\n            if (!clazz.isInstance(object)) {\n                Preconditions.fail(clazz, object, message || 'must be error instance.');\n            }\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {String} typeName\n     * @param {*} value\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeType(typeName, value, message) {\n        return Preconditions.shouldBe(Utility.typeMatcher(typeName), typeName, value, message);\n    }\n\n    /**\n     *\n     * @param {*} boolean\n     * @param {String} [message]\n     * @return {boolean}\n     */\n    static shouldBeTrue(boolean, message) {\n        Preconditions.shouldBeBoolean(boolean, message);\n\n        if (true === boolean) {\n            return boolean;\n        }\n\n        Preconditions.fail(boolean, true, message || 'was not true');\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @returns {Number}\n     */\n    static shouldNotBeNegativeNumber(number, message) {\n        Preconditions.shouldBeDefined(number, message);\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number < 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {boolean} boolean\n     * @param {String} [message]\n     */\n    static shouldBeBoolean(boolean, message) {\n        Preconditions.shouldBeDefined(boolean);\n\n        if (!Utility.isBoolean(boolean)) {\n            Preconditions.fail('boolean', boolean, message || 'was not boolean');\n        }\n\n        return boolean;\n    }\n\n    /**\n     *\n     * @param {Array} array\n     * @param {String} [message]\n     */\n    static shouldBeArray(array, message) {\n        Preconditions.shouldBeDefined(array);\n\n        if (!Utility.isArray(array)) {\n            Preconditions.fail('array', array, message || 'was not array');\n        }\n\n        return array;\n    }\n\n    /**\n     *\n     * @param {*} number1\n     * @param {*} number2\n     * @param {String} [message]\n     */\n    static shouldBeGreaterThan(number1, number2, message) {\n        Preconditions.shouldBeNumber(number1, message);\n        Preconditions.shouldBeNumber(number2, message);\n\n        if (number1 <= number2) {\n            Preconditions.fail('larger than ' + number2, number1, message);\n        }\n\n        return number1;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBePositiveNumber(number, message) {\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number <= 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n\n    /**\n     * @param {*|PreconditionsError} e\n     * @param {String} [message]\n     *\n     * @return {PreconditionsError}\n     */\n    static shouldBePreconditionsError(e, message) {\n        if (!PreconditionsError.isInstance(e)) {\n            Preconditions.fail(PreconditionsError, e, message || 'Should be a preconditions error. Was: ' + e);\n        }\n\n        return e;\n    }\n}"]}