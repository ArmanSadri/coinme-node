{"version":3,"sources":["../../src/js/Preconditions.js"],"names":[],"mappings":"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","file":"Preconditions.js","sourcesContent":["'use strict';\n\nimport Utility from \"./Utility\";\nimport Lodash from \"lodash/index\";\nimport CoreObject from './CoreObject';\n\n// class PreconditionsError extends AbstractError {\n//\n//     /**\n//      *\n//      * @param {*} actualValue\n//      * @param {*} expectedValue\n//      * @param {String} [message]\n//      * @param {Error} [optionalCause]\n//      * @constructor\n//      */\n//     constructor(expectedValue, actualValue, message, optionalCause) {\n//         super(message);\n//\n//         console.log('capture stack A');\n//\n//         this.name = 'PreconditionsError';\n//         // this.stack = error.stack;\n//         this.cause = optionalCause;\n//\n//         this.expectedValue = expectedValue || '';\n//         this.actualValue = actualValue || '';\n//         this.message = `failure (expected: ${this.expectedValue}) (actual: ${this.actualValue}) (message: ${this.message})`;\n//     }\n// }\n\n/**\n *\n * @param {*} expectedValue\n * @param {*} actualValue\n * @param {String} [message]\n * @param {Error} [optionalCause]\n * @constructor\n */\nfunction PreconditionsError(expectedValue, actualValue, message, optionalCause) {\n    var error = Error.call(this, message);\n\n    this.name = 'PreconditionsError';\n    this.stack = error.stack;\n    this.cause = optionalCause;\n\n    this.expectedValue = expectedValue;\n    this.actualValue = actualValue;\n    this.message = `failure (expected: '${this.expectedValue}' [${Utility.typeOf(this.expectedValue)}]) (actual: '${this.actualValue}' [${Utility.typeOf(this.actualValue)}]) (message: ${this.message})`;\n}\n\nPreconditionsError.prototype = Object.create(Error.prototype);\nPreconditionsError.prototype.constructor = PreconditionsError;\n\nexport { PreconditionsError }\n\n/**\n * @singleton\n * @class Preconditions\n */\nexport default class Preconditions {\n\n    /**\n     *\n     * @param {*} expectedValue\n     * @param {*} actualValue\n     * @param {String} [message]\n     */\n    static fail(expectedValue, actualValue, message) {\n        throw new PreconditionsError(expectedValue, actualValue, message || 'Preconditions failure');\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * return {*} object\n     */\n    static shouldBeUndefined(object, message) {\n        return Preconditions.shouldBe(Utility.isUndefined, object, 'undefined', message || 'must be undefined');\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldNotBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isNotFalsey, true, object, message || 'must not be falsey')\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isFalsey, false, object, message || 'must be falsey')\n    }\n\n    /**\n     * This method checks for UNDEFINED, NAN, and NULL\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeDefined(object, message) {\n        if (Utility.isUndefined(object)) {\n            Preconditions.fail('defined', 'undefined', message || 'must be defined.');\n        }\n\n        return object;\n    }\n\n    /**\n     * Make sure an object is not: undefined, null, NaN\n     *\n     * @param {*} object\n     * @param {String} [message]\n     */\n    static shouldBeExisting(object, message) {\n        return Preconditions.shouldBe(Utility.isExisting, 'exist', object, message || 'must exist.');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldNotBeBlank(string, message) {\n        Preconditions.shouldBeString(string);\n\n        return Preconditions.shouldBe(Utility.isNotBlank, 'not blank', string, message || 'must not be blank.');\n    }\n\n    /**\n     *\n     * @param {*} fn\n     * @param {String} [message]\n     * @return {function}\n     */\n    static shouldBeFunction(fn, message) {\n        return Preconditions.shouldBeType('function', fn, message);\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeNumber(number, message) {\n        Preconditions.shouldBeType('number', number, message);\n        Preconditions.shouldBeFinite(number, message);\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {function} testFn\n     * @param {*} [expectedValue]\n     * @param {*} actualValue\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBe(testFn, expectedValue, actualValue, message) {\n        if (!Utility.isFunction(testFn)) {\n            Preconditions.fail('function', testFn, `testFn must be function, but was ${Utility.typeOf(testFn)}.`);\n        }\n\n        if (!testFn.call(this, actualValue)) {\n            Preconditions.fail(expectedValue, actualValue, message || 'must pass test.');\n        }\n\n        return actualValue;\n    }\n\n    /**\n     *\n     * @param {Class|Object} object\n     * @param {Class|Object} [clazz]\n     * @param {String} [message]\n     */\n    static shouldBeClass(object, clazz, message) {\n        Preconditions.shouldBeDefined(object, 'object must be defined');\n\n        if (!clazz) {\n            clazz = CoreObject;\n        }\n\n        if (!CoreObject.isClass(clazz)) {\n            Preconditions.fail(CoreObject, clazz, 'Class not a CoreObject class');\n        }\n\n        if (!clazz.isClass(object)) {\n            Preconditions.fail(object, clazz, 'Class not a ' + clazz + ' class');\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {Class|Object} [clazz]\n     * @param {String} [message]\n     * @returns {Object}\n     */\n    static shouldBeInstance(object, clazz, message) {\n        Preconditions.shouldBeDefined(object, message || 'object must be defined');\n\n        if (!clazz) {\n            clazz = CoreObject;\n        }\n\n        if (!CoreObject.isClass(clazz)) {\n            Preconditions.fail(CoreObject, clazz, message || 'Class not a CoreObject class');\n        }\n\n        if (!clazz.isInstance(object)) {\n            Preconditions.fail(object, clazz, message || 'Class not an instance of ' + clazz);\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeFinite(number, message) {\n        if (!Lodash.isFinite(number)) {\n            Preconditions.fail('finite', number, message || 'must be finite.');\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {String} [message]\n     * @return {Object}\n     */\n    static shouldBeObject(object, message) {\n        Preconditions.shouldBeExisting(object, message);\n\n        let fn = Utility.typeMatcher('object');\n\n        return Preconditions.shouldBe(fn, 'object', object, message || 'shouldBeObject');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldBeString(string, message) {\n        Preconditions.shouldBeExisting(string);\n\n        let fn = Utility.typeMatcher('string');\n\n        return Preconditions.shouldBe(fn, 'object', string, message);\n    }\n\n    /**\n     *\n     * @param {String} typeName\n     * @param {*} value\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeType(typeName, value, message) {\n        return Preconditions.shouldBe(Utility.typeMatcher(typeName), typeName, value, message);\n    }\n\n    /**\n     *\n     * @param {*} boolean\n     * @param {String} [message]\n     * @return {boolean}\n     */\n    static shouldBeTrue(boolean, message) {\n        Preconditions.shouldBeBoolean(boolean, message);\n\n        if (true === boolean) {\n            return boolean;\n        }\n\n        Preconditions.fail(boolean, true, message || 'was not true');\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @returns {Number}\n     */\n    static shouldNotBeNegativeNumber(number, message) {\n        Preconditions.shouldBeDefined(number, message);\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number < 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {boolean} boolean\n     * @param {String} [message]\n     */\n    static shouldBeBoolean(boolean, message) {\n        Preconditions.shouldBeDefined(boolean);\n\n        if (!Utility.isBoolean(boolean)) {\n            Preconditions.fail('boolean', boolean, message || 'was not boolean');\n        }\n\n        return boolean;\n    }\n\n    /**\n     *\n     * @param {*} number1\n     * @param {*} number2\n     * @param {String} [message]\n     */\n    static shouldBeGreaterThan(number1, number2, message) {\n        Preconditions.shouldBeNumber(number1, message);\n        Preconditions.shouldBeNumber(number2, message);\n\n        if (number1 <= number2) {\n            Preconditions.fail('larger than ' + number2, number1, message);\n        }\n\n        return number1;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBePositiveNumber(number, message) {\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number <= 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n}"]}