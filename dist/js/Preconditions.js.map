{"version":3,"sources":["../../src/js/Preconditions.js"],"names":[],"mappings":"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","file":"Preconditions.js","sourcesContent":["'use strict';\n\nimport Utility from \"./Utility\";\nimport Lodash from \"lodash/index\";\nimport CoreObject from './CoreObject';\nimport AbstractError from './errors/AbstractError';\nimport { Errors, PreconditionsError } from './errors';\n\n// class PreconditionsError extends AbstractError {\n//\n//     /**\n//      *\n//      * @param {*} actualValue\n//      * @param {*} expectedValue\n//      * @param {String} [message]\n//      * @param {Error} [optionalCause]\n//      * @constructor\n//      */\n//     constructor(expectedValue, actualValue, message, optionalCause) {\n//         super(message);\n//\n//         console.log('capture stack A');\n//\n//         this.name = 'PreconditionsError';\n//         // this.stack = error.stack;\n//         this.cause = optionalCause;\n//\n//         this.expectedValue = expectedValue || '';\n//         this.actualValue = actualValue || '';\n//         this.message = `failure (expected: ${this.expectedValue}) (actual: ${this.actualValue}) (message: ${this.message})`;\n//     }\n// }\n\n// /**\n//  *\n//  * @param {*} expectedValue\n//  * @param {*} actualValue\n//  * @param {String} [message]\n//  * @param {Error} [optionalCause]\n//  * @constructor\n//  */\n// function PreconditionsError(expectedValue, actualValue, message, optionalCause) {\n//     var error = Error.call(this, message);\n//\n//     this.name = 'PreconditionsError';\n//     this.stack = error.stack;\n//     this.cause = optionalCause;\n//\n//     this.expectedValue = expectedValue;\n//     this.actualValue = actualValue;\n//     this.message = `failure (expected: '${this.expectedValue}' [${Utility.typeOf(this.expectedValue)}]) (actual: '${this.actualValue}' [${Utility.typeOf(this.actualValue)}]) (message: ${this.message})`;\n// }\n//\n// PreconditionsError.prototype = Object.create(Error.prototype);\n// PreconditionsError.prototype.constructor = PreconditionsError;\n//\n// export { PreconditionsError }\n\n/**\n * @singleton\n * @class Preconditions\n */\nexport default class Preconditions {\n\n    /**\n     *\n     * @param {*} expectedValue\n     * @param {*} actualValue\n     * @param {String} [message]\n     */\n    static fail(expectedValue, actualValue, message) {\n        throw new PreconditionsError({\n            expectedValue: expectedValue,\n            actualValue: actualValue,\n            message: message || 'Preconditions failure'\n        });\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * return {*} object\n     */\n    static shouldBeUndefined(object, message) {\n        return Preconditions.shouldBe(Utility.isUndefined, undefined, object, message || 'must be undefined');\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldNotBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isNotFalsey, true, object, message || 'must not be falsey')\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeFalsey(object, message) {\n        return Preconditions.shouldBe(Utility.isFalsey, false, object, message || 'must be falsey')\n    }\n\n    /**\n     * This method checks for UNDEFINED, NAN, and NULL\n     *\n     * @param {*} object\n     * @param {String} [message]\n     * @return {*}\n     */\n    static shouldBeDefined(object, message) {\n        if (Utility.isUndefined(object)) {\n            Preconditions.fail('defined', 'undefined', message || 'must be defined.');\n        }\n\n        return object;\n    }\n\n    /**\n     * Make sure an object is not: undefined, null, NaN\n     *\n     * @param {*} object\n     * @param {String} [message]\n     */\n    static shouldBeExisting(object, message) {\n        return Preconditions.shouldBe(Utility.isExisting, 'exist', object, message || 'must exist.');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldNotBeBlank(string, message) {\n        Preconditions.shouldBeString(string, message || 'not blank');\n\n        return Preconditions.shouldBe(Utility.isNotBlank, 'not blank', string, message || 'must not be blank.');\n    }\n\n    /**\n     *\n     * @param {*} fn\n     * @param {String} [message]\n     * @return {function}\n     */\n    static shouldBeFunction(fn, message) {\n        return Preconditions.shouldBeType('function', fn, message);\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeNumber(number, message) {\n        Preconditions.shouldBeType('number', number, message);\n        Preconditions.shouldBeFinite(number, message);\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {function} testFn\n     * @param {*} [expectedValue]\n     * @param {*} actualValue\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBe(testFn, expectedValue, actualValue, message) {\n        if (!Utility.isFunction(testFn)) {\n            Preconditions.fail('function', testFn, `testFn must be function, but was ${Utility.typeOf(testFn)}.`);\n        }\n\n        if (!testFn.call(this, actualValue)) {\n            Preconditions.fail(expectedValue, actualValue, message || 'must pass test.');\n        }\n\n        return actualValue;\n    }\n\n    /**\n     *\n     * @param {Class|Object} object\n     * @param {Class|Object} [clazz]\n     * @param {String} [message]\n     */\n    static shouldBeClass(object, clazz, message) {\n        Preconditions.shouldBeDefined(object, 'object must be defined');\n\n        if (!clazz) {\n            clazz = CoreObject;\n        }\n\n        if (!CoreObject.isClass(clazz)) {\n            Preconditions.fail(CoreObject, clazz, 'Class not a CoreObject class');\n        }\n\n        if (!clazz.isClass(object)) {\n            Preconditions.fail(object, clazz, 'Class not a ' + clazz + ' class');\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {Class} [clazz]\n     * @param {String} [message]\n     * @returns {Object}\n     */\n    static shouldBeInstance(object, clazz, message) {\n        Preconditions.shouldBeDefined(object, message || 'object must be defined');\n\n        if (!Utility.isInstance(object)) {\n            Preconditions.fail(CoreObject, clazz, message || 'object not an instance');\n        }\n\n        if (clazz) {\n            if (!Utility.isClass(clazz)) {\n                Preconditions.fail(CoreObject, clazz, message || 'clazz not a class');\n            }\n\n            if (!clazz.isInstance(object)) {\n                Preconditions.fail(object, clazz, message || 'Class not an instance of ' + clazz);\n            }\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBeFinite(number, message) {\n        if (!Lodash.isFinite(number)) {\n            Preconditions.fail('finite', number, message || 'must be finite.');\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {Object} object\n     * @param {String} [message]\n     * @return {Object}\n     */\n    static shouldBeObject(object, message) {\n        Preconditions.shouldBeExisting(object, message);\n\n        let fn = Utility.typeMatcher('object');\n\n        return Preconditions.shouldBe(fn, 'object', object, message || 'shouldBeObject');\n    }\n\n    /**\n     *\n     * @param {*} string\n     * @param {String} [message]\n     * @return {String}\n     */\n    static shouldBeString(string, message) {\n        Preconditions.shouldBeExisting(string);\n\n        let fn = Utility.typeMatcher('string');\n\n        return Preconditions.shouldBe(fn, 'object', string, message);\n    }\n\n    /**\n     *\n     * @param {*} object\n     * @param {AbstractError} [clazz]\n     * @param {String} [message]\n     * @returns Error\n     */\n    static shouldBeError(object, clazz, message) {\n        Preconditions.shouldBeType('error', object, message || 'Should be error type');\n\n        if (clazz) {\n            if (!Errors.isErrorClass(clazz)) {\n                Preconditions.fail(Error, clazz, message || 'must be error class');\n            }\n\n            if (!clazz.isInstance(object)) {\n                Preconditions.fail(clazz, object, message || 'must be error instance.');\n            }\n        }\n\n        return object;\n    }\n\n    /**\n     *\n     * @param {String} typeName\n     * @param {*} value\n     * @param {String} [message]\n     * @returns {*}\n     */\n    static shouldBeType(typeName, value, message) {\n        return Preconditions.shouldBe(Utility.typeMatcher(typeName), typeName, value, message);\n    }\n\n    /**\n     *\n     * @param {*} boolean\n     * @param {String} [message]\n     * @return {boolean}\n     */\n    static shouldBeTrue(boolean, message) {\n        Preconditions.shouldBeBoolean(boolean, message);\n\n        if (true === boolean) {\n            return boolean;\n        }\n\n        Preconditions.fail(boolean, true, message || 'was not true');\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @returns {Number}\n     */\n    static shouldNotBeNegativeNumber(number, message) {\n        Preconditions.shouldBeDefined(number, message);\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number < 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n\n    /**\n     *\n     * @param {boolean} boolean\n     * @param {String} [message]\n     */\n    static shouldBeBoolean(boolean, message) {\n        Preconditions.shouldBeDefined(boolean);\n\n        if (!Utility.isBoolean(boolean)) {\n            Preconditions.fail('boolean', boolean, message || 'was not boolean');\n        }\n\n        return boolean;\n    }\n\n    /**\n     *\n     * @param {Array} array\n     * @param {String} [message]\n     */\n    static shouldBeArray(array, message) {\n        Preconditions.shouldBeDefined(array);\n\n        if (!Utility.isArray(array)) {\n            Preconditions.fail('array', array, message || 'was not array');\n        }\n\n        return array;\n    }\n\n    /**\n     *\n     * @param {*} number1\n     * @param {*} number2\n     * @param {String} [message]\n     */\n    static shouldBeGreaterThan(number1, number2, message) {\n        Preconditions.shouldBeNumber(number1, message);\n        Preconditions.shouldBeNumber(number2, message);\n\n        if (number1 <= number2) {\n            Preconditions.fail('larger than ' + number2, number1, message);\n        }\n\n        return number1;\n    }\n\n    /**\n     *\n     * @param {*} number\n     * @param {String} [message]\n     * @return {Number}\n     */\n    static shouldBePositiveNumber(number, message) {\n        Preconditions.shouldBeNumber(number, message);\n\n        if (number <= 0) {\n            Preconditions.fail('positive', number, message || 'Number should be positive. Was: ' + number);\n        }\n\n        return number;\n    }\n}"]}